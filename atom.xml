<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Koo&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/3f699edf093c84da2984d079893f3080</icon>
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://ElaineKoo.github.io/"/>
  <updated>2018-12-12T03:14:02.025Z</updated>
  <id>http://ElaineKoo.github.io/</id>
  
  <author>
    <name>Koo</name>
    <email>593321338@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>桥梁模式</title>
    <link href="http://ElaineKoo.github.io/2018/12/11/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/12/11/桥梁模式/</id>
    <published>2018-12-11T08:02:29.000Z</published>
    <updated>2018-12-12T03:14:02.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫桥接模式，将抽象和实现解耦，使得两者可以独立地变化</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Abstraction抽象化角色</li><li>Implementor实现化角色</li><li>RefinedAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正</li><li>ConcreteImplementor具体实现化角色</li></ol><ul><li>使用类间的聚合关系、继承、覆写等常用功能，提供一个清晰、稳定的架构 *</li></ul><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public interface Implementor &#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">    public void doAnything();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteImplementor1 implements Imlementor &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteImplementor2 implements Imlementor &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Abstraction &#123;</span><br><span class="line">    //实现化角色的引用</span><br><span class="line">    private Implement imp;</span><br><span class="line">    public Abstraction(Implementor _imp) &#123;</span><br><span class="line">        this.imp = _imp;</span><br><span class="line">    &#125;</span><br><span class="line">    //自身的行为和属性</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        this.imp.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    //获得实现化角色</span><br><span class="line">    public Implement getImp() &#123;</span><br><span class="line">        return imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RefinedAbstraction extends Abstraction &#123;</span><br><span class="line">    //覆写构造函数</span><br><span class="line">    public RefinedAbstraction(Implementor _imp) &#123;</span><br><span class="line">        super(_imp);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        super.request();</span><br><span class="line">        super.getImp().doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Implementor imp = new ConcreteImplementor1();</span><br><span class="line">        Abstraction = abs = new RefinedAbstraction(imp);</span><br><span class="line">        abs.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>抽象和实现分离，完全是为了解决继承的缺点而提出的设计模式。该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上</li><li>优秀的扩充能力。可增加实现也可增加抽象。</li><li>实现细节对客户透明</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>不希望或不适合使用继承的场景</li><li>接口或抽象类不稳定的场景</li><li>重用性要求较高的场景</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫桥接模式，将抽象和实现解耦，使得两者可以独立地变化&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Abstraction抽象化角色&lt;/li&gt;
&lt;li&gt;Implementor实现化角色&lt;/li&gt;
&lt;li&gt;RefinedAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正&lt;/li&gt;
&lt;li&gt;ConcreteImplementor具体实现化角色&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用类间的聚合关系、继承、覆写等常用功能，提供一个清晰、稳定的架构 *&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥梁模式" scheme="http://ElaineKoo.github.io/tags/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://ElaineKoo.github.io/2018/12/11/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/12/11/享元模式/</id>
    <published>2018-12-11T06:47:36.000Z</published>
    <updated>2018-12-11T07:58:51.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象</p><ul><li>两个要求：细粒度的对象和共享对象 *</li></ul><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Flyweight抽象享元角色</li><li>ConcreteFlyweight具体享元角色</li><li>unsharedConcreteFlyweight不可共享的享元角色</li><li>FlyweightFactory享元工厂</li></ol><ul><li>目的：运用共享技术，使得一些细粒度的对象可以共享，我们的设计也应该多使用细粒度的对象，便于重用或重构 *</li></ul><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Flyweight &#123;</span><br><span class="line">    //内部状态</span><br><span class="line">    private String intrinsic;</span><br><span class="line">    //外部状态</span><br><span class="line">    protected final String Extrinsic;</span><br><span class="line">    //要求享元角色必须接受外部状态</span><br><span class="line">    public Flyweight(String _Extrinsic) &#123;</span><br><span class="line">        this.Extrinsic = _Extrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义业务操作</span><br><span class="line">    public abstract void operate();</span><br><span class="line">    //内部状态的getter/setter</span><br><span class="line">    public String getIntrinsic() &#123;</span><br><span class="line">        return intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setIntrinsic(String intrinsic) &#123;</span><br><span class="line">        this.intrinsic = intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFlyweight1 extends Flyweight &#123;</span><br><span class="line">    //接受外部状态</span><br><span class="line">    public ConcreteFlyweight1(String _Extrinsic) &#123;</span><br><span class="line">        super(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据外部状态进行逻辑处理</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFlyweight2 extends Flyweight &#123;</span><br><span class="line">    //接受外部状态</span><br><span class="line">    public ConcreteFlyweight2(String _Extrinsic) &#123;</span><br><span class="line">        super(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据外部状态进行逻辑处理</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    //池容器</span><br><span class="line">    private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;String,Flyweight&gt;();</span><br><span class="line">    //享元工厂</span><br><span class="line">    public static Flyweight getFlyweight(String Extrinsic) &#123;</span><br><span class="line">        //需要返回的对象</span><br><span class="line">        Flyweight = flyweight = null;</span><br><span class="line">        //在池中没有该对象</span><br><span class="line">        if(!pool.containsKey(Extrinsic)) &#123;</span><br><span class="line">            flyweight = pool.get(Extrinsic);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //根据外部状态创建享元对象</span><br><span class="line">            flyweight = new ConcreteFlyweight1(Extrinsic);</span><br><span class="line">            //放置到池中</span><br><span class="line">            pool.put(Extrinsic, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>提高系统复杂性，需要分离外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>系统中存在大量的相似对象</li><li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份</li><li>需要缓冲池的场景</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>线程安全问题</li><li>性能平衡</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个要求：细粒度的对象和共享对象 *&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Flyweight抽象享元角色&lt;/li&gt;
&lt;li&gt;ConcreteFlyweight具体享元角色&lt;/li&gt;
&lt;li&gt;unsharedConcreteFlyweight不可共享的享元角色&lt;/li&gt;
&lt;li&gt;FlyweightFactory享元工厂&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;目的：运用共享技术，使得一些细粒度的对象可以共享，我们的设计也应该多使用细粒度的对象，便于重用或重构 *&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="享元模式" scheme="http://ElaineKoo.github.io/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>解释器模式</title>
    <link href="http://ElaineKoo.github.io/2018/12/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/12/05/解释器模式/</id>
    <published>2018-12-05T08:49:08.000Z</published>
    <updated>2018-12-05T09:13:09.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>AbstractExpression抽象解释器</li><li>TerminalExpression终结符表达式 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。主要是处理场景元素和数据的转换。</li><li>NonterminalExpression非终结符表达式 文法中的每条规则对应于一个非中介表达式</li><li>Context环境角色</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Expression &#123;</span><br><span class="line">    //每个表达式必须有一个解析任务</span><br><span class="line">    public abstract Object interpreter(Context ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TerminalExpression extends Expression &#123;</span><br><span class="line">    //通常终结符表达式只有一个，但是有多个对象</span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代表一个文法规则</span><br><span class="line">public class NonterminalExpression extends Expression &#123;</span><br><span class="line">    public NonterminalExpression(Expression... exoression) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        //进行文法处理</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context ctx = new Context();</span><br><span class="line">        Stack&lt;Expression&gt; stack = null;</span><br><span class="line">        for(;;) &#123;</span><br><span class="line">            //进行语法判断，并产生递归调用</span><br><span class="line">        &#125;</span><br><span class="line">        Expression exp = stack.php();</span><br><span class="line">        exp.interpreter(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>是一个简单语法分析工具，最显著的有点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>类膨胀</li><li>解释其模式采用递归调用方法，难以定位问题</li><li>效率问题，大量循环和递归</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>重复发生的问题可以使用解释器模式，例如：不同日志格式但数据要素相同的服务器解析</li><li>一个简单语法需要解释的场景</li></ol><p><em>尽量不要在不重要的模块使用解释器模式，维护困难，可使用脚本语言代替解释器模式</em></p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;AbstractExpression抽象解释器&lt;/li&gt;
&lt;li&gt;TerminalExpression终结符表达式 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。主要是处理场景元素和数据的转换。&lt;/li&gt;
&lt;li&gt;NonterminalExpression非终结符表达式 文法中的每条规则对应于一个非中介表达式&lt;/li&gt;
&lt;li&gt;Context环境角色&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="解释器模式" scheme="http://ElaineKoo.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/22/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/22/状态模式/</id>
    <published>2018-11-22T02:01:22.000Z</published>
    <updated>2018-11-22T03:02:59.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。核心是封装。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换</li><li>ConcreteState具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态的处理，就是本状态要做的事，以及本状态如何过渡到其他状态</li><li>Context环境角色 定义客户端需要的接口，负责具体状态的切换</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public abstract class State &#123;</span><br><span class="line">    protected Context context;</span><br><span class="line">    public void setContext(Context _context) &#123;</span><br><span class="line">        this.context = _context;</span><br><span class="line">    &#125;</span><br><span class="line">    //行为</span><br><span class="line">    public abstract void handle1();</span><br><span class="line">    public abstract void handle2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteState1 extends State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        //本状态下必须处理的逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        //设置状态</span><br><span class="line">        super.context.setCurrentState(Context.STATE2);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteState2 extends State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        //设置状态</span><br><span class="line">        super.context.setCurrentState(Context.STATE1);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handle1();</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        //本状态下必须处理的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Context &#123;</span><br><span class="line">    public final static State STATE1 = new ConcreteState1();</span><br><span class="line">    public final static State STATE2 = new ConcreteState2();</span><br><span class="line">    </span><br><span class="line">    private State = CurrentState;</span><br><span class="line">    public State getCurrentState() &#123;</span><br><span class="line">        return CurrentState;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setCurrentState(State currentState) &#123;</span><br><span class="line">        this.CurrentState = currentState;</span><br><span class="line">        //切换状态</span><br><span class="line">        this.CurrentState.setContext(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        this.CurrentState.handle1(this);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        this.CurrentState.handle2(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line">        context.setCurrentState(new ConcreteState1());</span><br><span class="line">        context.handel1();</span><br><span class="line">        context.handel2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>把状态对象声明为静态常量</em><br><em>环境角色（Context）具有状态抽象角色（State）定义的所有行为，具有执行使用委托方式</em></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>结构清晰 避免使用过多的switch..case或者if..else，避免程序的复杂性，提高系统的可维护性</li><li>遵循设计原则 很好体现了开闭原则和单一职责原则，增加状态就增加一个子类，修改状态就修改一个子类</li><li>封装性非常好 状态变换放置到类的内部实现，外部的调用不用知道类内部如何实现状态和行为的变换</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>子类太多，类膨胀，不好管理</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>行为随状态改变而改变</li><li>条件、分支判断语句的替代者</li></ol><p><em>适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个</em></p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。核心是封装。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换&lt;/li&gt;
&lt;li&gt;ConcreteState具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态的处理，就是本状态要做的事，以及本状态如何过渡到其他状态&lt;/li&gt;
&lt;li&gt;Context环境角色 定义客户端需要的接口，负责具体状态的切换&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="访问者模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/访问者模式/</id>
    <published>2018-11-21T08:04:39.000Z</published>
    <updated>2018-11-21T10:20:48.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Visitor抽象访问者 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的</li><li>ConcreteVisitor具体访问者 影响访问者访问到一个类后该怎么干，要做什么事</li><li>Element抽象元素 接口或抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义</li><li>ConcreteElement具体元素 实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了</li><li>ObjectStructure结构对象 元素产生者，一般容纳多个不同类、不同接口的容器，如List、Set、Map等</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Element &#123;</span><br><span class="line">    //业务逻辑</span><br><span class="line">    public abstract void doSomething();</span><br><span class="line">    //允许谁来访问</span><br><span class="line">    public abstract void accept(Ivisitor visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public classConcreteElement1 extends Element &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void accept(Ivisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public classConcreteElement2 extends Element &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void accept(Ivisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IVisitor &#123;</span><br><span class="line">    public void visit(ConcreteElement1 el1);</span><br><span class="line">    public void visit(ConcreteElement2 el2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Visitor implements IVisitor &#123;</span><br><span class="line">    public void visit(ConcreteElement1 el1) &#123;</span><br><span class="line">        el1.doSomething();</span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    public void visit(ConcreteElement2 el2) &#123;</span><br><span class="line">        el2.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//模拟</span><br><span class="line">public class ObjectStructure &#123;</span><br><span class="line">    public static Element createElement() &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line">        if(rand.nextInt(100) &gt; 50) &#123;</span><br><span class="line">            return new ConcreteElement1();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new ConcreteElement2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0; i&lt;10; i++)&#123;</span><br><span class="line">            Element el = ObjectStructure.createElement();</span><br><span class="line">            el.accept(new Visitor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>符合单一职责原则</li><li>优秀的扩展性</li><li>灵活性非常高</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>具体元素对访问者公布细节 访问者要访问一个类就必然要求这个类公布一些方法和数据，违反迪米特法则</li><li>具体元素变更比较困难 具体元素角色增加。删除。修改都是比较困难的</li><li>违背了依赖倒置原则 访问者依赖的是具体元素，而不是抽象元素，破坏了依赖倒置原则</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作</li><li>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作”污染”这些对象的类</li></ol><p><em>业务规则要求遍历多个不同的对象，这本身也是访问者模式的出发点，迭代器模式只能访问同类或同接口的数据，而访问者模式是对迭代器模式的补充，可以遍历不同的对象，然后执行不同的操作</em><br><em>还有一个用途，充当拦截器（Interceptor）</em></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>统计功能</li><li>多个访问者</li><li>双分派 双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>通过访问者模式可以容易地把一些功能进行梳理，达到最终目的——功能集中化，如一个统一的报表运算、UI展现等，我们还可以与其他模式混编建立一套自己的过滤器或者拦截器</p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Visitor抽象访问者 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的&lt;/li&gt;
&lt;li&gt;ConcreteVisitor具体访问者 影响访问者访问到一个类后该怎么干，要做什么事&lt;/li&gt;
&lt;li&gt;Element抽象元素 接口或抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义&lt;/li&gt;
&lt;li&gt;ConcreteElement具体元素 实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了&lt;/li&gt;
&lt;li&gt;ObjectStructure结构对象 元素产生者，一般容纳多个不同类、不同接口的容器，如List、Set、Map等&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="访问者模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/备忘录模式/</id>
    <published>2018-11-21T06:33:25.000Z</published>
    <updated>2018-11-21T07:46:52.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在不破坏封装性的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态。这样以后就可将该对象回复到原先保存的状态。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Originator发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据</li><li>Memento备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态</li><li>Caretaker备忘录管理员角色 对备忘录进行管理、保存和提供备忘录</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        return new Memento(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    public void restoreMemento(Memento _memento) &#123;</span><br><span class="line">        this.setState(_memento.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Memento &#123;</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    public Memento(String _state) &#123;</span><br><span class="line">        this.state = _state;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Caretaker &#123;</span><br><span class="line">    private Memento memento;</span><br><span class="line">    public Memento getMemento() &#123;</span><br><span class="line">        return memento;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMemento(Memento memento) &#123;</span><br><span class="line">        this.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Originator originator = new Originator();</span><br><span class="line">        Caretaker caretaker = new Caretaker();</span><br><span class="line">        caretaker.setMemento(origunator.createMemento());</span><br><span class="line">        originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要保存和恢复数据的相关状态场景</li><li>提供一个可回滚的操作</li><li>需要监控的副本场景中 备份一个主线程中的对象，然后由分析程序来分析</li><li>数据库连接的事务管理就是用备忘录模式</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>备忘录的生命期 主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理</li><li>备忘录的性能 不要频繁建立备份的场景中使用备忘录模式，原因一：控制不了备忘录建立的对象数量；原因二：大对象的建立消耗资源，系统的性能需要考虑</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>clone方式的备忘录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Originator implements Cloneable &#123;</span><br><span class="line">    private Originator backup;</span><br><span class="line">    //内部状态</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        this.backup = this.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public void restoreMemento() &#123;</span><br><span class="line">        this.setState(this.backup.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected Originator clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Originator)super.clone();</span><br><span class="line">        &#125; catch(CloneNotSupporteException e) &#123;</span><br><span class="line">            e.printStackTace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void mian(String[] args) &#123;</span><br><span class="line">        Originator = originator = new Originator();</span><br><span class="line">        originator.setState(&quot;初始状态..&quot;);</span><br><span class="line">        originator.createMemento();        </span><br><span class="line">        originator.setState(&quot;修改后的状态..&quot;);</span><br><span class="line">        originator.restoreMemento();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多状态的备忘录模式</p></li><li>多备份的备忘录</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在不破坏封装性的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态。这样以后就可将该对象回复到原先保存的状态。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Originator发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据&lt;/li&gt;
&lt;li&gt;Memento备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态&lt;/li&gt;
&lt;li&gt;Caretaker备忘录管理员角色 对备忘录进行管理、保存和提供备忘录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="备忘录模式" scheme="http://ElaineKoo.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>门面模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/门面模式/</id>
    <published>2018-11-21T05:57:42.000Z</published>
    <updated>2018-11-21T06:30:43.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>又叫外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Facade门面角色 此角色知晓子系统的所有功能和责任</li><li>subsystem子系统角色 可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道门面的存在。</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ClassA &#123;</span><br><span class="line">    public void doSomethingA() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassB &#123;</span><br><span class="line">    public void doSomethingB() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassC &#123;</span><br><span class="line">    public void doSomethingC() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Facade &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassB b = new ClassB();</span><br><span class="line">    private ClassC c = new ClassC();</span><br><span class="line">    </span><br><span class="line">    public void methodA() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodB() &#123;</span><br><span class="line">        this.a.doSomethingB();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodC() &#123;</span><br><span class="line">        this.a.doSomethingC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>减少系统的相互依赖 所有的依赖都是对门面对象的依赖，与子系统无关</li><li>提高了灵活性 依赖减少了，灵活性自然提高了</li><li>提高安全性 想让你访问子系统的哪些业务就开通哪些逻辑</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>最大的缺点是不符合开闭原则，如果要修改，唯一能做的就是修改门面角色的代码，风险相当大</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>为一个复杂的模块或子系统提供一个供外界访问的接口</li><li>子系统相对独立，外界对子系统的访问只要黑箱操作即可</li><li>预防低水平人员带来的风险扩散</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>一个子系统可以有多个门面，(1)门面可拆分 (2)子系统可以提供不同的访问路径，新增一个引用原有门面的门面</li><li>门面不参与子系统内的业务逻辑，门面对象只是提供一个访问子系统的一个路径而已，不应该参与具体的业务逻辑，否则会产生一个倒依赖的问题：子系统必须依赖门面才能被访问，不仅违反了单一职责原则，同事也破坏了系统的封装性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassC c = new ClassC();</span><br><span class="line">    public void complexMethod() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">        this.c.doSomethingC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Facade &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassB b = new ClassB();</span><br><span class="line">    private Context context = new Context();</span><br><span class="line">    </span><br><span class="line">    public void methodA() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodB() &#123;</span><br><span class="line">        this.a.doSomethingB();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodC() &#123;</span><br><span class="line">        this.context.complexMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;又叫外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Facade门面角色 此角色知晓子系统的所有功能和责任&lt;/li&gt;
&lt;li&gt;subsystem子系统角色 可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道门面的存在。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="门面模式" scheme="http://ElaineKoo.github.io/tags/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/观察者模式/</id>
    <published>2018-11-21T03:01:52.000Z</published>
    <updated>2018-11-21T05:56:50.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Subject被观察者</li><li>Observer观察者</li><li>ConcreteSubject具体的被观察者</li><li>ConcreteObserver具体的观察者</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subject &#123;</span><br><span class="line">    private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();</span><br><span class="line">    public void addObserver(Observer o) &#123;</span><br><span class="line">        this.obsVector.add(o);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void delObserver(Observer o) &#123;</span><br><span class="line">        this.obsVector.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for(Observer o:this.obsVector) &#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject extends Subject &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        super.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">    public void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserver implements Observer &#123;</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;接收到信息，并进行处理！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line">        Observer obs = new ConcreteObserver();</span><br><span class="line">        subject.addObserver(obs);</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>观察者和被观察者之间是抽象耦合</li><li>建立一套触发机制</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>顺序执行，一个观察者卡壳，影响整体，一般考虑采用异步方式</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>关联行为场景</li><li>事件多级触发场景</li><li>跨系统的消息交换场景，如消息队列处理机制</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>广播链问题 一个观察者模式中最多出现一个对象既是观察者也是被观察者，消息最多转发一次。</li><li>异步处理问题</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>文件系统</li><li>猫鼠游戏</li><li>ATM取钱</li><li>广播收音机</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Subject被观察者&lt;/li&gt;
&lt;li&gt;Observer观察者&lt;/li&gt;
&lt;li&gt;ConcreteSubject具体的被观察者&lt;/li&gt;
&lt;li&gt;ConcreteObserver具体的观察者&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="http://ElaineKoo.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/组合模式/</id>
    <published>2018-11-21T02:35:40.000Z</published>
    <updated>2018-11-21T03:01:29.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫合成模式、整体模式。将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Component抽象构件角色 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性</li><li>Leaf叶子构件 叶子对象</li><li>Composite树枝构件 树枝对象</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Composite extends Component &#123;</span><br><span class="line">    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();</span><br><span class="line">    public void add(Component component) &#123;</span><br><span class="line">        this.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove(Component component) &#123;</span><br><span class="line">        this.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line">    public ArrayList&lt;Component&gt; getChildren() &#123;</span><br><span class="line">        return this.componentArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Leaf extends Component &#123;</span><br><span class="line">    //可以覆写</span><br><span class="line">    public void doSomething() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Composite root new Composite();</span><br><span class="line">        root.doSomething();</span><br><span class="line">        Composite branch = new Composite();</span><br><span class="line">        Leaf leaf = new Leaf();</span><br><span class="line">        root.add(branch);</span><br><span class="line">        branch.add(leaf);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void display(Composite root) &#123;</span><br><span class="line">        for(Component c:root.getChildren()) &#123;</span><br><span class="line">            if(c instanceof Leaf) &#123;</span><br><span class="line">                c.doSomething();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                display((Composite)c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>高层模块调用简单</li><li>节点自由增加</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>与依赖倒置原则冲突</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</li><li>从一个整体中能够独立出部分模块或功能的场景。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫合成模式、整体模式。将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Component抽象构件角色 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性&lt;/li&gt;
&lt;li&gt;Leaf叶子构件 叶子对象&lt;/li&gt;
&lt;li&gt;Composite树枝构件 树枝对象&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="组合模式" scheme="http://ElaineKoo.github.io/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/20/迭代器模式/</id>
    <published>2018-11-20T10:16:30.000Z</published>
    <updated>2018-11-20T10:48:49.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它提供一种方法访问一个容器对象中的各个元素，而不需要暴露该对象的内部细节。<br>没落的模式，基本么有人会单独写一个迭代器。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Iterator抽象迭代器 first，next，isDone</li><li>ConcreteIterator具体迭代器</li><li>Aggregate抽象容器 容器角色负责提供创建具体迭代器角色的接口</li><li>ConcreteAggregate具体容器 实现容器接口定义的方法，创建出容纳迭代器的对象</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">    public Object next();</span><br><span class="line">    public boolean hasNext();</span><br><span class="line">    public boolean remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ConcreteInterator implements Ieterator &#123;</span><br><span class="line">    private Vector vector = new Vector();</span><br><span class="line">    </span><br><span class="line">    public int cursor = 0;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public ConcreteIeterator(Vector _vector) &#123;</span><br><span class="line">        this.vector = _vector;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        if(this.cursor == this.vector.size()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object next() &#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        if(this.hasNext()) &#123;</span><br><span class="line">            result = this.vector.get(this.cursor++);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove() &#123;</span><br><span class="line">        this.vector.remove(this.cursor);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Aggregate &#123;</span><br><span class="line">    public void add(Object object);</span><br><span class="line">    public void remove(Object object);</span><br><span class="line">    public Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteAggregate implements Aggregate &#123;</span><br><span class="line">    private Vector vector = new Vector();</span><br><span class="line">    public void add(Object object) &#123;</span><br><span class="line">        this.vector.add(object);</span><br><span class="line">    &#125;</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new ConcreteIterator(this.vector);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove(Object object) &#123;</span><br><span class="line">        this.remove(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Aggregate agg = new ConcreteAggregate();</span><br><span class="line">        agg.add(&quot;abc&quot;);</span><br><span class="line">        agg.add(&quot;aaa&quot;);</span><br><span class="line">        agg.add(&quot;1234&quot;);</span><br><span class="line">        </span><br><span class="line">        Iterator iterator = agg.iterator();</span><br><span class="line">        while(iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;它提供一种方法访问一个容器对象中的各个元素，而不需要暴露该对象的内部细节。&lt;br&gt;没落的模式，基本么有人会单独写一个迭代器。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Iterator抽象迭代器 first，next，isDone&lt;/li&gt;
&lt;li&gt;ConcreteIterator具体迭代器&lt;/li&gt;
&lt;li&gt;Aggregate抽象容器 容器角色负责提供创建具体迭代器角色的接口&lt;/li&gt;
&lt;li&gt;ConcreteAggregate具体容器 实现容器接口定义的方法，创建出容纳迭代器的对象&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="http://ElaineKoo.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/20/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/20/适配器模式/</id>
    <published>2018-11-20T06:18:48.000Z</published>
    <updated>2018-11-21T06:07:34.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>又叫变压器模式、包装模式，将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</p><h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><ol><li>Target目标角色</li><li>Adaptee源角色</li><li>Adapter适配器角色</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Target &#123;</span><br><span class="line">    //目标角色有自己的方法</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public vlass ConcreteTarget implements Target &#123;</span><br><span class="line">    pubilc void request() &#123;</span><br><span class="line">        System.out.println(&quot;xxxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;zzzzz&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public vlass Adapter extends Adaptee implements Target &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        super.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //原</span><br><span class="line">        Target target = new ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line">        //适配器</span><br><span class="line">        Target target2 = new Adapter();</span><br><span class="line">        target2.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>适配器模式可以让两个没有任何关系的类在一起运行</li><li>增加了类的透明性</li><li>提高类的复用度</li><li>灵活性非常好</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>你有动机修改一个已经投产中的接口时</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要在开发阶段考虑，解决的是正在服役中的项目问题<br>项目一定要遵守依赖倒置原则和里氏替换原则</p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;又叫变压器模式、包装模式，将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作&lt;/p&gt;
&lt;h2 id=&quot;三个角色&quot;&gt;&lt;a href=&quot;#三个角色&quot; class=&quot;headerlink&quot; title=&quot;三个角色&quot;&gt;&lt;/a&gt;三个角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Target目标角色&lt;/li&gt;
&lt;li&gt;Adaptee源角色&lt;/li&gt;
&lt;li&gt;Adapter适配器角色&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://ElaineKoo.github.io/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/20/策略模式/</id>
    <published>2018-11-20T02:56:10.000Z</published>
    <updated>2018-11-20T06:12:22.534Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫做政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Context封装角色 上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化</li><li>Strategy抽象策略角色 策略算法的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性</li><li>ConcreteStrategy具体策略角色 实现抽象策略</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategy1 implements Strategy &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategy2 implements Strategy &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重点：封装角色，借用了代理模式的思路，区别在于策略模式的封装角色和被封装的策略类不用是同一个接口，如果是同一个接口就成为代理模式</span><br><span class="line">public class Context &#123;</span><br><span class="line">    private Strategy strategy = null;</span><br><span class="line">    public Context(Strategy _strategy) &#123;</span><br><span class="line">        this.strategy = _strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">        this.strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Strategy strategy = new ConcreteStrategy1();</span><br><span class="line">        Context context = new Context(strategy);</span><br><span class="line">        context.doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>算法可以自由切换</li><li>避免使用多重条件判断</li><li>扩展性良好</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>策略类数量增多 复用可能性小，类数量增多</li><li>所有策略类都要对外暴露 违反迪米特法则，可使用其他模式修正缺陷，如工厂方法模式、代理模式或享元模式</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个类只有在算法或行为上稍有不同的场景</li><li>算法需要自由切换的场景</li><li>需要屏蔽算法规则的场景</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀或对外暴露的问题。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>策略枚举</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫做政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Context封装角色 上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化&lt;/li&gt;
&lt;li&gt;Strategy抽象策略角色 策略算法的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性&lt;/li&gt;
&lt;li&gt;ConcreteStrategy具体策略角色 实现抽象策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="http://ElaineKoo.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/装饰模式/</id>
    <published>2018-11-19T10:39:59.000Z</published>
    <updated>2018-11-20T02:45:20.269Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。</p><h2 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h2><ol><li>Component抽象构件 定义最核心、最原始的对象</li><li>ConcreteComponent具体构件 最核心、最原始的对象的实现</li><li>Decorator装饰角色 一般是一个抽象类，实现接口或者抽象方法，里面不一定有抽象的方法，属性里必然有一个private变量指向Component抽象构件</li><li>具体装饰角色</li></ol><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public abstract void operate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteComponent extends Component &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        System.out.println(&apos;do Something&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Decorator extends Component &#123;</span><br><span class="line">    private Component component = null;</span><br><span class="line">    public Decorator(Component _component) &#123;</span><br><span class="line">        this.component = _component;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        this.component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecorator1 extends Decorator &#123;</span><br><span class="line">    publicConcreteDecorator1(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void method1() &#123;</span><br><span class="line">        System.out,println(&apos;method 1 修饰&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Operate() &#123;</span><br><span class="line">        this.method1();</span><br><span class="line">        super.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecorator2 extends Decorator &#123;</span><br><span class="line">    publicConcreteDecorator1(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void method2() &#123;</span><br><span class="line">        System.out,println(&apos;method 1 修饰&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Operate() &#123;</span><br><span class="line">        super.operate();</span><br><span class="line">        this.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Component component = new ConcreteComponent();</span><br><span class="line">        component = new ConcreteDecorator1(component);</span><br><span class="line">        component = new ConcreteDecorator2(component);</span><br><span class="line">        component.operator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>装饰类和被装饰类可以独立发展，不会互相耦合。</li><li>装饰模式是继承关系的一个替代方案。</li><li>装饰模式可以动态扩展一个实现类的功能。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>多层的装饰是比较复杂的，尽量减少装饰的数量，以降低系统的复杂度</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要扩展一个类的功能，或给一个类增加附加功能</li><li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销</li><li>需要为一批的兄弟类进行改装或加装功能，首选装饰模式</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。&lt;/p&gt;
&lt;h2 id=&quot;四个角色&quot;&gt;&lt;a href=&quot;#四个角色&quot; class=&quot;headerlink&quot; title=&quot;四个角色&quot;&gt;&lt;/a&gt;四个角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Component抽象构件 定义最核心、最原始的对象&lt;/li&gt;
&lt;li&gt;ConcreteComponent具体构件 最核心、最原始的对象的实现&lt;/li&gt;
&lt;li&gt;Decorator装饰角色 一般是一个抽象类，实现接口或者抽象方法，里面不一定有抽象的方法，属性里必然有一个private变量指向Component抽象构件&lt;/li&gt;
&lt;li&gt;具体装饰角色&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰模式" scheme="http://ElaineKoo.github.io/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/责任链模式/</id>
    <published>2018-11-19T09:34:23.000Z</published>
    <updated>2018-11-19T10:18:08.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。</p><ul><li>实际应用中，一般会有一个封装类对责任模式进行封装，替代Client类，直接返回链中第一个处理者，具体链的设置不需要高层次模块关系 *</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>将请求和处理分开，解耦，提高系统灵活性</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>性能问题，每个请求都是从链头遍历到链尾</li><li>调试不方便，类似递归</li></ol><ul><li>链中节点数量控制，避免超长链，一般做法是在Handler中这是一个最大节点数量，太长则不允许链建立 * </li></ul><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractLogger &#123;</span><br><span class="line">   public static int INFO = 1;</span><br><span class="line">   public static int DEBUG = 2;</span><br><span class="line">   public static int ERROR = 3;</span><br><span class="line"> </span><br><span class="line">   protected int level;</span><br><span class="line"> </span><br><span class="line">   //责任链中的下一个元素</span><br><span class="line">   protected AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   public void setNextLogger(AbstractLogger nextLogger)&#123;</span><br><span class="line">      this.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void logMessage(int level, String message)&#123;</span><br><span class="line">      if(this.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      if(nextLogger !=null)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   abstract protected void write(String message);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConsoleLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public ConsoleLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;Standard Console::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ErrorLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public ErrorLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;Error Console::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FileLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public FileLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;File::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChainPatternDemo &#123;</span><br><span class="line">   </span><br><span class="line">   private static AbstractLogger getChainOfLoggers()&#123;</span><br><span class="line"> </span><br><span class="line">      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"> </span><br><span class="line">      errorLogger.setNextLogger(fileLogger);</span><br><span class="line">      fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"> </span><br><span class="line">      return errorLogger;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, </span><br><span class="line">         &quot;This is an information.&quot;);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </span><br><span class="line">         &quot;This is an debug level information.&quot;);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </span><br><span class="line">         &quot;This is an error information.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Standard Console::Logger: This is an information.</span><br><span class="line">File::Logger: This is an debug level information.</span><br><span class="line">Standard Console::Logger: This is an debug level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">File::Logger: This is an error information.</span><br><span class="line">Standard Console::Logger: This is an error information.</span><br></pre></td></tr></table></figure></p><p>参考<br>《设计模式之禅》<br><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际应用中，一般会有一个封装类对责任模式进行封装，替代Client类，直接返回链中第一个处理者，具体链的设置不需要高层次模块关系 *&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;p&gt;将请求和处理分开，解耦，提高系统灵活性&lt;/p&gt;
&lt;h2 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;性能问题，每个请求都是从链头遍历到链尾&lt;/li&gt;
&lt;li&gt;调试不方便，类似递归&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;链中节点数量控制，避免超长链，一般做法是在Handler中这是一个最大节点数量，太长则不允许链建立 * &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="责任链模式" scheme="http://ElaineKoo.github.io/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/命令模式/</id>
    <published>2018-11-19T08:36:11.000Z</published>
    <updated>2018-11-19T09:34:09.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Receive接收者角色</li><li>Command命令角色</li><li>Invoker调用者角色</li></ol><ul><li>封装性好，把请求方（Invoker）和执行方（Receiver）分开 *</li></ul><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Receiver &#123;</span><br><span class="line">    //抽象接收者，定义每个接收者都必须完成的业务</span><br><span class="line">    public abstract void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteReceiver1 extends Receiver &#123;</span><br><span class="line">    //每个接收者都必须处理一定的业务逻辑</span><br><span class="line">    public void doSomthing()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteReceiver2 extends Receiver &#123;</span><br><span class="line">    //每个接收者都必须处理一定的业务逻辑</span><br><span class="line">    public void doSomthing()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Command &#123;</span><br><span class="line">    //每个命令都有一个执行命令的方法</span><br><span class="line">    public abstract void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteCommand1 extends Command &#123;</span><br><span class="line">    //对哪个Receiver类进行命令处理</span><br><span class="line">    private Receiver receiver;</span><br><span class="line">    public ConcreteCommand1(Receiver _receiver) &#123;</span><br><span class="line">        this.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteCommand2 extends Command &#123;</span><br><span class="line">    //对哪个Receiver类进行命令处理</span><br><span class="line">    private Receiver receiver;</span><br><span class="line">    public ConcreteCommand2(Receiver _receiver) &#123;</span><br><span class="line">        this.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Invoker &#123;</span><br><span class="line">    private Command command;</span><br><span class="line">    //接受命令</span><br><span class="line">    public void setCommand(Command _command) &#123;</span><br><span class="line">        this.command = _command;</span><br><span class="line">    &#125;</span><br><span class="line">    public void action() &#123;</span><br><span class="line">        this.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Invoker invoker = new Invoker();</span><br><span class="line">        Receiver receiver = new ConcreteReceiver1();</span><br><span class="line">        Command command = new ConcreteCommand1(receiver);</span><br><span class="line">        </span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>类间解耦 调用者角色与接收者角色之间没有任何依赖关系，不需要了解到底是哪个接收者执行</li><li>可扩展性 Command子类非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合</li><li>命令模式结合其他模式会更优秀 可以结合责任链模式，实现命令族解析任务；结合模板方法模式，减少Command子类的膨胀问题</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>如果有N个命令，Command的子类就是N个，类膨胀非常大</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>只要你任务是命令的地方，例如GUI开发中的一个按钮点击；模拟DOS命令；触发-反馈机制的处理等</p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Receive接收者角色&lt;/li&gt;
&lt;li&gt;Command命令角色&lt;/li&gt;
&lt;li&gt;Invoker调用者角色&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;封装性好，把请求方（Invoker）和执行方（Receiver）分开 *&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="命令模式" scheme="http://ElaineKoo.github.io/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/中介者模式/</id>
    <published>2018-11-19T07:31:20.000Z</published>
    <updated>2018-11-19T08:45:44.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫调停者模式<br>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li>Mediator 抽象中介者角色<br>定义统一的接口，用于各同事角色之间的通信</li><li>Concrete Mediator 具体中介者角色<br>通过协调各同事角色实现协作行为，必须依赖于各个同事角色</li><li>Colleague 同事角色<br>每个同事角色都知道中介者角色，而且与其他的同事角色通信时，一定要通过中介者角色协作。<br>每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。</li></ol><a id="more"></a><h2 id="通用源代码"><a href="#通用源代码" class="headerlink" title="通用源代码"></a>通用源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Mediator &#123;</span><br><span class="line">    //定义同事类</span><br><span class="line">    protected ConcreteColleague1 c1;</span><br><span class="line">    protected ConcreteColleague2 c2;</span><br><span class="line">    </span><br><span class="line">    //注入同事类</span><br><span class="line">    public ConcreteColleague1 getC1() &#123;</span><br><span class="line">        return c1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setC1(ConcreteColleague1 c1) &#123;</span><br><span class="line">        this.c1 = c1; </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public ConcreteColleague2 getC2() &#123;</span><br><span class="line">        return c2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setC2(ConcreteColleague2 c2) &#123;</span><br><span class="line">        this.c2 = c2; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void doSomething1();</span><br><span class="line">    public abstract void doSomething2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteMediator extends Mediator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething1() &#123;</span><br><span class="line">        super.c1.selfMethod1();</span><br><span class="line">        super.c2.selfMethod2();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void doSomething2() &#123;</span><br><span class="line">        super.c1.selfMethod1();</span><br><span class="line">        super.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Colleague &#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    public Colleague(Mediator _mediator) &#123;</span><br><span class="line">        this.mediator = _mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteColleague1 extends Colleague &#123;</span><br><span class="line">    public ConcreteColleague1(Mediator _mediator) &#123;</span><br><span class="line">        super(_mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    //自有方法</span><br><span class="line">    public void selfMethod1() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    //依赖方法</span><br><span class="line">    public void depMethod1() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">        //自己不能处理的业务逻辑，委托给中介者处理</span><br><span class="line">        super.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteColleague2 extends Colleague &#123;</span><br><span class="line">    public ConcreteColleague2(Mediator _mediator) &#123;</span><br><span class="line">        super(_mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    //自有方法</span><br><span class="line">    public void selfMethod2() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    //依赖方法</span><br><span class="line">    public void depMethod2() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">        //自己不能处理的业务逻辑，委托给中介者处理</span><br><span class="line">        super.mediator.doSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>减少类间的依赖，把原有的一对多的依赖变成一对一依赖<br>同事类只依赖中介者，减少了依赖，降低了类间的耦合</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>中介者会膨胀得很快，而且逻辑复杂，同事类越多，中介者的逻辑越复杂</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>机场调度中心</li><li>MVC框架 C就是中介者，隔开M和V，减少M和V的依赖关系。</li><li>媒体网关</li><li>中介服务</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>N个对象之间产生了相互的依赖关系（N&gt;2）</li><li>多个对象有依赖关系，但依赖的行为尚不确定或者有发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散</li><li>产品开发 提升产品的性能和扩展性</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫调停者模式&lt;br&gt;用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/p&gt;
&lt;h2 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Mediator 抽象中介者角色&lt;br&gt;定义统一的接口，用于各同事角色之间的通信&lt;/li&gt;
&lt;li&gt;Concrete Mediator 具体中介者角色&lt;br&gt;通过协调各同事角色实现协作行为，必须依赖于各个同事角色&lt;/li&gt;
&lt;li&gt;Colleague 同事角色&lt;br&gt;每个同事角色都知道中介者角色，而且与其他的同事角色通信时，一定要通过中介者角色协作。&lt;br&gt;每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="中介者模式" scheme="http://ElaineKoo.github.io/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记 laravel chunk 遇到的坑</title>
    <link href="http://ElaineKoo.github.io/2018/11/15/%E8%AE%B0laravel-chunk%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://ElaineKoo.github.io/2018/11/15/记laravel-chunk遇到的坑/</id>
    <published>2018-11-15T06:15:43.000Z</published>
    <updated>2018-11-19T07:29:11.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flight::chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //对每条数据做一些处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果’flights’表中有1000条数据，将拆成10次查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` limit 100 offset 0</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 100</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 200</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 300</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 400</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 500</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 600</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 700</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 800</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 900</span><br><span class="line">//对每条数据做一些处理</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><table><thead><tr><th>id</th><th>xx</th><th>yy  </th></tr></thead><tbody><tr><td> 1</td><td>0</td><td>0  </td></tr><tr><td> 2</td><td>0</td><td>0  </td></tr><tr><td> 3</td><td>0</td><td>0  </td></tr><tr><td> ..</td><td>..</td><td>.. </td></tr><tr><td> ..</td><td>..</td><td>..  </td></tr><tr><td>1000</td><td>0</td><td>0  </td></tr></tbody></table><h2 id="如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。"><a href="#如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。" class="headerlink" title="如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。"></a>如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flight::where(&apos;xx&apos;, 0)-&gt;chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //$res = 通过flight与关联表的关系得出来值，这也是我们为什么需要通过这种方法更新 </span><br><span class="line">        $flight-&gt;yy = $res;</span><br><span class="line">        $flight-&gt;save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更新所有xx=0的yy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 0</span><br><span class="line">update `flights` set `yy` = 152 where `id` = 1 </span><br><span class="line">update `flights` set `yy` = 12 where `id` = 2 </span><br><span class="line">update `flights` set `yy` = 123 where `id` = 3 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 52 where `id` = 99</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 100</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 100</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 101 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =102 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 103 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 199</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 200</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 200</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 201 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =202 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 203 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 299</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 300</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 300</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 400</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 500</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 600</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 700</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 800</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 900</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 901 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =902 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 903 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 999</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 1000</span><br></pre></td></tr></table></figure><h2 id="如果我们按yy进行筛选，更新yy字段，这样就会出问题。"><a href="#如果我们按yy进行筛选，更新yy字段，这样就会出问题。" class="headerlink" title="如果我们按yy进行筛选，更新yy字段，这样就会出问题。"></a>如果我们按yy进行筛选，更新yy字段，这样就会出问题。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flight::where(&apos;yy&apos;, 0)-&gt;chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //$res = 通过flight与关联表的关系得出来值(反正不是0)，这也是我们为什么需要通过这种方法更新 </span><br><span class="line">        $flight-&gt;yy = $res;</span><br><span class="line">        $flight-&gt;save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更新所有yy=0的yy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 0</span><br><span class="line">update `flights` set `yy` = 152 where `id` = 1 </span><br><span class="line">update `flights` set `yy` = 12 where `id` = 2 </span><br><span class="line">update `flights` set `yy` = 123 where `id` = 3 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 52 where `id` = 99</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 100</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 100</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 201 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =202 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 203 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 299</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 300</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 200</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 401 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =402 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 403 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 499</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 400</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 300</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 601 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =602 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 603 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 699</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 600</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 400</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 801 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =802 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 803 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 899</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 800</span><br></pre></td></tr></table></figure><p>很困惑，为什么表中还是有yy=0的数据。<br>在执行 <code>select * from flights where  yy = 0 limit 100 offset 100</code> 之前，id=1~100的数据yy已经不等于0了，所以在执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 100</span><br></pre></td></tr></table></figure></p><p>的时候，搜索出的是id=201~300的数据，而id=101~200的数据，只有在再次搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 0</span><br></pre></td></tr></table></figure></p><p>的时候才会出现。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>所以，我们要避免使用 chunk 的时候，更改和过滤条件的字段的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Flight::chunk(100, function ($flights) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foreach ($flights as $flight) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果’flights’表中有1000条数据，将拆成10次查询：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 300&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 400&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 600&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 700&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 900&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="laravel" scheme="http://ElaineKoo.github.io/tags/laravel/"/>
    
      <category term="php" scheme="http://ElaineKoo.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/13/原型模式/</id>
    <published>2018-11-13T07:26:06.000Z</published>
    <updated>2018-11-19T04:30:35.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式<br>简单程度仅次于单例模式和迭代器模式，使用广泛<br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建的对象<br>核心就是clone方法，通过该方法进行对象的拷贝，JAVA提供了Cloneable接口，标示这个对象是可拷贝的。覆写clone方法。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>性能优良。原型模式是内存二进制流的拷贝。</li><li>逃避构造函数的约束。不执行构造函数，优点和缺点都是减少了约束。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>资源优化场景。类初始化需要消化非常多的资源，包括数据和硬件资源等。</li><li>性能和安全要求的场景。通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li><li>一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时。</li></ol><p><em>原型模式很少单独出现，一般和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</em></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>构造函数不会被执行</li><li>浅拷贝和深拷贝<br><em>使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变类型</em></li><li>clone与final关键字冲突</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式&lt;br&gt;简单程度仅次于单例模式和迭代器模式，使用广泛&lt;br&gt;用原型
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="原型模式" scheme="http://ElaineKoo.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/13/代理模式/</id>
    <published>2018-11-13T05:42:28.000Z</published>
    <updated>2018-11-19T04:30:35.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫委托模式，为其他对象提供一种代理，以控制对这个对象的访问。使用率非常高。提供非常好的访问控制。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Subject抽象主题角色。可以是抽象类也可以是接口</li><li>RealSubject具体主题角色。也称为被委托角色或被代理角色，业务逻辑的具体执行者</li><li>Proxy代理主题角色。也称为委托类、代理类</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        //业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Proxy implements Subject &#123;</span><br><span class="line">    private Subject subject = null;</span><br><span class="line">    </span><br><span class="line">    public Proxy() &#123;</span><br><span class="line">        this.subject = new Proxy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Proxy(Subject subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void request() &#123;</span><br><span class="line">        this.before();</span><br><span class="line">        this.subject.request();</span><br><span class="line">        this.after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void before() &#123;&#125;</span><br><span class="line">    public void after() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>职责清晰。真实角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰</li><li>高扩展性。具体主题角色随时发生变化，不管怎么变化，只要实现了接口，那代理类完全就可以在不做任何修改的情况下使用。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Spring AOP</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>普通代理，要求客户端只能访问代理角色，而不能访问真实角色。<br>普通代理模式的约束问题，尽量通过团队内的变成规范类约束，因为每一个主题类是可被重用的和可维护的，实用技术约束的方式对系统维护是一种非常不利的因素</li><li>强制代理，强制必须通过真是角色查找到代理角色，否则不能访问。只有通过真实角色指定的代理类才可以访问，由真是角色管理代理角色。可以不知道代理的存在，但是你的所作所为还是需要代理为你提供。</li><li>代理是有个性的。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能。可以代理多个真实角色。</li><li>动态代理。动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪个对象。横切面编程（AOP）核心就是动态代理机制。？？</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫委托模式，为其他对象提供一种代理，以控制对这个对象的访问。使用率非常高。提供非常好的访问控制。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://ElaineKoo.github.io/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/13/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/13/建造者模式/</id>
    <published>2018-11-13T03:12:56.000Z</published>
    <updated>2018-11-19T04:30:35.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CarBuilder &#123;</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public abstract void setSequence(ArrayList&lt;String&gt; sequence);</span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public abstract CarModel getCarModel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BenzBuilder extends CarBuilder &#123;</span><br><span class="line">    private BenzModel benz = new BenzModel();</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public void setSequence(ArrayList&lt;String&gt; sequence)&#123;</span><br><span class="line">        this.benz.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public CarModel getCarModel() &#123;</span><br><span class="line">        return this.benz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BMWBuilder extends CarBuilder &#123;</span><br><span class="line">    private BMWModel bmw = new BMWModel();</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public void setSequence(ArrayList&lt;String&gt; sequence)&#123;</span><br><span class="line">        this.bmw.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public CarModel getCarModel() &#123;</span><br><span class="line">        return this.bmw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Director &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; sequence = new ArrayList();</span><br><span class="line">    private BenzBuilder benzBuilder = new BenzBuilder();</span><br><span class="line">    private BMWBuilder bmwBuilder = new bmwBuilder();</span><br><span class="line">    </span><br><span class="line">    public BenzModel getABenzModel() &#123;</span><br><span class="line">        this.sequence.clear();</span><br><span class="line">        </span><br><span class="line">        this.sequesce.add(&quot;start&quot;);</span><br><span class="line">        this.sequesce.add(&quot;stop&quot;);</span><br><span class="line">        this.benzBuilder.setSequence(this.sequence);</span><br><span class="line">        return (BenzModel)this.benzBuilder.getCarModel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Director director = new Director();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            director.getABenzModel().run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>需求是无底洞，是无理性的</em></p><a id="more"></a><h2 id="导演类"><a href="#导演类" class="headerlink" title="导演类"></a>导演类</h2><p>指挥各事件的先后顺序</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><h2 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h2><ol><li>Product产品类，实现模板方法模式</li><li>Builder抽象建造类，规划产品的组建，一般由子类实现。CarBuilder</li><li>ConcreteBuilder具体建造者，实现抽象类定义好的所有方法，并且返回一个组建好的对象。BenzBuilder和BMWBuilder</li><li>Director导演类，负责安排已有模块顺序，告诉Builder开始建造。</li></ol><p><em>导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。导演类可以有多个</em></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>封装性。使用建造者模式可以使客户端不必知道产品内部组成的细节。</li><li>建造者独立，容易扩展。BenzBuilder和BMWBuilder互相独立，对系统的扩展非常有利</li><li>便于控制细节风险。建造者独立，可对建造过程逐步细化，而不对其他模块产生任何影响</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能时</li><li>在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时。补偿方法，设计阶段没有发觉。</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>建造者模式关注的是零件类型和装配工艺（顺序），与工厂方法模式最大的不同。建造者模式最主要的功能是基本方法的调用顺序安排，顺序不同产生的对象也不同；工厂方法重点是创造，创建零件是它的主要职责，组装顺序则不是它关心的。<br>使用建造者模式的时候考虑一下模板方法模式。</p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码实例&quot;&gt;&lt;a href=&quot;#代码实例&quot; class=&quot;headerlink&quot; title=&quot;代码实例&quot;&gt;&lt;/a&gt;代码实例&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public abstract class CarBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置组装顺序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract void setSequence(ArrayList&amp;lt;String&amp;gt; sequence);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置完毕顺序后，就可以直接拿到这个车辆模型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public abstract CarModel getCarModel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class BenzBuilder extends CarBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private BenzModel benz = new BenzModel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置组装顺序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setSequence(ArrayList&amp;lt;String&amp;gt; sequence)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.benz.setSequence(sequence);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置完毕顺序后，就可以直接拿到这个车辆模型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public CarModel getCarModel() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.benz;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class BMWBuilder extends CarBuilder &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private BMWModel bmw = new BMWModel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置组装顺序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void setSequence(ArrayList&amp;lt;String&amp;gt; sequence)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.bmw.setSequence(sequence);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置完毕顺序后，就可以直接拿到这个车辆模型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public CarModel getCarModel() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return this.bmw;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Director &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private ArrayList&amp;lt;String&amp;gt; sequence = new ArrayList();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private BenzBuilder benzBuilder = new BenzBuilder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private BMWBuilder bmwBuilder = new bmwBuilder();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public BenzModel getABenzModel() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.sequence.clear();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.sequesce.add(&amp;quot;start&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.sequesce.add(&amp;quot;stop&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this.benzBuilder.setSequence(this.sequence);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (BenzModel)this.benzBuilder.getCarModel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class Client &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Director director = new Director();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for(int i = 0; i &amp;lt; 1000; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            director.getABenzModel().run();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;需求是无底洞，是无理性的&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="http://ElaineKoo.github.io/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
