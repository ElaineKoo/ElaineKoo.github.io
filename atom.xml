<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Koo&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/3f699edf093c84da2984d079893f3080</icon>
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://ElaineKoo.github.io/"/>
  <updated>2018-11-12T11:02:30.803Z</updated>
  <id>http://ElaineKoo.github.io/</id>
  
  <author>
    <name>Koo</name>
    <email>593321338@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/12/单例模式/</id>
    <published>2018-11-12T10:54:04.000Z</published>
    <updated>2018-11-12T11:02:30.803Z</updated>
    
    <content type="html"><![CDATA[<p>Singleton类称为单例类<br>通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式优势明显</li><li>由于单例模式只生成一个实例，所以减少了系统的性能开销。当一个对象的产生需要比较多资源的时候，如读取配置、产生其他依赖对象时，则可以通过在<em>应用启动时</em>直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li><li>单例模式可以避免对资源的多重占用，如避免对同一资源文件的同时写操作</li><li>单例模式可以在系统设置全局访问点，优化和共享资源访问。如设计一个单例类，负责所有数据表的映射处理。</li></ol><a id="more"></a><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。<br>接口对单例模式没有任何意义，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。</li><li>单一模式对测试是不利的。<br>在并行开发的环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li><li>单例模式与单一职责原则有冲突。<br>一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>要求生成唯一序列号的环境</li><li>在整个项目中需要一个共享访问点或共享数据，如web页面上的计数器</li><li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源</li><li>需要定义大量的静态常量和静态方法的环境，可以采用单例模式</li></ol><h2 id="两种常见写法"><a href="#两种常见写法" class="headerlink" title="两种常见写法"></a>两种常见写法</h2><p>饿汉式单例：(单例模式通用代码)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static final Singleton singleton = new Singleton();</span><br><span class="line">    //限制产生多个对象</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过该方法获得实例对象</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    //其他方法尽量使static</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式单例：（线程不安全单例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton = null;</span><br><span class="line">    //限制产生多个对象</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过该方法获得实例对象</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        if(singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    //其他方法尽量使static</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【修改后】懒汉式单例：（线程安全单例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton = null;</span><br><span class="line">    //限制产生多个对象</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过该方法获得实例对象</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        if(singleton == null) &#123;</span><br><span class="line">            lock(singleton) &#123;</span><br><span class="line">                if(singleton == null) &#123; //由于某些情况下，可能有延迟加载或者缓存的原因，需要多做一次判断</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    //其他方法尽量使static</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>懒汉式单例高并发情况下，注意单例模式的线程同步问题<br>解决方法，可以在getSingleton方法前加synchronized关键字，也可以在该方法内增加synchronized来实现</li><li>需要考虑对象的复制情况<br>解决方法，单例类不实现Cloneable接口</li></ol><h2 id="单例模式的扩展"><a href="#单例模式的扩展" class="headerlink" title="单例模式的扩展"></a>单例模式的扩展</h2><ol><li>有上限的多例模式：如果要求一个类只能产生两三个对象</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Singleton类称为单例类&lt;br&gt;通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式优势明显&lt;/li&gt;
&lt;li&gt;由于单例模式只生成一个实例，所以减少了系统的性能开销。当一个对象的产生需要比较多资源的时候，如读取配置、产生其他依赖对象时，则可以通过在&lt;em&gt;应用启动时&lt;/em&gt;直接产生一个单例对象，然后用永久驻留内存的方式来解决。&lt;/li&gt;
&lt;li&gt;单例模式可以避免对资源的多重占用，如避免对同一资源文件的同时写操作&lt;/li&gt;
&lt;li&gt;单例模式可以在系统设置全局访问点，优化和共享资源访问。如设计一个单例类，负责所有数据表的映射处理。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://ElaineKoo.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>六大设计原则(SOLID)</title>
    <link href="http://ElaineKoo.github.io/2018/11/12/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99(SOLID)/"/>
    <id>http://ElaineKoo.github.io/2018/11/12/六大设计原则(SOLID)/</id>
    <published>2018-11-12T06:05:00.000Z</published>
    <updated>2018-11-12T06:37:35.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>一个接口或类只有一个原因引起变化</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>类的复杂度降低</li><li>可读性提高</li><li>可维护性提高</li><li>变更引起的风险降低</li></ol><h2 id="难以实现的原因"><a href="#难以实现的原因" class="headerlink" title="难以实现的原因"></a>难以实现的原因</h2><p>环境、工作量、人员的技术水平、硬件资源、文化差异…</p><hr><h1 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h1><p>为良好的继承定义了一个规范</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol><li>子类必须完全实现父类的方法。<br>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li><li>子类可以有自己的个性</li><li>覆盖或实现父类的方法时输入参数可以被放大<br>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松</li><li>覆写或实现父类的方法时输出结果可以被缩小<br>子类返回值必须和父类返回值同类型或是父类返回值的子类</li></ol><a id="more"></a><hr><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>正置是面向实现编程，倒置是面向接口编程<br>是实现开闭原则的重要途径<br>本质是通过抽象（接口或抽象类）使各个类或模块的是想彼此独立，不互相影响，实现模块间的松耦合。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>高层模块不应该依赖底层模块，两者都应该依赖其抽象<br>抽象指接口或抽象类</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ol><p>减少类间的耦合性，提高系统的稳定性<br>依赖是可传递的</p><h2 id="三种写法"><a href="#三种写法" class="headerlink" title="三种写法"></a>三种写法</h2><ol><li>构造函数传递依赖对象</li><li>Setter方法传递依赖对象</li><li>接口声明依赖对象</li></ol><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或者是抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法<br>类型依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响</li><li>结合里氏替换原则使用<br>接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化。</li></ol><hr><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li>实例接口</li><li>类接口</li></ol><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ol><h2 id="接口尽量细化，同时接口中的方法尽量少，与单一职责的不同"><a href="#接口尽量细化，同时接口中的方法尽量少，与单一职责的不同" class="headerlink" title="接口尽量细化，同时接口中的方法尽量少，与单一职责的不同"></a>接口尽量细化，同时接口中的方法尽量少，与单一职责的不同</h2><p>与单一职责的视角不同，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；接口隔离原则是要求接口的方法尽量少，提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问</p><h2 id="保证接口的纯洁性"><a href="#保证接口的纯洁性" class="headerlink" title="保证接口的纯洁性"></a>保证接口的纯洁性</h2><ol><li>接口要尽量小<br>根于接口隔离原则拆分接口时，首先必须满足单一职责原则</li><li>接口要高内聚<br>提高接口、类、模块的处理能力，减少对外的交互。要求接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更的风险也就越少，同时也有利于降低成本。</li><li>定制服务<br>只提供访问者的需要的方法</li><li>接口设计是有限度的<br>接口的设计粒度越小，系统越灵活</li></ol><hr><h1 id="迪米特法则——最少知识原则"><a href="#迪米特法则——最少知识原则" class="headerlink" title="迪米特法则——最少知识原则"></a>迪米特法则——最少知识原则</h1><p>一个对象应该对其他对象有最少的了解</p><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><ol><li>只和朋友交流<br>两个对象之间耦合就成为朋友，组合、聚合、依赖等</li><li>朋友间也是有距离的</li><li>是自己的就是自己的<br>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li><li>谨慎使用Serializable</li></ol><h2 id="核心观念"><a href="#核心观念" class="headerlink" title="核心观念"></a>核心观念</h2><p>类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。但解耦是有限度的。</p><hr><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。<br>开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，底层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段</p><h2 id="软件实体"><a href="#软件实体" class="headerlink" title="软件实体"></a>软件实体</h2><ol><li>项目或软件产品中按照一定的逻辑规则划分的模块</li><li>抽象和类</li><li>方法</li></ol><h2 id="变化的归纳"><a href="#变化的归纳" class="headerlink" title="变化的归纳"></a>变化的归纳</h2><ol><li>逻辑变化</li><li>子模块变化</li><li>可见视图变化</li></ol><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><ol><li>开闭原则对测试的影响</li><li>开闭原则可以提高复用性<br>粒度越小，被复用的可能性越大</li><li>开闭原则可以提高可维护性</li><li>面向对象开发的要求</li></ol><h2 id="如何使用开闭原则"><a href="#如何使用开闭原则" class="headerlink" title="如何使用开闭原则"></a>如何使用开闭原则</h2><ol><li>抽象约束</li><li>元数据控制模块行为</li><li>制定项目章程</li><li>封装变化</li></ol><h2 id="注意以下问题"><a href="#注意以下问题" class="headerlink" title="注意以下问题"></a>注意以下问题</h2><ol><li>开闭原则也只是一个原则</li><li>项目规章非常重要</li><li>预知变化</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单一职责原则&quot;&gt;&lt;a href=&quot;#单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;单一职责原则&quot;&gt;&lt;/a&gt;单一职责原则&lt;/h1&gt;&lt;p&gt;一个接口或类只有一个原因引起变化&lt;/p&gt;
&lt;h2 id=&quot;好处&quot;&gt;&lt;a href=&quot;#好处&quot; class=&quot;headerlink&quot; title=&quot;好处&quot;&gt;&lt;/a&gt;好处&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;类的复杂度降低&lt;/li&gt;
&lt;li&gt;可读性提高&lt;/li&gt;
&lt;li&gt;可维护性提高&lt;/li&gt;
&lt;li&gt;变更引起的风险降低&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;难以实现的原因&quot;&gt;&lt;a href=&quot;#难以实现的原因&quot; class=&quot;headerlink&quot; title=&quot;难以实现的原因&quot;&gt;&lt;/a&gt;难以实现的原因&lt;/h2&gt;&lt;p&gt;环境、工作量、人员的技术水平、硬件资源、文化差异…&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;里式替换原则&quot;&gt;&lt;a href=&quot;#里式替换原则&quot; class=&quot;headerlink&quot; title=&quot;里式替换原则&quot;&gt;&lt;/a&gt;里式替换原则&lt;/h1&gt;&lt;p&gt;为良好的继承定义了一个规范&lt;/p&gt;
&lt;h2 id=&quot;规则&quot;&gt;&lt;a href=&quot;#规则&quot; class=&quot;headerlink&quot; title=&quot;规则&quot;&gt;&lt;/a&gt;规则&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;子类必须完全实现父类的方法。&lt;br&gt;如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承&lt;/li&gt;
&lt;li&gt;子类可以有自己的个性&lt;/li&gt;
&lt;li&gt;覆盖或实现父类的方法时输入参数可以被放大&lt;br&gt;子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松&lt;/li&gt;
&lt;li&gt;覆写或实现父类的方法时输出结果可以被缩小&lt;br&gt;子类返回值必须和父类返回值同类型或是父类返回值的子类&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 数据类型</title>
    <link href="http://ElaineKoo.github.io/2018/11/06/Mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://ElaineKoo.github.io/2018/11/06/Mysql-数据类型/</id>
    <published>2018-11-06T06:53:35.000Z</published>
    <updated>2018-11-06T11:04:52.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><blockquote><ul><li>TINYINT = 2^8 bit = 1字节</li><li>SMALLINT = 2 * 2^8 bit = 2字节</li><li>MEDIUMINT = 3 * 2^8 bit = 3字节</li><li>INT = INTEGER = 4 * 2^8 bit = 4字节</li><li>BIGINT = 8 * 2^8 bit = 8字节</li></ul></blockquote><p><em>取值范围如果加了 unsigned，则最大值翻倍</em></p><a id="more"></a><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><blockquote><ul><li>FLOAT = 4 * 2^8 = 4字节</li><li>DOUBLE = 8 * 2^8 bit = 8字节</li><li>DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2，否则为D+2。</li></ul></blockquote><p><em>D&lt;=M &amp;&amp; &amp;&amp; M&gt;=0 &amp;&amp; D&lt;=30, M&gt;=1 &amp;&amp; M&lt;=65。</em></p><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><blockquote><ul><li>DATE = 3字节 YYYY-MM-DD</li><li>TIME = 3字节 HH:MM:SS</li><li>YEAR = 1字节 YYYY</li><li>DATETIME = 8字节 YYYY-MM-DD HH:MM:SS</li><li>TIMESTAMP = 4字节 2147483647（类似INT）</li></ul></blockquote><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><blockquote><ul><li>CHAR = 2^8字节（定长，不区分大小写）</li><li>VARCHAR = 2^16字节（变长，不区分大小写）</li></ul></blockquote><p><em>char为定长，后面加空格，如果数据中末尾有空格会被去掉，且不区分大小写</em></p><blockquote><ul><li>TINYBLOB = 2^8字节 不超过 255 个字符的二进制字符串</li><li>TINYTEXT = 2^8字节</li></ul></blockquote><blockquote><ul><li>BLOB = 2^8 * 2^8 = 2^16字节</li><li>TEXT = 2^8 * 2^8 = 2^16字节</li></ul></blockquote><blockquote><ul><li>MEDIUMBLOB = 2^8 <em> 2^8 </em> 2^8 = 2^24字节</li><li>MEDIUMTEXT = 2^8 <em> 2^8 </em> 2^8 = 2^24字节</li></ul></blockquote><blockquote><ul><li>LONGBLOB = 2^8 <em> 2^8 </em> 2^8* 2^8 = 2^32字节</li><li>LONGTEXT = 2^8 <em> 2^8 </em> 2^8* 2^8 = 2^32字节</li></ul></blockquote><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="一个汉字占多少长度与编码有关：（MySQL-5-0-以上的版本）"><a href="#一个汉字占多少长度与编码有关：（MySQL-5-0-以上的版本）" class="headerlink" title="一个汉字占多少长度与编码有关：（MySQL 5.0 以上的版本）"></a>一个汉字占多少长度与编码有关：（MySQL 5.0 以上的版本）</h3><ul><li>UTF－8：一个汉字（含繁体）＝3个字节 ；</li><li>GBK：一个汉字＝2个字节</li></ul><h3 id="char-和-varchar-区别："><a href="#char-和-varchar-区别：" class="headerlink" title="char 和 varchar 区别："></a>char 和 varchar 区别：</h3><ul><li>CHAR和VARCHAR在存储或检索过程中不进行大小写转换。</li><li>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。</li><li>char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或2个字节(n&gt;255)，多的字节用来记录长度。所以 varchar(4),存入 3 个字符将占用 4 个字节。</li><li>char 类型的字符串检索速度要比 varchar 类型的快。</li></ul><h3 id="varchar-和-text-区别："><a href="#varchar-和-text-区别：" class="headerlink" title="varchar 和 text 区别："></a>varchar 和 text 区别：</h3><ul><li>varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或 2 个字节(n&gt;255)，text 是实际字符数 +2 个字节。</li><li>text 类型不能有默认值。</li><li>varchar 可直接创建索引，text 创建索引指定索引前缀的长度。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。</li></ul><h3 id="二进制数据-Blob-和-text-区别："><a href="#二进制数据-Blob-和-text-区别：" class="headerlink" title="二进制数据(_Blob) 和 text 区别："></a>二进制数据(_Blob) 和 text 区别：</h3><ul><li>BLOB 是一个二进制大对象</li><li>_BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。</li><li>_BLOB存储的数据只能整体读出。</li><li>_TEXT可以指定字符集，_BLO不用指定字符集。</li></ul><h3 id="ENUM-和-SET-区别："><a href="#ENUM-和-SET-区别：" class="headerlink" title="ENUM 和 SET 区别："></a>ENUM 和 SET 区别：</h3><ul><li>ENUM = 1字节或2字节 最多2字节（2^16）</li><li>ENUM是一个字符串对象，可以插入空字符串””（索引：0）和NULL（索引：NULL），从1开始编号。其值来自表创建时在列规定中显式枚举的一列值</li><li>SET = 1字节或2字节或3字节或4字节或8字节</li><li>SET是一个字符串对象，可以有零或多个值，最多可以设置64个值，其值来自表创建时规定的允许的一列值</li></ul><p>来源：<br><a href="http://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-data-types.html</a><br><a href="https://www.cnblogs.com/Caveolae/p/7058890.html" target="_blank" rel="noopener">https://www.cnblogs.com/Caveolae/p/7058890.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本类型&quot;&gt;&lt;a href=&quot;#基本类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型&quot;&gt;&lt;/a&gt;基本类型&lt;/h2&gt;&lt;h3 id=&quot;整型&quot;&gt;&lt;a href=&quot;#整型&quot; class=&quot;headerlink&quot; title=&quot;整型&quot;&gt;&lt;/a&gt;整型&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TINYINT = 2^8 bit = 1字节&lt;/li&gt;
&lt;li&gt;SMALLINT = 2 * 2^8 bit = 2字节&lt;/li&gt;
&lt;li&gt;MEDIUMINT = 3 * 2^8 bit = 3字节&lt;/li&gt;
&lt;li&gt;INT = INTEGER = 4 * 2^8 bit = 4字节&lt;/li&gt;
&lt;li&gt;BIGINT = 8 * 2^8 bit = 8字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;取值范围如果加了 unsigned，则最大值翻倍&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="mysql" scheme="http://ElaineKoo.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
