<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Koo&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/3f699edf093c84da2984d079893f3080</icon>
  
  <link href="//atom.xml" rel="self"/>
  
  <link href="http://ElaineKoo.github.io/"/>
  <updated>2018-12-20T02:00:51.405Z</updated>
  <id>http://ElaineKoo.github.io/</id>
  
  <author>
    <name>Koo</name>
    <email>593321338@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Laravel redis monitor</title>
    <link href="http://ElaineKoo.github.io/2018/12/19/Laravel-redis-monitor/"/>
    <id>http://ElaineKoo.github.io/2018/12/19/Laravel-redis-monitor/</id>
    <published>2018-12-19T05:54:32.000Z</published>
    <updated>2018-12-20T02:00:51.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用redis-monitor观察"><a href="#使用redis-monitor观察" class="headerlink" title="使用redis monitor观察"></a>使用redis monitor观察</h2><p><em>以下为laradock环境下的redis</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose exec redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt;monitor</span><br></pre></td></tr></table></figure></p><h3 id="队列中无任务，启动队列：php-artisan-queue-work"><a href="#队列中无任务，启动队列：php-artisan-queue-work" class="headerlink" title="队列中无任务，启动队列：php artisan queue:work"></a>队列中无任务，启动队列：php artisan queue:work</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">查看是否需要重启，如果 my_laravel_project_cache:illuminate:queue:restart 存在，就重启队列（代码更新后，一定要重启队列，否则队列不会读取最新代码）。</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:40858] &quot;GET&quot; &quot;my_laravel_project_cache:illuminate:queue:restart&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:delayed&quot; &quot;queues:default&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，延迟任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:delayed&quot; &quot;-inf&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:reserved&quot; &quot;queues:default&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，待处理任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:reserved&quot; &quot;-inf&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Pop the first job off of the queue...\nlocal job = redis.call(&apos;lpop&apos;, KEYS[1])\nlocal reserved = false\n\nif(job ~= false) then\n    -- Increment the attempt count and place job on the reserved queue...\n    reserved = cjson.decode(job)\n    reserved[&apos;attempts&apos;] = reserved[&apos;attempts&apos;] + 1\n    reserved = cjson.encode(reserved)\n    redis.call(&apos;zadd&apos;, KEYS[2], ARGV[1], reserved)\nend\n\nreturn &#123;job, reserved&#125;&quot; &quot;2&quot; &quot;queues:default&quot; &quot;queues:default:reserved&quot; &quot;1543320211&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，从默认队列中删除job</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;lpop&quot; &quot;queues:default&quot;</span><br></pre></td></tr></table></figure><h3 id="及时任务"><a href="#及时任务" class="headerlink" title="及时任务"></a>及时任务</h3><h4 id="操作1-放一个及时任务到消息队列"><a href="#操作1-放一个及时任务到消息队列" class="headerlink" title="操作1: 放一个及时任务到消息队列"></a>操作1: 放一个及时任务到消息队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择1号redis库</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.6:56918] &quot;SELECT&quot; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">将任务放入默认队列</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.6:56918] &quot;RPUSH&quot; &quot;queues:default&quot; &quot;&#123;\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;maxTries\&quot;:4,\&quot;timeout\&quot;:5000,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:145;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;N;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;&#125;,\&quot;id\&quot;:\&quot;aP4LzhyYgB3aKaiCTJRJjlqhVtrqDhOC\&quot;,\&quot;attempts\&quot;:0&#125;&quot;</span><br></pre></td></tr></table></figure><h4 id="操作2-启动队列：php-artisan-queue-work"><a href="#操作2-启动队列：php-artisan-queue-work" class="headerlink" title="操作2: 启动队列：php artisan queue:work"></a>操作2: 启动队列：php artisan queue:work</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">查看是否需要重启，如果 my_laravel_project_cache:illuminate:queue:restart 存在，就重启队列。</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:40858] &quot;GET&quot; &quot;my_laravel_project_cache:illuminate:queue:restart&quot;</span><br><span class="line"></span><br><span class="line">选择1号redis库</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:40860] &quot;SELECT&quot; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:delayed&quot; &quot;queues:default&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，延迟任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:delayed&quot; &quot;-inf&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:reserved&quot; &quot;queues:default&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，待处理任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:reserved&quot; &quot;-inf&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Pop the first job off of the queue...\nlocal job = redis.call(&apos;lpop&apos;, KEYS[1])\nlocal reserved = false\n\nif(job ~= false) then\n    -- Increment the attempt count and place job on the reserved queue...\n    reserved = cjson.decode(job)\n    reserved[&apos;attempts&apos;] = reserved[&apos;attempts&apos;] + 1\n    reserved = cjson.encode(reserved)\n    redis.call(&apos;zadd&apos;, KEYS[2], ARGV[1], reserved)\nend\n\nreturn &#123;job, reserved&#125;&quot; &quot;2&quot; &quot;queues:default&quot; &quot;queues:default:reserved&quot; &quot;1543320207&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，从默认队列中删除job</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;lpop&quot; &quot;queues:default&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，把job加入待处理任务队列中</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zadd&quot; &quot;queues:default:reserved&quot; &quot;1543320207&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;aP4LzhyYgB3aKaiCTJRJjlqhVtrqDhOC\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:145;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;N;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br><span class="line"></span><br><span class="line">任务执行成功，将job从default:reserved中删除</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;ZREM&quot; &quot;queues:default:reserved&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;aP4LzhyYgB3aKaiCTJRJjlqhVtrqDhOC\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:145;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;N;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h3><h4 id="操作1-放一个延迟任务到消息队列"><a href="#操作1-放一个延迟任务到消息队列" class="headerlink" title="操作1: 放一个延迟任务到消息队列"></a>操作1: 放一个延迟任务到消息队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择1号redis库</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.6:57034] &quot;SELECT&quot; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">将job放进延迟队列中</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.6:57034] &quot;zadd&quot; &quot;queues:default:delayed&quot; &quot;1543321166&quot; &quot;&#123;\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;maxTries\&quot;:4,\&quot;timeout\&quot;:5000,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:146;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:19:26.033615\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;&#125;,\&quot;id\&quot;:\&quot;JGqshVc6ub4iQH3CeZFFyGjcxTmmPNvh\&quot;,\&quot;attempts\&quot;:0&#125;&quot;</span><br></pre></td></tr></table></figure><h5 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">namespace Illuminate\Queue;</span><br><span class="line"></span><br><span class="line">class RedisQueue extends Queue implements QueueContract</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Push a raw job onto the queue after a delay.</span><br><span class="line">     *</span><br><span class="line">     * @param  \DateTimeInterface|\DateInterval|int  $delay</span><br><span class="line">     * @param  string  $payload</span><br><span class="line">     * @param  string  $queue</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    protected function laterRaw($delay, $payload, $queue = null)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;getConnection()-&gt;zadd(</span><br><span class="line">            $this-&gt;getQueue($queue).&apos;:delayed&apos;, $this-&gt;availableAt($delay), $payload</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        return json_decode($payload, true)[&apos;id&apos;] ?? null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作2-启动队列：php-artisan-queue-work，并执行延迟任务"><a href="#操作2-启动队列：php-artisan-queue-work，并执行延迟任务" class="headerlink" title="操作2: 启动队列：php artisan queue:work，并执行延迟任务"></a>操作2: 启动队列：php artisan queue:work，并执行延迟任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">查看是否需要重启，如果 my_laravel_project_cache:illuminate:queue:restart 存在，就重启队列。</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:41020] &quot;GET&quot; &quot;my_laravel_project_cache:illuminate:queue:restart&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:delayed&quot; &quot;queues:default&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，延迟任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:delayed&quot; &quot;-inf&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，移除延迟任务队列中，下标为0的任务（说明只找到一个）</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zremrangebyrank&quot; &quot;queues:default:delayed&quot; &quot;0&quot; &quot;0&quot;</span><br><span class="line"></span><br><span class="line">将任务放入默认队列</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;rpush&quot; &quot;queues:default&quot; &quot;&#123;\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;maxTries\&quot;:4,\&quot;timeout\&quot;:5000,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:147;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:12:07.408913\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;&#125;,\&quot;id\&quot;:\&quot;brP2ZEbWU7e5CwXAURQ1fxkk1h9VHuKj\&quot;,\&quot;attempts\&quot;:0&#125;&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:reserved&quot; &quot;queues:default&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，待处理任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:reserved&quot; &quot;-inf&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;EVAL&quot; &quot;-- Pop the first job off of the queue...\nlocal job = redis.call(&apos;lpop&apos;, KEYS[1])\nlocal reserved = false\n\nif(job ~= false) then\n    -- Increment the attempt count and place job on the reserved queue...\n    reserved = cjson.decode(job)\n    reserved[&apos;attempts&apos;] = reserved[&apos;attempts&apos;] + 1\n    reserved = cjson.encode(reserved)\n    redis.call(&apos;zadd&apos;, KEYS[2], ARGV[1], reserved)\nend\n\nreturn &#123;job, reserved&#125;&quot; &quot;2&quot; &quot;queues:default&quot; &quot;queues:default:reserved&quot; &quot;1543320819&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，从默认队列中删除job</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;lpop&quot; &quot;queues:default&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，把job加入待处理任务队列中</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zadd&quot; &quot;queues:default:reserved&quot; &quot;1543320819&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;brP2ZEbWU7e5CwXAURQ1fxkk1h9VHuKj\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:147;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:12:07.408913\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br><span class="line"></span><br><span class="line">任务执行成功，将job从default:reserved中删除</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;ZREM&quot; &quot;queues:default:reserved&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;brP2ZEbWU7e5CwXAURQ1fxkk1h9VHuKj\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:147;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:12:07.408913\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="三个队列"><a href="#三个队列" class="headerlink" title="三个队列"></a>三个队列</h3><blockquote><p>queue:default:delayed : 存储延迟任务<br>queue:default : 存储待处理任务，应该处理但是还未处理任务<br>queue:default:reserved : 存储待处理任务</p></blockquote><p>参考<br><a href="https://www.cnblogs.com/yjf512/p/6571941.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.cnblogs.com/yjf512/p/6571941.html?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="https://laravel-china.org/articles/3729/use-laravel-queue-to-understand-the-knowledge#1e3690" target="_blank" rel="noopener">https://laravel-china.org/articles/3729/use-laravel-queue-to-understand-the-knowledge#1e3690</a><br><a href="https://www.codercto.com/a/20858.html" target="_blank" rel="noopener">https://www.codercto.com/a/20858.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用redis-monitor观察&quot;&gt;&lt;a href=&quot;#使用redis-monitor观察&quot; class=&quot;headerlink&quot; title=&quot;使用redis monitor观察&quot;&gt;&lt;/a&gt;使用redis monitor观察&lt;/h2&gt;&lt;p&gt;&lt;em&gt;以下为lar
      
    
    </summary>
    
    
      <category term="laravel" scheme="http://ElaineKoo.github.io/tags/laravel/"/>
    
      <category term="redis" scheme="http://ElaineKoo.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Mysql explain用法及含义</title>
    <link href="http://ElaineKoo.github.io/2018/12/14/Mysql-explain%E7%94%A8%E6%B3%95%E5%8F%8A%E5%90%AB%E4%B9%89/"/>
    <id>http://ElaineKoo.github.io/2018/12/14/Mysql-explain用法及含义/</id>
    <published>2018-12-14T06:44:37.000Z</published>
    <updated>2018-12-17T02:07:12.811Z</updated>
    
    <content type="html"><![CDATA[<p><em>EXPLAIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划</em></p><h2 id="EXPLAIN列的解释："><a href="#EXPLAIN列的解释：" class="headerlink" title="EXPLAIN列的解释："></a>EXPLAIN列的解释：</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>SELECT识别符。这是SELECT的查询序列号，每一个select都会分配一个id</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>SELECT类型</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>输出的行所引用的表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>从最佳类型到最坏类型进行排序</p><p>特殊：NULL<br>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select min(id) from users\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Select tables optimized away</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p><h4 id="system"><a href="#system" class="headerlink" title="[system]"></a>[system]</h4><p>表中只有一条数据。 这个类型是特殊的 const 类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from (select * from admins where id = 1) tmp\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        table: &lt;derived2&gt;</span><br><span class="line">         type: system</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 2</span><br><span class="line">  select_type: DERIVED</span><br><span class="line">        table: admins</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="const"><a href="#const" class="headerlink" title="[const]"></a>[const]</h4><p>针对<code>主键或唯一索引</code>的等值查询扫描, 最多只返回一行数据。 const 查询速度非常快, 因为它仅仅读取一次即可。<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="[eq_ref]"></a>[eq_ref]</h4><p>对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。<br>此类型通常出现在多表的 join 查询, 表示<code>对于前表的每一个结果, 都只能匹配到后表的一行结果</code>。 并且查询的比较操作通常是 =, 查询效率较高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users,doctors where users.doctor_id = doctors.id\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: doctors</span><br><span class="line">         type: eq_ref                      </span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: rysn-test.users.doctor_id</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="ref"><a href="#ref" class="headerlink" title="[ref]"></a>[ref]</h4><p>此类型通常出现在<code>多表的 join 查询, 针对于非唯一或非主键索引</code>, 或者是使用了<code>最左前缀</code>规则索引的查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users,doctors where users.doctor_id = doctors.id AND users.doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: doctors</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref                          </span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM users where doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">使用了`最左前缀`规则索引</span><br></pre></td></tr></table></figure></p><h4 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="[ref_or_null]"></a>[ref_or_null]</h4><p>该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。</p><h4 id="index-merge"><a href="#index-merge" class="headerlink" title="[index_merge]"></a>[index_merge]</h4><p>该联接类型表示使用了索引合并优化方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from users where id = 2040 or doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: index_merge</span><br><span class="line">possible_keys: PRIMARY,users_doctor_id_index</span><br><span class="line">          key: PRIMARY,users_doctor_id_index</span><br><span class="line">      key_len: 4,4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using union(PRIMARY,users_doctor_id_index); Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="[unique_subquery]"></a>[unique_subquery]</h4><p>该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</p><h4 id="index-subquery"><a href="#index-subquery" class="headerlink" title="[index_subquery]"></a>[index_subquery]</h4><p>该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</p><h4 id="range"><a href="#range" class="headerlink" title="[range]"></a>[range]</h4><p>只检索给定范围的行,使用一个索引来选择行。<br>表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录。 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users,doctors where users.doctor_id = doctors.id AND users.doctor_id &gt; 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: range                          </span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: doctors</span><br><span class="line">         type: eq_ref</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: rysn-test.users.doctor_id</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="index"><a href="#index" class="headerlink" title="[index]"></a>[index]</h4><p>该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。<br>表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据。<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。 当是这种情况时, Extra 字段 会显示 Using index。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT doctor_id FROM users where doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">但如果是：</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM users where doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">使用了`最左前缀`规则索引</span><br></pre></td></tr></table></figure></p><h4 id="ALL"><a href="#ALL" class="headerlink" title="[ALL]"></a>[ALL]</h4><p>对于每个来自于先前的表的行组合,进行完整的表扫描。我们的查询不应该出现 ALL 类型的查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM users where name = &apos;yyy&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>指出MySQL能使用哪个索引在该表中找到行</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>显示MySQL决定使用的键的字节数。如果键是NULL,则长度为NULL。</p><h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><p>显示使用哪个列或常数与key一起从表中选择行</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。</p><h3 id="filtered-？"><a href="#filtered-？" class="headerlink" title="filtered(？)"></a>filtered(？)</h3><p>显示了通过条件过滤出的行数的百分比估计值。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>包含MySQL解决查询的详细信息</p><h4 id="Distinct"><a href="#Distinct" class="headerlink" title="[Distinct]"></a>[Distinct]</h4><p>MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行</p><h4 id="Not-exists"><a href="#Not-exists" class="headerlink" title="[Not exists]"></a>[Not exists]</h4><p>MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行</p><h4 id="range-checked-for-each-record-index-map"><a href="#range-checked-for-each-record-index-map" class="headerlink" title="[range checked for each record (index map: #)]"></a>[range checked for each record (index map: #)]</h4><p>MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用</p><h4 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="[Using filesort]"></a>[Using filesort]</h4><p>MySQL需要额外的一次传递,以找出如何按排序顺序检索行<br>表示 MySQL 需额外的排序操作，不能通过索引顺序达到排序效果，一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users ORDER BY name\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: Using filesort</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-index"><a href="#Using-index" class="headerlink" title="[Using index]"></a>[Using index]</h4><p>从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">doctor_id是索引</span><br><span class="line">mysql&gt; EXPLAIN SELECT doctor_id FROM users where  doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="[Using temporary]"></a>[Using temporary]</h4><p>为了解决查询,MySQL需要创建一个临时表来容纳结果<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select 1 union all select 1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: No tables used</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 2</span><br><span class="line">  select_type: UNION</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: No tables used</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">           id: NULL</span><br><span class="line">  select_type: UNION RESULT</span><br><span class="line">        table: &lt;union1,2&gt;</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Using temporary</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-where"><a href="#Using-where" class="headerlink" title="[Using where]"></a>[Using where]</h4><p>WHERE 子句用于限制哪一个行匹配下一个表或发送到客户<br><em>name不是索引</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM users where  name = &apos;xx&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-sort-union-…-Using-union-…-Using-intersect-…"><a href="#Using-sort-union-…-Using-union-…-Using-intersect-…" class="headerlink" title="[Using sort_union(…), Using union(…), Using intersect(…)]"></a>[Using sort_union(…), Using union(…), Using intersect(…)]</h4><p>这些函数说明如何为index_merge联接类型合并索引扫描</p><h4 id="Using-index-for-group-by"><a href="#Using-index-for-group-by" class="headerlink" title="[Using index for group-by]"></a>[Using index for group-by]</h4><p>类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表</p><h4 id="Impossible-WHERE"><a href="#Impossible-WHERE" class="headerlink" title="[Impossible WHERE]"></a>[Impossible WHERE]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">doctor_id是unsigned integer</span><br><span class="line">mysql&gt; EXPLAIN SELECT doctor_id FROM users where  doctor_id = &apos;1340000000000&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Impossible WHERE noticed after reading const tables</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;EXPLAIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;EXPLAIN列的解释：&quot;&gt;&lt;a href=&quot;#EXPLAIN列的解释：&quot; class=&quot;headerlink&quot; title=&quot;EXPLAIN列的解
      
    
    </summary>
    
    
      <category term="mysql" scheme="http://ElaineKoo.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>桥梁模式</title>
    <link href="http://ElaineKoo.github.io/2018/12/11/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/12/11/桥梁模式/</id>
    <published>2018-12-11T08:02:29.000Z</published>
    <updated>2018-12-17T07:42:59.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫桥接模式，将抽象和实现解耦，使得两者可以独立地变化</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Abstraction抽象化角色</li><li>Implementor实现化角色</li><li>RefinedAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正</li><li>ConcreteImplementor具体实现化角色</li></ol><ul><li>使用类间的聚合关系、继承、覆写等常用功能，提供一个清晰、稳定的架构 *</li></ul><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public interface Implementor &#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">    public void doAnything();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteImplementor1 implements Imlementor &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteImplementor2 implements Imlementor &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Abstraction &#123;</span><br><span class="line">    //实现化角色的引用</span><br><span class="line">    private Implement imp;</span><br><span class="line">    public Abstraction(Implementor _imp) &#123;</span><br><span class="line">        this.imp = _imp;</span><br><span class="line">    &#125;</span><br><span class="line">    //自身的行为和属性</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        this.imp.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    //获得实现化角色</span><br><span class="line">    public Implement getImp() &#123;</span><br><span class="line">        return imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RefinedAbstraction extends Abstraction &#123;</span><br><span class="line">    //覆写构造函数</span><br><span class="line">    public RefinedAbstraction(Implementor _imp) &#123;</span><br><span class="line">        super(_imp);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        super.request();</span><br><span class="line">        super.getImp().doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Implementor imp = new ConcreteImplementor1();</span><br><span class="line">        Abstraction = abs = new RefinedAbstraction(imp);</span><br><span class="line">        abs.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>抽象和实现分离，完全是为了解决继承的缺点而提出的设计模式。该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上</li><li>优秀的扩充能力。可增加实现也可增加抽象。</li><li>实现细节对客户透明</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>不希望或不适合使用继承的场景</li><li>接口或抽象类不稳定的场景</li><li>重用性要求较高的场景</li></ol><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与策略模式比：桥梁模式关注的是抽象和实现的分离，它是结构型模式。在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫桥接模式，将抽象和实现解耦，使得两者可以独立地变化&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Abstraction抽象化角色&lt;/li&gt;
&lt;li&gt;Implementor实现化角色&lt;/li&gt;
&lt;li&gt;RefinedAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正&lt;/li&gt;
&lt;li&gt;ConcreteImplementor具体实现化角色&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;使用类间的聚合关系、继承、覆写等常用功能，提供一个清晰、稳定的架构 *&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥梁模式" scheme="http://ElaineKoo.github.io/tags/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>享元模式</title>
    <link href="http://ElaineKoo.github.io/2018/12/11/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/12/11/享元模式/</id>
    <published>2018-12-11T06:47:36.000Z</published>
    <updated>2018-12-11T07:58:51.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象</p><ul><li>两个要求：细粒度的对象和共享对象 *</li></ul><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Flyweight抽象享元角色</li><li>ConcreteFlyweight具体享元角色</li><li>unsharedConcreteFlyweight不可共享的享元角色</li><li>FlyweightFactory享元工厂</li></ol><ul><li>目的：运用共享技术，使得一些细粒度的对象可以共享，我们的设计也应该多使用细粒度的对象，便于重用或重构 *</li></ul><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Flyweight &#123;</span><br><span class="line">    //内部状态</span><br><span class="line">    private String intrinsic;</span><br><span class="line">    //外部状态</span><br><span class="line">    protected final String Extrinsic;</span><br><span class="line">    //要求享元角色必须接受外部状态</span><br><span class="line">    public Flyweight(String _Extrinsic) &#123;</span><br><span class="line">        this.Extrinsic = _Extrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义业务操作</span><br><span class="line">    public abstract void operate();</span><br><span class="line">    //内部状态的getter/setter</span><br><span class="line">    public String getIntrinsic() &#123;</span><br><span class="line">        return intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setIntrinsic(String intrinsic) &#123;</span><br><span class="line">        this.intrinsic = intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFlyweight1 extends Flyweight &#123;</span><br><span class="line">    //接受外部状态</span><br><span class="line">    public ConcreteFlyweight1(String _Extrinsic) &#123;</span><br><span class="line">        super(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据外部状态进行逻辑处理</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFlyweight2 extends Flyweight &#123;</span><br><span class="line">    //接受外部状态</span><br><span class="line">    public ConcreteFlyweight2(String _Extrinsic) &#123;</span><br><span class="line">        super(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据外部状态进行逻辑处理</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    //池容器</span><br><span class="line">    private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;String,Flyweight&gt;();</span><br><span class="line">    //享元工厂</span><br><span class="line">    public static Flyweight getFlyweight(String Extrinsic) &#123;</span><br><span class="line">        //需要返回的对象</span><br><span class="line">        Flyweight = flyweight = null;</span><br><span class="line">        //在池中没有该对象</span><br><span class="line">        if(!pool.containsKey(Extrinsic)) &#123;</span><br><span class="line">            flyweight = pool.get(Extrinsic);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //根据外部状态创建享元对象</span><br><span class="line">            flyweight = new ConcreteFlyweight1(Extrinsic);</span><br><span class="line">            //放置到池中</span><br><span class="line">            pool.put(Extrinsic, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>提高系统复杂性，需要分离外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>系统中存在大量的相似对象</li><li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份</li><li>需要缓冲池的场景</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>线程安全问题</li><li>性能平衡</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;两个要求：细粒度的对象和共享对象 *&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Flyweight抽象享元角色&lt;/li&gt;
&lt;li&gt;ConcreteFlyweight具体享元角色&lt;/li&gt;
&lt;li&gt;unsharedConcreteFlyweight不可共享的享元角色&lt;/li&gt;
&lt;li&gt;FlyweightFactory享元工厂&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;目的：运用共享技术，使得一些细粒度的对象可以共享，我们的设计也应该多使用细粒度的对象，便于重用或重构 *&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="享元模式" scheme="http://ElaineKoo.github.io/tags/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>解释器模式</title>
    <link href="http://ElaineKoo.github.io/2018/12/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/12/05/解释器模式/</id>
    <published>2018-12-05T08:49:08.000Z</published>
    <updated>2018-12-05T09:13:09.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>AbstractExpression抽象解释器</li><li>TerminalExpression终结符表达式 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。主要是处理场景元素和数据的转换。</li><li>NonterminalExpression非终结符表达式 文法中的每条规则对应于一个非中介表达式</li><li>Context环境角色</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Expression &#123;</span><br><span class="line">    //每个表达式必须有一个解析任务</span><br><span class="line">    public abstract Object interpreter(Context ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TerminalExpression extends Expression &#123;</span><br><span class="line">    //通常终结符表达式只有一个，但是有多个对象</span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代表一个文法规则</span><br><span class="line">public class NonterminalExpression extends Expression &#123;</span><br><span class="line">    public NonterminalExpression(Expression... exoression) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        //进行文法处理</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context ctx = new Context();</span><br><span class="line">        Stack&lt;Expression&gt; stack = null;</span><br><span class="line">        for(;;) &#123;</span><br><span class="line">            //进行语法判断，并产生递归调用</span><br><span class="line">        &#125;</span><br><span class="line">        Expression exp = stack.php();</span><br><span class="line">        exp.interpreter(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>是一个简单语法分析工具，最显著的有点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>类膨胀</li><li>解释其模式采用递归调用方法，难以定位问题</li><li>效率问题，大量循环和递归</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>重复发生的问题可以使用解释器模式，例如：不同日志格式但数据要素相同的服务器解析</li><li>一个简单语法需要解释的场景</li></ol><p><em>尽量不要在不重要的模块使用解释器模式，维护困难，可使用脚本语言代替解释器模式</em></p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;AbstractExpression抽象解释器&lt;/li&gt;
&lt;li&gt;TerminalExpression终结符表达式 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。主要是处理场景元素和数据的转换。&lt;/li&gt;
&lt;li&gt;NonterminalExpression非终结符表达式 文法中的每条规则对应于一个非中介表达式&lt;/li&gt;
&lt;li&gt;Context环境角色&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="解释器模式" scheme="http://ElaineKoo.github.io/tags/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>状态模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/22/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/22/状态模式/</id>
    <published>2018-11-22T02:01:22.000Z</published>
    <updated>2018-12-17T07:00:38.935Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。核心是封装。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换</li><li>ConcreteState具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态的处理，就是本状态要做的事，以及本状态如何过渡到其他状态</li><li>Context环境角色 定义客户端需要的接口，负责具体状态的切换</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public abstract class State &#123;</span><br><span class="line">    protected Context context;</span><br><span class="line">    public void setContext(Context _context) &#123;</span><br><span class="line">        this.context = _context;</span><br><span class="line">    &#125;</span><br><span class="line">    //行为</span><br><span class="line">    public abstract void handle1();</span><br><span class="line">    public abstract void handle2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteState1 extends State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        //本状态下必须处理的逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        //设置状态</span><br><span class="line">        super.context.setCurrentState(Context.STATE2);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteState2 extends State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        //设置状态</span><br><span class="line">        super.context.setCurrentState(Context.STATE1);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handle1();</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        //本状态下必须处理的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Context &#123;</span><br><span class="line">    public final static State STATE1 = new ConcreteState1();</span><br><span class="line">    public final static State STATE2 = new ConcreteState2();</span><br><span class="line">    </span><br><span class="line">    private State = CurrentState;</span><br><span class="line">    public State getCurrentState() &#123;</span><br><span class="line">        return CurrentState;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setCurrentState(State currentState) &#123;</span><br><span class="line">        this.CurrentState = currentState;</span><br><span class="line">        //切换状态</span><br><span class="line">        this.CurrentState.setContext(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        this.CurrentState.handle1(this);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        this.CurrentState.handle2(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line">        context.setCurrentState(new ConcreteState1());</span><br><span class="line">        context.handel1();</span><br><span class="line">        context.handel2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>把状态对象声明为静态常量</em><br><em>环境角色（Context）具有状态抽象角色（State）定义的所有行为，具有执行使用委托方式</em></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>结构清晰 避免使用过多的switch..case或者if..else，避免程序的复杂性，提高系统的可维护性</li><li>遵循设计原则 很好体现了开闭原则和单一职责原则，增加状态就增加一个子类，修改状态就修改一个子类</li><li>封装性非常好 状态变换放置到类的内部实现，外部的调用不用知道类内部如何实现状态和行为的变换</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>子类太多，类膨胀，不好管理</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>行为随状态改变而改变</li><li>条件、分支判断语句的替代者</li></ol><p><em>适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个</em></p><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与策略模式比：状态模式封装的是不同的状态，以达到状态切换行为随之改变的目的。状态模式的环境角色不仅仅是委托行为，具有登记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。核心是封装。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换&lt;/li&gt;
&lt;li&gt;ConcreteState具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态的处理，就是本状态要做的事，以及本状态如何过渡到其他状态&lt;/li&gt;
&lt;li&gt;Context环境角色 定义客户端需要的接口，负责具体状态的切换&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="访问者模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>访问者模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/访问者模式/</id>
    <published>2018-11-21T08:04:39.000Z</published>
    <updated>2018-11-21T10:20:48.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Visitor抽象访问者 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的</li><li>ConcreteVisitor具体访问者 影响访问者访问到一个类后该怎么干，要做什么事</li><li>Element抽象元素 接口或抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义</li><li>ConcreteElement具体元素 实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了</li><li>ObjectStructure结构对象 元素产生者，一般容纳多个不同类、不同接口的容器，如List、Set、Map等</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Element &#123;</span><br><span class="line">    //业务逻辑</span><br><span class="line">    public abstract void doSomething();</span><br><span class="line">    //允许谁来访问</span><br><span class="line">    public abstract void accept(Ivisitor visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public classConcreteElement1 extends Element &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void accept(Ivisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public classConcreteElement2 extends Element &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void accept(Ivisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IVisitor &#123;</span><br><span class="line">    public void visit(ConcreteElement1 el1);</span><br><span class="line">    public void visit(ConcreteElement2 el2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Visitor implements IVisitor &#123;</span><br><span class="line">    public void visit(ConcreteElement1 el1) &#123;</span><br><span class="line">        el1.doSomething();</span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    public void visit(ConcreteElement2 el2) &#123;</span><br><span class="line">        el2.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//模拟</span><br><span class="line">public class ObjectStructure &#123;</span><br><span class="line">    public static Element createElement() &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line">        if(rand.nextInt(100) &gt; 50) &#123;</span><br><span class="line">            return new ConcreteElement1();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new ConcreteElement2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0; i&lt;10; i++)&#123;</span><br><span class="line">            Element el = ObjectStructure.createElement();</span><br><span class="line">            el.accept(new Visitor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>符合单一职责原则</li><li>优秀的扩展性</li><li>灵活性非常高</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>具体元素对访问者公布细节 访问者要访问一个类就必然要求这个类公布一些方法和数据，违反迪米特法则</li><li>具体元素变更比较困难 具体元素角色增加。删除。修改都是比较困难的</li><li>违背了依赖倒置原则 访问者依赖的是具体元素，而不是抽象元素，破坏了依赖倒置原则</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作</li><li>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作”污染”这些对象的类</li></ol><p><em>业务规则要求遍历多个不同的对象，这本身也是访问者模式的出发点，迭代器模式只能访问同类或同接口的数据，而访问者模式是对迭代器模式的补充，可以遍历不同的对象，然后执行不同的操作</em><br><em>还有一个用途，充当拦截器（Interceptor）</em></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>统计功能</li><li>多个访问者</li><li>双分派 双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>通过访问者模式可以容易地把一些功能进行梳理，达到最终目的——功能集中化，如一个统一的报表运算、UI展现等，我们还可以与其他模式混编建立一套自己的过滤器或者拦截器</p><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Visitor抽象访问者 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的&lt;/li&gt;
&lt;li&gt;ConcreteVisitor具体访问者 影响访问者访问到一个类后该怎么干，要做什么事&lt;/li&gt;
&lt;li&gt;Element抽象元素 接口或抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义&lt;/li&gt;
&lt;li&gt;ConcreteElement具体元素 实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了&lt;/li&gt;
&lt;li&gt;ObjectStructure结构对象 元素产生者，一般容纳多个不同类、不同接口的容器，如List、Set、Map等&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="访问者模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>备忘录模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/备忘录模式/</id>
    <published>2018-11-21T06:33:25.000Z</published>
    <updated>2018-11-21T07:46:52.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在不破坏封装性的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态。这样以后就可将该对象回复到原先保存的状态。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Originator发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据</li><li>Memento备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态</li><li>Caretaker备忘录管理员角色 对备忘录进行管理、保存和提供备忘录</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        return new Memento(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    public void restoreMemento(Memento _memento) &#123;</span><br><span class="line">        this.setState(_memento.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Memento &#123;</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    public Memento(String _state) &#123;</span><br><span class="line">        this.state = _state;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Caretaker &#123;</span><br><span class="line">    private Memento memento;</span><br><span class="line">    public Memento getMemento() &#123;</span><br><span class="line">        return memento;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMemento(Memento memento) &#123;</span><br><span class="line">        this.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Originator originator = new Originator();</span><br><span class="line">        Caretaker caretaker = new Caretaker();</span><br><span class="line">        caretaker.setMemento(origunator.createMemento());</span><br><span class="line">        originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要保存和恢复数据的相关状态场景</li><li>提供一个可回滚的操作</li><li>需要监控的副本场景中 备份一个主线程中的对象，然后由分析程序来分析</li><li>数据库连接的事务管理就是用备忘录模式</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>备忘录的生命期 主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理</li><li>备忘录的性能 不要频繁建立备份的场景中使用备忘录模式，原因一：控制不了备忘录建立的对象数量；原因二：大对象的建立消耗资源，系统的性能需要考虑</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>clone方式的备忘录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Originator implements Cloneable &#123;</span><br><span class="line">    private Originator backup;</span><br><span class="line">    //内部状态</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        this.backup = this.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public void restoreMemento() &#123;</span><br><span class="line">        this.setState(this.backup.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected Originator clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Originator)super.clone();</span><br><span class="line">        &#125; catch(CloneNotSupporteException e) &#123;</span><br><span class="line">            e.printStackTace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void mian(String[] args) &#123;</span><br><span class="line">        Originator = originator = new Originator();</span><br><span class="line">        originator.setState(&quot;初始状态..&quot;);</span><br><span class="line">        originator.createMemento();        </span><br><span class="line">        originator.setState(&quot;修改后的状态..&quot;);</span><br><span class="line">        originator.restoreMemento();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多状态的备忘录模式</p></li><li>多备份的备忘录</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;在不破坏封装性的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态。这样以后就可将该对象回复到原先保存的状态。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Originator发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据&lt;/li&gt;
&lt;li&gt;Memento备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态&lt;/li&gt;
&lt;li&gt;Caretaker备忘录管理员角色 对备忘录进行管理、保存和提供备忘录&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="备忘录模式" scheme="http://ElaineKoo.github.io/tags/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>门面模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/门面模式/</id>
    <published>2018-11-21T05:57:42.000Z</published>
    <updated>2018-11-21T06:30:43.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>又叫外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Facade门面角色 此角色知晓子系统的所有功能和责任</li><li>subsystem子系统角色 可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道门面的存在。</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ClassA &#123;</span><br><span class="line">    public void doSomethingA() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassB &#123;</span><br><span class="line">    public void doSomethingB() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassC &#123;</span><br><span class="line">    public void doSomethingC() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Facade &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassB b = new ClassB();</span><br><span class="line">    private ClassC c = new ClassC();</span><br><span class="line">    </span><br><span class="line">    public void methodA() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodB() &#123;</span><br><span class="line">        this.a.doSomethingB();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodC() &#123;</span><br><span class="line">        this.a.doSomethingC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>减少系统的相互依赖 所有的依赖都是对门面对象的依赖，与子系统无关</li><li>提高了灵活性 依赖减少了，灵活性自然提高了</li><li>提高安全性 想让你访问子系统的哪些业务就开通哪些逻辑</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>最大的缺点是不符合开闭原则，如果要修改，唯一能做的就是修改门面角色的代码，风险相当大</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>为一个复杂的模块或子系统提供一个供外界访问的接口</li><li>子系统相对独立，外界对子系统的访问只要黑箱操作即可</li><li>预防低水平人员带来的风险扩散</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>一个子系统可以有多个门面，(1)门面可拆分 (2)子系统可以提供不同的访问路径，新增一个引用原有门面的门面</li><li>门面不参与子系统内的业务逻辑，门面对象只是提供一个访问子系统的一个路径而已，不应该参与具体的业务逻辑，否则会产生一个倒依赖的问题：子系统必须依赖门面才能被访问，不仅违反了单一职责原则，同事也破坏了系统的封装性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassC c = new ClassC();</span><br><span class="line">    public void complexMethod() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">        this.c.doSomethingC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Facade &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassB b = new ClassB();</span><br><span class="line">    private Context context = new Context();</span><br><span class="line">    </span><br><span class="line">    public void methodA() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodB() &#123;</span><br><span class="line">        this.a.doSomethingB();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodC() &#123;</span><br><span class="line">        this.context.complexMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;又叫外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Facade门面角色 此角色知晓子系统的所有功能和责任&lt;/li&gt;
&lt;li&gt;subsystem子系统角色 可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道门面的存在。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="门面模式" scheme="http://ElaineKoo.github.io/tags/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/观察者模式/</id>
    <published>2018-11-21T03:01:52.000Z</published>
    <updated>2018-11-21T05:56:50.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Subject被观察者</li><li>Observer观察者</li><li>ConcreteSubject具体的被观察者</li><li>ConcreteObserver具体的观察者</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subject &#123;</span><br><span class="line">    private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();</span><br><span class="line">    public void addObserver(Observer o) &#123;</span><br><span class="line">        this.obsVector.add(o);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void delObserver(Observer o) &#123;</span><br><span class="line">        this.obsVector.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for(Observer o:this.obsVector) &#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject extends Subject &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        super.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">    public void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserver implements Observer &#123;</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;接收到信息，并进行处理！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line">        Observer obs = new ConcreteObserver();</span><br><span class="line">        subject.addObserver(obs);</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>观察者和被观察者之间是抽象耦合</li><li>建立一套触发机制</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>顺序执行，一个观察者卡壳，影响整体，一般考虑采用异步方式</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>关联行为场景</li><li>事件多级触发场景</li><li>跨系统的消息交换场景，如消息队列处理机制</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>广播链问题 一个观察者模式中最多出现一个对象既是观察者也是被观察者，消息最多转发一次。</li><li>异步处理问题</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>文件系统</li><li>猫鼠游戏</li><li>ATM取钱</li><li>广播收音机</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Subject被观察者&lt;/li&gt;
&lt;li&gt;Observer观察者&lt;/li&gt;
&lt;li&gt;ConcreteSubject具体的被观察者&lt;/li&gt;
&lt;li&gt;ConcreteObserver具体的观察者&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="http://ElaineKoo.github.io/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>组合模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/21/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/21/组合模式/</id>
    <published>2018-11-21T02:35:40.000Z</published>
    <updated>2018-11-21T03:01:29.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫合成模式、整体模式。将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Component抽象构件角色 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性</li><li>Leaf叶子构件 叶子对象</li><li>Composite树枝构件 树枝对象</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Composite extends Component &#123;</span><br><span class="line">    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();</span><br><span class="line">    public void add(Component component) &#123;</span><br><span class="line">        this.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove(Component component) &#123;</span><br><span class="line">        this.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line">    public ArrayList&lt;Component&gt; getChildren() &#123;</span><br><span class="line">        return this.componentArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Leaf extends Component &#123;</span><br><span class="line">    //可以覆写</span><br><span class="line">    public void doSomething() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Composite root new Composite();</span><br><span class="line">        root.doSomething();</span><br><span class="line">        Composite branch = new Composite();</span><br><span class="line">        Leaf leaf = new Leaf();</span><br><span class="line">        root.add(branch);</span><br><span class="line">        branch.add(leaf);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void display(Composite root) &#123;</span><br><span class="line">        for(Component c:root.getChildren()) &#123;</span><br><span class="line">            if(c instanceof Leaf) &#123;</span><br><span class="line">                c.doSomething();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                display((Composite)c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>高层模块调用简单</li><li>节点自由增加</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>与依赖倒置原则冲突</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</li><li>从一个整体中能够独立出部分模块或功能的场景。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫合成模式、整体模式。将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Component抽象构件角色 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性&lt;/li&gt;
&lt;li&gt;Leaf叶子构件 叶子对象&lt;/li&gt;
&lt;li&gt;Composite树枝构件 树枝对象&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="组合模式" scheme="http://ElaineKoo.github.io/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>迭代器模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/20/迭代器模式/</id>
    <published>2018-11-20T10:16:30.000Z</published>
    <updated>2018-11-20T10:48:49.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它提供一种方法访问一个容器对象中的各个元素，而不需要暴露该对象的内部细节。<br>没落的模式，基本么有人会单独写一个迭代器。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Iterator抽象迭代器 first，next，isDone</li><li>ConcreteIterator具体迭代器</li><li>Aggregate抽象容器 容器角色负责提供创建具体迭代器角色的接口</li><li>ConcreteAggregate具体容器 实现容器接口定义的方法，创建出容纳迭代器的对象</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">    public Object next();</span><br><span class="line">    public boolean hasNext();</span><br><span class="line">    public boolean remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ConcreteInterator implements Ieterator &#123;</span><br><span class="line">    private Vector vector = new Vector();</span><br><span class="line">    </span><br><span class="line">    public int cursor = 0;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public ConcreteIeterator(Vector _vector) &#123;</span><br><span class="line">        this.vector = _vector;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        if(this.cursor == this.vector.size()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object next() &#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        if(this.hasNext()) &#123;</span><br><span class="line">            result = this.vector.get(this.cursor++);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove() &#123;</span><br><span class="line">        this.vector.remove(this.cursor);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Aggregate &#123;</span><br><span class="line">    public void add(Object object);</span><br><span class="line">    public void remove(Object object);</span><br><span class="line">    public Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteAggregate implements Aggregate &#123;</span><br><span class="line">    private Vector vector = new Vector();</span><br><span class="line">    public void add(Object object) &#123;</span><br><span class="line">        this.vector.add(object);</span><br><span class="line">    &#125;</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new ConcreteIterator(this.vector);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove(Object object) &#123;</span><br><span class="line">        this.remove(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Aggregate agg = new ConcreteAggregate();</span><br><span class="line">        agg.add(&quot;abc&quot;);</span><br><span class="line">        agg.add(&quot;aaa&quot;);</span><br><span class="line">        agg.add(&quot;1234&quot;);</span><br><span class="line">        </span><br><span class="line">        Iterator iterator = agg.iterator();</span><br><span class="line">        while(iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;它提供一种方法访问一个容器对象中的各个元素，而不需要暴露该对象的内部细节。&lt;br&gt;没落的模式，基本么有人会单独写一个迭代器。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Iterator抽象迭代器 first，next，isDone&lt;/li&gt;
&lt;li&gt;ConcreteIterator具体迭代器&lt;/li&gt;
&lt;li&gt;Aggregate抽象容器 容器角色负责提供创建具体迭代器角色的接口&lt;/li&gt;
&lt;li&gt;ConcreteAggregate具体容器 实现容器接口定义的方法，创建出容纳迭代器的对象&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="http://ElaineKoo.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/20/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/20/适配器模式/</id>
    <published>2018-11-20T06:18:48.000Z</published>
    <updated>2018-12-17T06:22:19.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>又叫变压器模式、包装模式，将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</p><h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><ol><li>Target目标角色</li><li>Adaptee源角色</li><li>Adapter适配器角色</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Target &#123;</span><br><span class="line">    //目标角色有自己的方法</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public vlass ConcreteTarget implements Target &#123;</span><br><span class="line">    pubilc void request() &#123;</span><br><span class="line">        System.out.println(&quot;xxxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;zzzzz&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public vlass Adapter extends Adaptee implements Target &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        super.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //原</span><br><span class="line">        Target target = new ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line">        //适配器</span><br><span class="line">        Target target2 = new Adapter();</span><br><span class="line">        target2.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>适配器模式可以让两个没有任何关系的类在一起运行</li><li>增加了类的透明性</li><li>提高类的复用度</li><li>灵活性非常好</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>你有动机修改一个已经投产中的接口时</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要在开发阶段考虑，解决的是正在服役中的项目问题<br>项目一定要遵守依赖倒置原则和里氏替换原则</p><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与装饰模式比：适配器模式修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，本质是非相同接口的对象。关注的是转化，意图是不同对象之间的转化。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;又叫变压器模式、包装模式，将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作&lt;/p&gt;
&lt;h2 id=&quot;三个角色&quot;&gt;&lt;a href=&quot;#三个角色&quot; class=&quot;headerlink&quot; title=&quot;三个角色&quot;&gt;&lt;/a&gt;三个角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Target目标角色&lt;/li&gt;
&lt;li&gt;Adaptee源角色&lt;/li&gt;
&lt;li&gt;Adapter适配器角色&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://ElaineKoo.github.io/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>策略模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/20/策略模式/</id>
    <published>2018-11-20T02:56:10.000Z</published>
    <updated>2018-12-17T07:42:20.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫做政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Context封装角色 上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化</li><li>Strategy抽象策略角色 策略算法的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性</li><li>ConcreteStrategy具体策略角色 实现抽象策略</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategy1 implements Strategy &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategy2 implements Strategy &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重点：封装角色，借用了代理模式的思路，区别在于策略模式的封装角色和被封装的策略类不用是同一个接口，如果是同一个接口就成为代理模式</span><br><span class="line">public class Context &#123;</span><br><span class="line">    private Strategy strategy = null;</span><br><span class="line">    public Context(Strategy _strategy) &#123;</span><br><span class="line">        this.strategy = _strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">        this.strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Strategy strategy = new ConcreteStrategy1();</span><br><span class="line">        Context context = new Context(strategy);</span><br><span class="line">        context.doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>算法可以自由切换</li><li>避免使用多重条件判断</li><li>扩展性良好</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>策略类数量增多 复用可能性小，类数量增多</li><li>所有策略类都要对外暴露 违反迪米特法则，可使用其他模式修正缺陷，如工厂方法模式、代理模式或享元模式</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个类只有在算法或行为上稍有不同的场景</li><li>算法需要自由切换的场景</li><li>需要屏蔽算法规则的场景</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀或对外暴露的问题。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>策略枚举</li></ol><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与命令模式比：策略模式关注是算法替换问题。关注的是算法的完整性、封装性，只有具备了这两个条件才能保证其可以自由切换。具体算法是负责一个完整算法逻辑，它是不可再拆分的原子业务单元，一旦变更就是对算法整体的变更。</li><li>与状态模式比：策略模式封装的是不同的算法，算法之间没有交互。策略模式的环境角色只是一个委托作用，负责算法的替换。</li><li>与桥梁模式比：策略模式是行为模式，旨在封装一系列行为。使用继承和多态建立一套可以自由切换算法的模式。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫做政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Context封装角色 上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化&lt;/li&gt;
&lt;li&gt;Strategy抽象策略角色 策略算法的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性&lt;/li&gt;
&lt;li&gt;ConcreteStrategy具体策略角色 实现抽象策略&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="策略模式" scheme="http://ElaineKoo.github.io/tags/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/装饰模式/</id>
    <published>2018-11-19T10:39:59.000Z</published>
    <updated>2018-12-17T06:22:48.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。</p><h2 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h2><ol><li>Component抽象构件 定义最核心、最原始的对象</li><li>ConcreteComponent具体构件 最核心、最原始的对象的实现</li><li>Decorator装饰角色 一般是一个抽象类，实现接口或者抽象方法，里面不一定有抽象的方法，属性里必然有一个private变量指向Component抽象构件</li><li>具体装饰角色</li></ol><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public abstract void operate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteComponent extends Component &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        System.out.println(&apos;do Something&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Decorator extends Component &#123;</span><br><span class="line">    private Component component = null;</span><br><span class="line">    public Decorator(Component _component) &#123;</span><br><span class="line">        this.component = _component;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        this.component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecorator1 extends Decorator &#123;</span><br><span class="line">    publicConcreteDecorator1(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void method1() &#123;</span><br><span class="line">        System.out,println(&apos;method 1 修饰&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Operate() &#123;</span><br><span class="line">        this.method1();</span><br><span class="line">        super.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecorator2 extends Decorator &#123;</span><br><span class="line">    publicConcreteDecorator1(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void method2() &#123;</span><br><span class="line">        System.out,println(&apos;method 1 修饰&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Operate() &#123;</span><br><span class="line">        super.operate();</span><br><span class="line">        this.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Component component = new ConcreteComponent();</span><br><span class="line">        component = new ConcreteDecorator1(component);</span><br><span class="line">        component = new ConcreteDecorator2(component);</span><br><span class="line">        component.operator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>装饰类和被装饰类可以独立发展，不会互相耦合。</li><li>装饰模式是继承关系的一个替代方案。</li><li>装饰模式可以动态扩展一个实现类的功能。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>多层的装饰是比较复杂的，尽量减少装饰的数量，以降低系统的复杂度</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要扩展一个类的功能，或给一个类增加附加功能</li><li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销</li><li>需要为一批的兄弟类进行改装或加装功能，首选装饰模式</li></ol><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与代理模式比：装饰模式在保证接口不变的情况下加强类的功能，保证被修饰的对象功能比原始对象丰富，但不做准入条件判断和准入参数过滤</li><li>与适配器模式比：装饰模式包装的是自己的兄弟类，隶属同一个家族。意图是加强对象的功能。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。&lt;/p&gt;
&lt;h2 id=&quot;四个角色&quot;&gt;&lt;a href=&quot;#四个角色&quot; class=&quot;headerlink&quot; title=&quot;四个角色&quot;&gt;&lt;/a&gt;四个角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Component抽象构件 定义最核心、最原始的对象&lt;/li&gt;
&lt;li&gt;ConcreteComponent具体构件 最核心、最原始的对象的实现&lt;/li&gt;
&lt;li&gt;Decorator装饰角色 一般是一个抽象类，实现接口或者抽象方法，里面不一定有抽象的方法，属性里必然有一个private变量指向Component抽象构件&lt;/li&gt;
&lt;li&gt;具体装饰角色&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰模式" scheme="http://ElaineKoo.github.io/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/责任链模式/</id>
    <published>2018-11-19T09:34:23.000Z</published>
    <updated>2018-11-19T10:18:08.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。</p><ul><li>实际应用中，一般会有一个封装类对责任模式进行封装，替代Client类，直接返回链中第一个处理者，具体链的设置不需要高层次模块关系 *</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>将请求和处理分开，解耦，提高系统灵活性</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>性能问题，每个请求都是从链头遍历到链尾</li><li>调试不方便，类似递归</li></ol><ul><li>链中节点数量控制，避免超长链，一般做法是在Handler中这是一个最大节点数量，太长则不允许链建立 * </li></ul><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractLogger &#123;</span><br><span class="line">   public static int INFO = 1;</span><br><span class="line">   public static int DEBUG = 2;</span><br><span class="line">   public static int ERROR = 3;</span><br><span class="line"> </span><br><span class="line">   protected int level;</span><br><span class="line"> </span><br><span class="line">   //责任链中的下一个元素</span><br><span class="line">   protected AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   public void setNextLogger(AbstractLogger nextLogger)&#123;</span><br><span class="line">      this.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void logMessage(int level, String message)&#123;</span><br><span class="line">      if(this.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      if(nextLogger !=null)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   abstract protected void write(String message);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConsoleLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public ConsoleLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;Standard Console::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ErrorLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public ErrorLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;Error Console::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FileLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public FileLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;File::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChainPatternDemo &#123;</span><br><span class="line">   </span><br><span class="line">   private static AbstractLogger getChainOfLoggers()&#123;</span><br><span class="line"> </span><br><span class="line">      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"> </span><br><span class="line">      errorLogger.setNextLogger(fileLogger);</span><br><span class="line">      fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"> </span><br><span class="line">      return errorLogger;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, </span><br><span class="line">         &quot;This is an information.&quot;);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </span><br><span class="line">         &quot;This is an debug level information.&quot;);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </span><br><span class="line">         &quot;This is an error information.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Standard Console::Logger: This is an information.</span><br><span class="line">File::Logger: This is an debug level information.</span><br><span class="line">Standard Console::Logger: This is an debug level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">File::Logger: This is an error information.</span><br><span class="line">Standard Console::Logger: This is an error information.</span><br></pre></td></tr></table></figure></p><p>参考<br>《设计模式之禅》<br><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际应用中，一般会有一个封装类对责任模式进行封装，替代Client类，直接返回链中第一个处理者，具体链的设置不需要高层次模块关系 *&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;p&gt;将请求和处理分开，解耦，提高系统灵活性&lt;/p&gt;
&lt;h2 id=&quot;缺点&quot;&gt;&lt;a href=&quot;#缺点&quot; class=&quot;headerlink&quot; title=&quot;缺点&quot;&gt;&lt;/a&gt;缺点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;性能问题，每个请求都是从链头遍历到链尾&lt;/li&gt;
&lt;li&gt;调试不方便，类似递归&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;链中节点数量控制，避免超长链，一般做法是在Handler中这是一个最大节点数量，太长则不允许链建立 * &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="责任链模式" scheme="http://ElaineKoo.github.io/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>命令模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/命令模式/</id>
    <published>2018-11-19T08:36:11.000Z</published>
    <updated>2018-12-17T06:51:24.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Receive接收者角色</li><li>Command命令角色</li><li>Invoker调用者角色</li></ol><p><em>封装性好，把请求方（Invoker）和执行方（Receiver）分开</em></p><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Receiver &#123;</span><br><span class="line">    //抽象接收者，定义每个接收者都必须完成的业务</span><br><span class="line">    public abstract void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteReceiver1 extends Receiver &#123;</span><br><span class="line">    //每个接收者都必须处理一定的业务逻辑</span><br><span class="line">    public void doSomthing()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteReceiver2 extends Receiver &#123;</span><br><span class="line">    //每个接收者都必须处理一定的业务逻辑</span><br><span class="line">    public void doSomthing()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Command &#123;</span><br><span class="line">    //每个命令都有一个执行命令的方法</span><br><span class="line">    public abstract void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteCommand1 extends Command &#123;</span><br><span class="line">    //对哪个Receiver类进行命令处理</span><br><span class="line">    private Receiver receiver;</span><br><span class="line">    public ConcreteCommand1(Receiver _receiver) &#123;</span><br><span class="line">        this.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteCommand2 extends Command &#123;</span><br><span class="line">    //对哪个Receiver类进行命令处理</span><br><span class="line">    private Receiver receiver;</span><br><span class="line">    public ConcreteCommand2(Receiver _receiver) &#123;</span><br><span class="line">        this.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Invoker &#123;</span><br><span class="line">    private Command command;</span><br><span class="line">    //接受命令</span><br><span class="line">    public void setCommand(Command _command) &#123;</span><br><span class="line">        this.command = _command;</span><br><span class="line">    &#125;</span><br><span class="line">    public void action() &#123;</span><br><span class="line">        this.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Invoker invoker = new Invoker();</span><br><span class="line">        Receiver receiver = new ConcreteReceiver1();</span><br><span class="line">        Command command = new ConcreteCommand1(receiver);</span><br><span class="line">        </span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>类间解耦 调用者角色与接收者角色之间没有任何依赖关系，不需要了解到底是哪个接收者执行</li><li>可扩展性 Command子类非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合</li><li>命令模式结合其他模式会更优秀 可以结合责任链模式，实现命令族解析任务；结合模板方法模式，减少Command子类的膨胀问题</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>如果有N个命令，Command的子类就是N个，类膨胀非常大</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>只要你任务是命令的地方，例如GUI开发中的一个按钮点击；模拟DOS命令；触发-反馈机制的处理等</p><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与策略模式比：命令模式的主旨是封装命令，使请求者与实现者解耦。关注的是解耦问题，把请求的内容封装为一个个的命令，由接收者执行。关注命令的实现，也就是功能的实现。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;&lt;a href=&quot;#角色&quot; class=&quot;headerlink&quot; title=&quot;角色&quot;&gt;&lt;/a&gt;角色&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Receive接收者角色&lt;/li&gt;
&lt;li&gt;Command命令角色&lt;/li&gt;
&lt;li&gt;Invoker调用者角色&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;封装性好，把请求方（Invoker）和执行方（Receiver）分开&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="命令模式" scheme="http://ElaineKoo.github.io/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中介者模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/19/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/19/中介者模式/</id>
    <published>2018-11-19T07:31:20.000Z</published>
    <updated>2018-11-19T08:45:44.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫调停者模式<br>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li>Mediator 抽象中介者角色<br>定义统一的接口，用于各同事角色之间的通信</li><li>Concrete Mediator 具体中介者角色<br>通过协调各同事角色实现协作行为，必须依赖于各个同事角色</li><li>Colleague 同事角色<br>每个同事角色都知道中介者角色，而且与其他的同事角色通信时，一定要通过中介者角色协作。<br>每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。</li></ol><a id="more"></a><h2 id="通用源代码"><a href="#通用源代码" class="headerlink" title="通用源代码"></a>通用源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Mediator &#123;</span><br><span class="line">    //定义同事类</span><br><span class="line">    protected ConcreteColleague1 c1;</span><br><span class="line">    protected ConcreteColleague2 c2;</span><br><span class="line">    </span><br><span class="line">    //注入同事类</span><br><span class="line">    public ConcreteColleague1 getC1() &#123;</span><br><span class="line">        return c1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setC1(ConcreteColleague1 c1) &#123;</span><br><span class="line">        this.c1 = c1; </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public ConcreteColleague2 getC2() &#123;</span><br><span class="line">        return c2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setC2(ConcreteColleague2 c2) &#123;</span><br><span class="line">        this.c2 = c2; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void doSomething1();</span><br><span class="line">    public abstract void doSomething2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteMediator extends Mediator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething1() &#123;</span><br><span class="line">        super.c1.selfMethod1();</span><br><span class="line">        super.c2.selfMethod2();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void doSomething2() &#123;</span><br><span class="line">        super.c1.selfMethod1();</span><br><span class="line">        super.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Colleague &#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    public Colleague(Mediator _mediator) &#123;</span><br><span class="line">        this.mediator = _mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteColleague1 extends Colleague &#123;</span><br><span class="line">    public ConcreteColleague1(Mediator _mediator) &#123;</span><br><span class="line">        super(_mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    //自有方法</span><br><span class="line">    public void selfMethod1() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    //依赖方法</span><br><span class="line">    public void depMethod1() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">        //自己不能处理的业务逻辑，委托给中介者处理</span><br><span class="line">        super.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteColleague2 extends Colleague &#123;</span><br><span class="line">    public ConcreteColleague2(Mediator _mediator) &#123;</span><br><span class="line">        super(_mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    //自有方法</span><br><span class="line">    public void selfMethod2() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    //依赖方法</span><br><span class="line">    public void depMethod2() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">        //自己不能处理的业务逻辑，委托给中介者处理</span><br><span class="line">        super.mediator.doSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>减少类间的依赖，把原有的一对多的依赖变成一对一依赖<br>同事类只依赖中介者，减少了依赖，降低了类间的耦合</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>中介者会膨胀得很快，而且逻辑复杂，同事类越多，中介者的逻辑越复杂</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>机场调度中心</li><li>MVC框架 C就是中介者，隔开M和V，减少M和V的依赖关系。</li><li>媒体网关</li><li>中介服务</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>N个对象之间产生了相互的依赖关系（N&gt;2）</li><li>多个对象有依赖关系，但依赖的行为尚不确定或者有发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散</li><li>产品开发 提升产品的性能和扩展性</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;也叫调停者模式&lt;br&gt;用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/p&gt;
&lt;h2 id=&quot;组成&quot;&gt;&lt;a href=&quot;#组成&quot; class=&quot;headerlink&quot; title=&quot;组成&quot;&gt;&lt;/a&gt;组成&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Mediator 抽象中介者角色&lt;br&gt;定义统一的接口，用于各同事角色之间的通信&lt;/li&gt;
&lt;li&gt;Concrete Mediator 具体中介者角色&lt;br&gt;通过协调各同事角色实现协作行为，必须依赖于各个同事角色&lt;/li&gt;
&lt;li&gt;Colleague 同事角色&lt;br&gt;每个同事角色都知道中介者角色，而且与其他的同事角色通信时，一定要通过中介者角色协作。&lt;br&gt;每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="中介者模式" scheme="http://ElaineKoo.github.io/tags/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记 laravel chunk 遇到的坑</title>
    <link href="http://ElaineKoo.github.io/2018/11/15/%E8%AE%B0laravel-chunk%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>http://ElaineKoo.github.io/2018/11/15/记laravel-chunk遇到的坑/</id>
    <published>2018-11-15T06:15:43.000Z</published>
    <updated>2018-11-19T07:29:11.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flight::chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //对每条数据做一些处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果’flights’表中有1000条数据，将拆成10次查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` limit 100 offset 0</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 100</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 200</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 300</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 400</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 500</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 600</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 700</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 800</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 900</span><br><span class="line">//对每条数据做一些处理</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><table><thead><tr><th>id</th><th>xx</th><th>yy  </th></tr></thead><tbody><tr><td> 1</td><td>0</td><td>0  </td></tr><tr><td> 2</td><td>0</td><td>0  </td></tr><tr><td> 3</td><td>0</td><td>0  </td></tr><tr><td> ..</td><td>..</td><td>.. </td></tr><tr><td> ..</td><td>..</td><td>..  </td></tr><tr><td>1000</td><td>0</td><td>0  </td></tr></tbody></table><h2 id="如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。"><a href="#如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。" class="headerlink" title="如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。"></a>如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flight::where(&apos;xx&apos;, 0)-&gt;chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //$res = 通过flight与关联表的关系得出来值，这也是我们为什么需要通过这种方法更新 </span><br><span class="line">        $flight-&gt;yy = $res;</span><br><span class="line">        $flight-&gt;save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更新所有xx=0的yy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 0</span><br><span class="line">update `flights` set `yy` = 152 where `id` = 1 </span><br><span class="line">update `flights` set `yy` = 12 where `id` = 2 </span><br><span class="line">update `flights` set `yy` = 123 where `id` = 3 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 52 where `id` = 99</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 100</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 100</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 101 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =102 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 103 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 199</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 200</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 200</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 201 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =202 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 203 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 299</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 300</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 300</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 400</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 500</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 600</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 700</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 800</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 900</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 901 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =902 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 903 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 999</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 1000</span><br></pre></td></tr></table></figure><h2 id="如果我们按yy进行筛选，更新yy字段，这样就会出问题。"><a href="#如果我们按yy进行筛选，更新yy字段，这样就会出问题。" class="headerlink" title="如果我们按yy进行筛选，更新yy字段，这样就会出问题。"></a>如果我们按yy进行筛选，更新yy字段，这样就会出问题。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flight::where(&apos;yy&apos;, 0)-&gt;chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //$res = 通过flight与关联表的关系得出来值(反正不是0)，这也是我们为什么需要通过这种方法更新 </span><br><span class="line">        $flight-&gt;yy = $res;</span><br><span class="line">        $flight-&gt;save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更新所有yy=0的yy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 0</span><br><span class="line">update `flights` set `yy` = 152 where `id` = 1 </span><br><span class="line">update `flights` set `yy` = 12 where `id` = 2 </span><br><span class="line">update `flights` set `yy` = 123 where `id` = 3 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 52 where `id` = 99</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 100</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 100</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 201 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =202 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 203 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 299</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 300</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 200</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 401 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =402 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 403 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 499</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 400</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 300</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 601 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =602 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 603 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 699</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 600</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 400</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 801 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =802 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 803 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 899</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 800</span><br></pre></td></tr></table></figure><p>很困惑，为什么表中还是有yy=0的数据。<br>在执行 <code>select * from flights where  yy = 0 limit 100 offset 100</code> 之前，id=1~100的数据yy已经不等于0了，所以在执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 100</span><br></pre></td></tr></table></figure></p><p>的时候，搜索出的是id=201~300的数据，而id=101~200的数据，只有在再次搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 0</span><br></pre></td></tr></table></figure></p><p>的时候才会出现。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>所以，我们要避免使用 chunk 的时候，更改和过滤条件的字段的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Flight::chunk(100, function ($flights) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    foreach ($flights as $flight) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果’flights’表中有1000条数据，将拆成10次查询：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 300&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 400&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 500&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 600&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 700&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 800&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;select * from `flights` limit 100 offset 900&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//对每条数据做一些处理&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="laravel" scheme="http://ElaineKoo.github.io/tags/laravel/"/>
    
      <category term="php" scheme="http://ElaineKoo.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>原型模式</title>
    <link href="http://ElaineKoo.github.io/2018/11/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://ElaineKoo.github.io/2018/11/13/原型模式/</id>
    <published>2018-11-13T07:26:06.000Z</published>
    <updated>2018-11-19T04:30:35.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式<br>简单程度仅次于单例模式和迭代器模式，使用广泛<br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建的对象<br>核心就是clone方法，通过该方法进行对象的拷贝，JAVA提供了Cloneable接口，标示这个对象是可拷贝的。覆写clone方法。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>性能优良。原型模式是内存二进制流的拷贝。</li><li>逃避构造函数的约束。不执行构造函数，优点和缺点都是减少了约束。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>资源优化场景。类初始化需要消化非常多的资源，包括数据和硬件资源等。</li><li>性能和安全要求的场景。通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li><li>一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时。</li></ol><p><em>原型模式很少单独出现，一般和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</em></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>构造函数不会被执行</li><li>浅拷贝和深拷贝<br><em>使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变类型</em></li><li>clone与final关键字冲突</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式&lt;br&gt;简单程度仅次于单例模式和迭代器模式，使用广泛&lt;br&gt;用原型
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://ElaineKoo.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="原型模式" scheme="http://ElaineKoo.github.io/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
