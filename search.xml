<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记 laravel chunk 遇到的坑]]></title>
    <url>%2F2018%2F11%2F15%2F%E8%AE%B0laravel-chunk%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：12345Flight::chunk(100, function ($flights) &#123; foreach ($flights as $flight) &#123; //对每条数据做一些处理 &#125;&#125;); 如果’flights’表中有1000条数据，将拆成10次查询：1234567891011121314151617181920select * from `flights` limit 100 offset 0//对每条数据做一些处理select * from `flights` limit 100 offset 100//对每条数据做一些处理select * from `flights` limit 100 offset 200//对每条数据做一些处理select * from `flights` limit 100 offset 300//对每条数据做一些处理select * from `flights` limit 100 offset 400//对每条数据做一些处理select * from `flights` limit 100 offset 500//对每条数据做一些处理select * from `flights` limit 100 offset 600//对每条数据做一些处理select * from `flights` limit 100 offset 700//对每条数据做一些处理select * from `flights` limit 100 offset 800//对每条数据做一些处理select * from `flights` limit 100 offset 900//对每条数据做一些处理 问题 id xx yy 1 0 0 2 0 0 3 0 0 .. .. .. .. .. .. 1000 0 0 如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。1234567Flight::where(&apos;xx&apos;, 0)-&gt;chunk(100, function ($flights) &#123; foreach ($flights as $flight) &#123; //$res = 通过flight与关联表的关系得出来值，这也是我们为什么需要通过这种方法更新 $flight-&gt;yy = $res; $flight-&gt;save(); &#125;&#125;); 更新所有xx=0的yy。 12345678910111213141516171819202122232425262728293031323334353637383940select * from `flights` where `xx` = 0 limit 100 offset 0update `flights` set `yy` = 152 where `id` = 1 update `flights` set `yy` = 12 where `id` = 2 update `flights` set `yy` = 123 where `id` = 3 ...update `flights` set `yy` = 52 where `id` = 99update `flights` set `yy` = 512 where `id` = 100select * from `flights` where `xx` = 0 limit 100 offset 100update `flights` set `yy` = 12 where `id` = 101 update `flights` set `yy` = 112 where `id` =102 update `flights` set `yy` = 13 where `id` = 103 ...update `flights` set `yy` = 5 where `id` = 199update `flights` set `yy` = 512 where `id` = 200select * from `flights` where `xx` = 0 limit 100 offset 200update `flights` set `yy` = 12 where `id` = 201 update `flights` set `yy` = 112 where `id` =202 update `flights` set `yy` = 13 where `id` = 203 ...update `flights` set `yy` = 5 where `id` = 299update `flights` set `yy` = 512 where `id` = 300select * from `flights` where `xx` = 0 limit 100 offset 300...select * from `flights` where `xx` = 0 limit 100 offset 400...select * from `flights` where `xx` = 0 limit 100 offset 500...select * from `flights` where `xx` = 0 limit 100 offset 600...select * from `flights` where `xx` = 0 limit 100 offset 700...select * from `flights` where `xx` = 0 limit 100 offset 800...select * from `flights` where `xx` = 0 limit 100 offset 900update `flights` set `yy` = 12 where `id` = 901 update `flights` set `yy` = 112 where `id` =902 update `flights` set `yy` = 13 where `id` = 903 ...update `flights` set `yy` = 5 where `id` = 999update `flights` set `yy` = 512 where `id` = 1000 如果我们按yy进行筛选，更新yy字段，这样就会出问题。1234567Flight::where(&apos;yy&apos;, 0)-&gt;chunk(100, function ($flights) &#123; foreach ($flights as $flight) &#123; //$res = 通过flight与关联表的关系得出来值(反正不是0)，这也是我们为什么需要通过这种方法更新 $flight-&gt;yy = $res; $flight-&gt;save(); &#125;&#125;); 更新所有yy=0的yy。 1234567891011121314151617181920212223242526272829303132333435select * from `flights` where `yy` = 0 limit 100 offset 0update `flights` set `yy` = 152 where `id` = 1 update `flights` set `yy` = 12 where `id` = 2 update `flights` set `yy` = 123 where `id` = 3 ...update `flights` set `yy` = 52 where `id` = 99update `flights` set `yy` = 512 where `id` = 100select * from `flights` where `yy` = 0 limit 100 offset 100update `flights` set `yy` = 12 where `id` = 201 update `flights` set `yy` = 112 where `id` =202 update `flights` set `yy` = 13 where `id` = 203 ...update `flights` set `yy` = 5 where `id` = 299update `flights` set `yy` = 512 where `id` = 300select * from `flights` where `yy` = 0 limit 100 offset 200update `flights` set `yy` = 12 where `id` = 401 update `flights` set `yy` = 112 where `id` =402 update `flights` set `yy` = 13 where `id` = 403 ...update `flights` set `yy` = 5 where `id` = 499update `flights` set `yy` = 512 where `id` = 400select * from `flights` where `yy` = 0 limit 100 offset 300update `flights` set `yy` = 12 where `id` = 601 update `flights` set `yy` = 112 where `id` =602 update `flights` set `yy` = 13 where `id` = 603 ...update `flights` set `yy` = 5 where `id` = 699update `flights` set `yy` = 512 where `id` = 600select * from `flights` where `yy` = 0 limit 100 offset 400update `flights` set `yy` = 12 where `id` = 801 update `flights` set `yy` = 112 where `id` =802 update `flights` set `yy` = 13 where `id` = 803 ...update `flights` set `yy` = 5 where `id` = 899update `flights` set `yy` = 512 where `id` = 800 很困惑，为什么表中还是有yy=0的数据。在执行 select * from flights where yy = 0 limit 100 offset 100 之前，id=1~100的数据yy已经不等于0了，所以在执行1select * from `flights` where `yy` = 0 limit 100 offset 100 的时候，搜索出的是id=201~300的数据，而id=101~200的数据，只有在再次搜索1select * from `flights` where `yy` = 0 limit 100 offset 0 的时候才会出现。 结论所以，我们要避免使用 chunk 的时候，更改和过滤条件的字段的值。]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>php</tag>
        <tag>chunk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式简单程度仅次于单例模式和迭代器模式，使用广泛用原型实例指定创建对象的种类，并且通过拷贝这些原型创建的对象核心就是clone方法，通过该方法进行对象的拷贝，JAVA提供了Cloneable接口，标示这个对象是可拷贝的。覆写clone方法。 优点 性能优良。原型模式是内存二进制流的拷贝。 逃避构造函数的约束。不执行构造函数，优点和缺点都是减少了约束。 使用场景 资源优化场景。类初始化需要消化非常多的资源，包括数据和硬件资源等。 性能和安全要求的场景。通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时。 原型模式很少单独出现，一般和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者 注意 构造函数不会被执行 浅拷贝和深拷贝使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变类型 clone与final关键字冲突 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义也叫委托模式，为其他对象提供一种代理，以控制对这个对象的访问。使用率非常高。提供非常好的访问控制。 角色 Subject抽象主题角色。可以是抽象类也可以是接口 RealSubject具体主题角色。也称为被委托角色或被代理角色，业务逻辑的具体执行者 Proxy代理主题角色。也称为委托类、代理类 代码123456789101112131415161718192021222324252627282930public interface Subject &#123; public void request();&#125;public class RealSubject implements Subject &#123; public void request() &#123; //业务逻辑 &#125;&#125;public class Proxy implements Subject &#123; private Subject subject = null; public Proxy() &#123; this.subject = new Proxy(); &#125; public Proxy(Subject subject) &#123; this.subject = subject; &#125; public void request() &#123; this.before(); this.subject.request(); this.after(); &#125; public void before() &#123;&#125; public void after() &#123;&#125;&#125; 优点 职责清晰。真实角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰 高扩展性。具体主题角色随时发生变化，不管怎么变化，只要实现了接口，那代理类完全就可以在不做任何修改的情况下使用。 使用场景Spring AOP 扩展 普通代理，要求客户端只能访问代理角色，而不能访问真实角色。普通代理模式的约束问题，尽量通过团队内的变成规范类约束，因为每一个主题类是可被重用的和可维护的，实用技术约束的方式对系统维护是一种非常不利的因素 强制代理，强制必须通过真是角色查找到代理角色，否则不能访问。只有通过真实角色指定的代理类才可以访问，由真是角色管理代理角色。可以不知道代理的存在，但是你的所作所为还是需要代理为你提供。 代理是有个性的。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能。可以代理多个真实角色。 动态代理。动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪个对象。横切面编程（AOP）核心就是动态代理机制。？？ 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代码实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class CarBuilder &#123; //设置组装顺序 public abstract void setSequence(ArrayList&lt;String&gt; sequence); //设置完毕顺序后，就可以直接拿到这个车辆模型 public abstract CarModel getCarModel();&#125;public class BenzBuilder extends CarBuilder &#123; private BenzModel benz = new BenzModel(); //设置组装顺序 public void setSequence(ArrayList&lt;String&gt; sequence)&#123; this.benz.setSequence(sequence); &#125; //设置完毕顺序后，就可以直接拿到这个车辆模型 public CarModel getCarModel() &#123; return this.benz; &#125;&#125;public class BMWBuilder extends CarBuilder &#123; private BMWModel bmw = new BMWModel(); //设置组装顺序 public void setSequence(ArrayList&lt;String&gt; sequence)&#123; this.bmw.setSequence(sequence); &#125; //设置完毕顺序后，就可以直接拿到这个车辆模型 public CarModel getCarModel() &#123; return this.bmw; &#125;&#125;public class Director &#123; private ArrayList&lt;String&gt; sequence = new ArrayList(); private BenzBuilder benzBuilder = new BenzBuilder(); private BMWBuilder bmwBuilder = new bmwBuilder(); public BenzModel getABenzModel() &#123; this.sequence.clear(); this.sequesce.add(&quot;start&quot;); this.sequesce.add(&quot;stop&quot;); this.benzBuilder.setSequence(this.sequence); return (BenzModel)this.benzBuilder.getCarModel(); &#125; ...&#125;public class Client &#123; public static void main(String[] args) &#123; Director director = new Director(); for(int i = 0; i &lt; 1000; i++) &#123; director.getABenzModel().run(); &#125; &#125;&#125; 需求是无底洞，是无理性的 导演类指挥各事件的先后顺序 定义也叫生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 四个角色 Product产品类，实现模板方法模式 Builder抽象建造类，规划产品的组建，一般由子类实现。CarBuilder ConcreteBuilder具体建造者，实现抽象类定义好的所有方法，并且返回一个组建好的对象。BenzBuilder和BMWBuilder Director导演类，负责安排已有模块顺序，告诉Builder开始建造。 导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。导演类可以有多个 优点 封装性。使用建造者模式可以使客户端不必知道产品内部组成的细节。 建造者独立，容易扩展。BenzBuilder和BMWBuilder互相独立，对系统的扩展非常有利 便于控制细节风险。建造者独立，可对建造过程逐步细化，而不对其他模块产生任何影响 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能时 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时。补偿方法，设计阶段没有发觉。 注意建造者模式关注的是零件类型和装配工艺（顺序），与工厂方法模式最大的不同。建造者模式最主要的功能是基本方法的调用顺序安排，顺序不同产生的对象也不同；工厂方法重点是创造，创建零件是它的主要职责，组装顺序则不是它关心的。使用建造者模式的时候考虑一下模板方法模式。 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//抽象悍马模型public abstract class HummerModel &#123; public abstract void start(); public abstract void stop(); public abstract void alarm(); public abstract void engineBoom(); public void run() &#123; this.start(); this.engineBoom(); this.alarm(); this.stop(); &#125;&#125;//悍马模型H1public class HummerH1Model extends HummerModel &#123; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; &#125;//悍马模型H2public class HummerH2Model extends HummerModel &#123; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; &#125;public class Client() &#123; public static void main(String[] args) &#123; HummerModel h1 = new HummerH1Model(); h1.run(); &#125;&#125; 在软件开发过程中，如果相同的一段代码复制过两次，就需要对设计产生怀疑，架构师要明确地说明为什么相同的逻辑要出现两次或更多次 定义定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。常用设计模式 AbstractClassAbstractClass叫做抽象模板，方法分为：基本方法和模板方法，基本方法由子类实现，模板方法一般是一个具体的方法。为防止恶意修改，一般模板方法都加上final关键字，不允许被覆写。基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。 优点 封装不变部分，扩展可变部分 提取公共部分代码，便于维护 行为由父类控制，子类实现。符合开闭原则 缺点在复杂项目中，会带来代码阅读的难度，新手产生不适感 使用场景 多个子类有公有的方法，而且逻辑基本相同时 重要、、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现 重构时，模板方法模式是最常用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为 扩展——钩子方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//抽象悍马模型public abstract class HummerModel &#123; public abstract void start(); public abstract void stop(); public abstract void alarm(); public abstract void engineBoom(); final public void run() &#123; this.start(); this.engineBoom(); //this.alarm(); if(this.isAlarm()) &#123; this.alarm(); &#125; this.stop(); &#125; //默认响喇叭，钩子方法 protected boolean isAlarm() &#123; return true; &#125;&#125;//悍马模型H1public class HummerH1Model extends HummerModel &#123; private boolean alarmFlag = true; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; //设置是否响喇叭 public void setAlarm(boolean isAlarm) &#123; this.alarmFlag = isAlarm; &#125;&#125;//悍马模型H2public class HummerH2Model extends HummerModel &#123; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; //默认不响喇叭 protected boolean isAlarm() &#123; return false; &#125;&#125;public class Client() &#123; public static void main(String[] args) &#123; HummerModel h1 = new HummerH1Model(); h1.setAlarm(false); h1.run(); &#125;&#125; 外界条件改变，影响模板方法的执行，isAlarm的返回值影响了模板方法的执行结果，该方法叫做钩子方法（Hook Method） 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义为创建一组相关或相互依赖的对象提供一个接口，并且无需指定他们的具体类抽象工厂模式是工厂方法模式的升级版本，在多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式有N个产品族，在抽象工厂类中就应该有N个创建方法 优点 封装性。每个产品的实现类不是高层模块要关心的，高层模块只关心接口，抽象，不关心对象是如何创建出来的。工厂类负责关心对象是如何创建出来的，产品只要知道工厂类是谁，就能创建出一个需要的对象，省时省力。 产品族内的约束为非公开状态。 缺点最大缺点是：产品族扩展非常困难，严重违反开闭原则！ 使用场景一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式例：一个文本编辑器和一个图片处理器，都是软件实体，在操作系统不同下，虽然功能和界面相同，但代码实现不同，图片处理器也有类似情况。这就是具有了共同的约束条件：操作系统类型。于是可以使用抽象工厂模式，产生不同操作系统下的编辑器和图片处理器 注意产品族扩展非常困难，但产品等级扩展非常简单。横向扩展容易，纵向扩展困难。例：不同肤色和不同性别的人类例子中，扩展肤色困难，但是扩展性别简单，这是符合开闭原则的。在软件产品开发过程中，设计不同操作系统时，都可以考虑使用抽象工厂模式。 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 通用代码123456789101112131415161718192021222324252627282930313233343536373839404142//抽象产品类public abstract class Product&#123; //产品类共有方法 public void method1()&#123; &#125; //抽象方法 public abstract void method2();&#125;//产品1类public class Product1 extends Product &#123; public void method2()&#123;&#125;&#125;//抽象工厂类public abstract class Creator &#123; public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);&#125;//具体工厂1类public class Creator1 extends Creator &#123; public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) &#123; Product product = null; try &#123; product = (Product)Class.forName(c.getName()).newInstance(); &#125; catch (Exception e)&#123; //异常处理 &#125; return (T)product; &#125;&#125;//调用public class Client &#123; public static void main(String[] args) &#123; Creator creator = new Creator1(); Product product = creator.createProduct(Product1.class); ... &#125;&#125; 优点 优良的封装性，代码结构清晰，降低模块间的耦合性 扩展性非常优秀 屏蔽产品类 解耦框架。高层模块只需要产品的抽象类，其他的实现类都不关心，符合迪米特法则（不需要的不交流），也符合依赖倒置原则（只依赖产品类的抽象），也符合里氏替换原则（使用产品子类替换产品父类 使用场景 在所有需要生成对象的地方都可以使用 需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式 工厂方法模式可以用在异构项目中 TDD开发的框架下 扩展 缩小为简单工厂模式一个模块只需要一个工厂类，没有必要把它生产出来。该模式是工厂方法模式的弱化，因为简单，成为简单工厂模式，也叫静态工厂模式。缺点是工厂类的扩展比较困难，不符合开闭原则，但仍然是一个非常实用的设计模式 升级为多个工厂类抽象方法中已经不再需要传递相关参数了，因为每个具体的工厂都已经非常明确自己的职责：创建自己负责的产品类对象。增加扩展的难度。 替代单例模式通过反射方式创建 延迟初始化一个对象被消费完毕后，不立刻释放，工厂类保持其初始状态，等待再次被使用。 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Singleton类称为单例类通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象 优点 在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式优势明显 由于单例模式只生成一个实例，所以减少了系统的性能开销。当一个对象的产生需要比较多资源的时候，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。 单例模式可以避免对资源的多重占用，如避免对同一资源文件的同时写操作 单例模式可以在系统设置全局访问点，优化和共享资源访问。如设计一个单例类，负责所有数据表的映射处理。 缺点 一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。接口对单例模式没有任何意义，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。 单一模式对测试是不利的。在并行开发的环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。 单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。 使用场景 要求生成唯一序列号的环境 在整个项目中需要一个共享访问点或共享数据，如web页面上的计数器 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源 需要定义大量的静态常量和静态方法的环境，可以采用单例模式 两种常见写法饿汉式单例：(单例模式通用代码)1234567891011121314public class Singleton&#123; private static final Singleton singleton = new Singleton(); //限制产生多个对象 private Singleton() &#123; &#125; //通过该方法获得实例对象 public static Singleton getSingleton()&#123; return singleton; &#125; //其他方法尽量使static public static void doSomething()&#123; &#125;&#125; 懒汉式单例：（线程不安全单例）1234567891011121314151617public class Singleton&#123; private static Singleton singleton = null; //限制产生多个对象 private Singleton() &#123; &#125; //通过该方法获得实例对象 public static Singleton getSingleton()&#123; if(singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125; //其他方法尽量使static public static void doSomething()&#123; &#125;&#125; 【修改后】懒汉式单例：（线程安全单例）123456789101112131415161718192021public class Singleton&#123; private static Singleton singleton = null; //限制产生多个对象 private Singleton() &#123; &#125; //通过该方法获得实例对象 public static Singleton getSingleton()&#123; if(singleton == null) &#123; lock(singleton) &#123; if(singleton == null) &#123; //由于某些情况下，可能有延迟加载或者缓存的原因，需要多做一次判断 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; //其他方法尽量使static public static void doSomething()&#123; &#125;&#125; 注意事项 懒汉式单例高并发情况下，注意单例模式的线程同步问题解决方法，可以在getSingleton方法前加synchronized关键字，也可以在该方法内增加synchronized来实现 需要考虑对象的复制情况解决方法，单例类不实现Cloneable接口 单例模式的扩展 有上限的多例模式：如果要求一个类只能产生两三个对象 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六大设计原则(SOLID)]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99(SOLID)%2F</url>
    <content type="text"><![CDATA[单一职责原则一个接口或类只有一个原因引起变化 好处 类的复杂度降低 可读性提高 可维护性提高 变更引起的风险降低 难以实现的原因环境、工作量、人员的技术水平、硬件资源、文化差异… 里式替换原则为良好的继承定义了一个规范 规则 子类必须完全实现父类的方法。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承 子类可以有自己的个性 覆盖或实现父类的方法时输入参数可以被放大子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松 覆写或实现父类的方法时输出结果可以被缩小子类返回值必须和父类返回值同类型或是父类返回值的子类 依赖倒置原则正置是面向实现编程，倒置是面向接口编程是实现开闭原则的重要途径本质是通过抽象（接口或抽象类）使各个类或模块的是想彼此独立，不互相影响，实现模块间的松耦合。 定义 高层模块不应该依赖底层模块，两者都应该依赖其抽象抽象指接口或抽象类 抽象不应该依赖细节 细节应该依赖抽象 减少类间的耦合性，提高系统的稳定性依赖是可传递的 三种写法 构造函数传递依赖对象 Setter方法传递依赖对象 接口声明依赖对象 原则 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备 变量的表面类型尽量是接口或者是抽象类 任何类都不应该从具体类派生 尽量不要覆写基类的方法类型依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响 结合里氏替换原则使用接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化。 接口隔离原则类型 实例接口 类接口 定义 客户端不应该依赖它不需要的接口 类间的依赖关系应该建立在最小的接口上 接口尽量细化，同时接口中的方法尽量少，与单一职责的不同与单一职责的视角不同，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；接口隔离原则是要求接口的方法尽量少，提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问 保证接口的纯洁性 接口要尽量小根于接口隔离原则拆分接口时，首先必须满足单一职责原则 接口要高内聚提高接口、类、模块的处理能力，减少对外的交互。要求接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更的风险也就越少，同时也有利于降低成本。 定制服务只提供访问者的需要的方法 接口设计是有限度的接口的设计粒度越小，系统越灵活 迪米特法则——最少知识原则一个对象应该对其他对象有最少的了解 原则 只和朋友交流两个对象之间耦合就成为朋友，组合、聚合、依赖等 朋友间也是有距离的 是自己的就是自己的如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中 谨慎使用Serializable 核心观念类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。但解耦是有限度的。 开闭原则一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，底层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段 软件实体 项目或软件产品中按照一定的逻辑规则划分的模块 抽象和类 方法 变化的归纳 逻辑变化 子模块变化 可见视图变化 为什么 开闭原则对测试的影响 开闭原则可以提高复用性粒度越小，被复用的可能性越大 开闭原则可以提高可维护性 面向对象开发的要求 如何使用开闭原则 抽象约束 元数据控制模块行为 制定项目章程 封装变化 注意以下问题 开闭原则也只是一个原则 项目规章非常重要 预知变化 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 数据类型]]></title>
    <url>%2F2018%2F11%2F06%2FMysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本类型整型 TINYINT = 2^8 bit = 1字节 SMALLINT = 2 * 2^8 bit = 2字节 MEDIUMINT = 3 * 2^8 bit = 3字节 INT = INTEGER = 4 * 2^8 bit = 4字节 BIGINT = 8 * 2^8 bit = 8字节 取值范围如果加了 unsigned，则最大值翻倍 浮点型 FLOAT = 4 * 2^8 = 4字节 DOUBLE = 8 * 2^8 bit = 8字节 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2，否则为D+2。 D&lt;=M &amp;&amp; &amp;&amp; M&gt;=0 &amp;&amp; D&lt;=30, M&gt;=1 &amp;&amp; M&lt;=65。 日期和时间类型 DATE = 3字节 YYYY-MM-DD TIME = 3字节 HH:MM:SS YEAR = 1字节 YYYY DATETIME = 8字节 YYYY-MM-DD HH:MM:SS TIMESTAMP = 4字节 2147483647（类似INT） 字符串类型 CHAR = 2^8字节（定长，不区分大小写） VARCHAR = 2^16字节（变长，不区分大小写） char为定长，后面加空格，如果数据中末尾有空格会被去掉，且不区分大小写 TINYBLOB = 2^8字节 不超过 255 个字符的二进制字符串 TINYTEXT = 2^8字节 BLOB = 2^8 * 2^8 = 2^16字节 TEXT = 2^8 * 2^8 = 2^16字节 MEDIUMBLOB = 2^8 2^8 2^8 = 2^24字节 MEDIUMTEXT = 2^8 2^8 2^8 = 2^24字节 LONGBLOB = 2^8 2^8 2^8* 2^8 = 2^32字节 LONGTEXT = 2^8 2^8 2^8* 2^8 = 2^32字节 其他说明一个汉字占多少长度与编码有关：（MySQL 5.0 以上的版本） UTF－8：一个汉字（含繁体）＝3个字节 ； GBK：一个汉字＝2个字节 char 和 varchar 区别： CHAR和VARCHAR在存储或检索过程中不进行大小写转换。 char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。 char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或2个字节(n&gt;255)，多的字节用来记录长度。所以 varchar(4),存入 3 个字符将占用 4 个字节。 char 类型的字符串检索速度要比 varchar 类型的快。 varchar 和 text 区别： varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或 2 个字节(n&gt;255)，text 是实际字符数 +2 个字节。 text 类型不能有默认值。 varchar 可直接创建索引，text 创建索引指定索引前缀的长度。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。 二进制数据(_Blob) 和 text 区别： BLOB 是一个二进制大对象 _BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 _BLOB存储的数据只能整体读出。 _TEXT可以指定字符集，_BLO不用指定字符集。 ENUM 和 SET 区别： ENUM = 1字节或2字节 最多2字节（2^16） ENUM是一个字符串对象，可以插入空字符串””（索引：0）和NULL（索引：NULL），从1开始编号。其值来自表创建时在列规定中显式枚举的一列值 SET = 1字节或2字节或3字节或4字节或8字节 SET是一个字符串对象，可以有零或多个值，最多可以设置64个值，其值来自表创建时规定的允许的一列值 参考http://www.runoob.com/mysql/mysql-data-types.htmlhttps://www.cnblogs.com/Caveolae/p/7058890.html]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
