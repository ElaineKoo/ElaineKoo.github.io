<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[桥梁模式]]></title>
    <url>%2F2018%2F12%2F11%2F%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义也叫桥接模式，将抽象和实现解耦，使得两者可以独立地变化 角色 Abstraction抽象化角色 Implementor实现化角色 RefinedAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正 ConcreteImplementor具体实现化角色 使用类间的聚合关系、继承、覆写等常用功能，提供一个清晰、稳定的架构 * 通用源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public interface Implementor &#123; public void doSomething(); public void doAnything();&#125;public class ConcreteImplementor1 implements Imlementor &#123; public void doSomething() &#123; &#125; public void doAnything() &#123; &#125;&#125;public class ConcreteImplementor2 implements Imlementor &#123; public void doSomething() &#123; &#125; public void doAnything() &#123; &#125;&#125;public abstract class Abstraction &#123; //实现化角色的引用 private Implement imp; public Abstraction(Implementor _imp) &#123; this.imp = _imp; &#125; //自身的行为和属性 public void request() &#123; this.imp.doSomething(); &#125; //获得实现化角色 public Implement getImp() &#123; return imp; &#125;&#125;public class RefinedAbstraction extends Abstraction &#123; //覆写构造函数 public RefinedAbstraction(Implementor _imp) &#123; super(_imp); &#125; @Override public void request() &#123; super.request(); super.getImp().doAnything(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Implementor imp = new ConcreteImplementor1(); Abstraction = abs = new RefinedAbstraction(imp); abs.request(); &#125;&#125; 优点 抽象和实现分离，完全是为了解决继承的缺点而提出的设计模式。该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上 优秀的扩充能力。可增加实现也可增加抽象。 实现细节对客户透明 使用场景 不希望或不适合使用继承的场景 接口或抽象类不稳定的场景 重用性要求较高的场景 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>桥梁模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2F2018%2F12%2F11%2F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象 两个要求：细粒度的对象和共享对象 * 角色 Flyweight抽象享元角色 ConcreteFlyweight具体享元角色 unsharedConcreteFlyweight不可共享的享元角色 FlyweightFactory享元工厂 目的：运用共享技术，使得一些细粒度的对象可以共享，我们的设计也应该多使用细粒度的对象，便于重用或重构 * 通用源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public abstract class Flyweight &#123; //内部状态 private String intrinsic; //外部状态 protected final String Extrinsic; //要求享元角色必须接受外部状态 public Flyweight(String _Extrinsic) &#123; this.Extrinsic = _Extrinsic; &#125; //定义业务操作 public abstract void operate(); //内部状态的getter/setter public String getIntrinsic() &#123; return intrinsic; &#125; public void setIntrinsic(String intrinsic) &#123; this.intrinsic = intrinsic; &#125;&#125;public class ConcreteFlyweight1 extends Flyweight &#123; //接受外部状态 public ConcreteFlyweight1(String _Extrinsic) &#123; super(_Extrinsic); &#125; //根据外部状态进行逻辑处理 public void operate() &#123; &#125;&#125;public class ConcreteFlyweight2 extends Flyweight &#123; //接受外部状态 public ConcreteFlyweight2(String _Extrinsic) &#123; super(_Extrinsic); &#125; //根据外部状态进行逻辑处理 public void operate() &#123; &#125;&#125;public class FlyweightFactory &#123; //池容器 private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;String,Flyweight&gt;(); //享元工厂 public static Flyweight getFlyweight(String Extrinsic) &#123; //需要返回的对象 Flyweight = flyweight = null; //在池中没有该对象 if(!pool.containsKey(Extrinsic)) &#123; flyweight = pool.get(Extrinsic); &#125; else &#123; //根据外部状态创建享元对象 flyweight = new ConcreteFlyweight1(Extrinsic); //放置到池中 pool.put(Extrinsic, flyweight); &#125; return flyweight; &#125;&#125; 优点大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能 缺点提高系统复杂性，需要分离外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱 使用场景 系统中存在大量的相似对象 细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份 需要缓冲池的场景 扩展 线程安全问题 性能平衡 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>享元模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2F2018%2F12%2F05%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子 角色 AbstractExpression抽象解释器 TerminalExpression终结符表达式 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。主要是处理场景元素和数据的转换。 NonterminalExpression非终结符表达式 文法中的每条规则对应于一个非中介表达式 Context环境角色 通用源码1234567891011121314151617181920212223242526272829303132333435public abstract class Expression &#123; //每个表达式必须有一个解析任务 public abstract Object interpreter(Context ctx);&#125;public class TerminalExpression extends Expression &#123; //通常终结符表达式只有一个，但是有多个对象 public Object interpreter(Context ctx) &#123; return null; &#125;&#125;//代表一个文法规则public class NonterminalExpression extends Expression &#123; public NonterminalExpression(Expression... exoression) &#123; &#125; public Object interpreter(Context ctx) &#123; //进行文法处理 return null; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Context ctx = new Context(); Stack&lt;Expression&gt; stack = null; for(;;) &#123; //进行语法判断，并产生递归调用 &#125; Expression exp = stack.php(); exp.interpreter(ctx); &#125;&#125; 优点是一个简单语法分析工具，最显著的有点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。 缺点 类膨胀 解释其模式采用递归调用方法，难以定位问题 效率问题，大量循环和递归 使用场景 重复发生的问题可以使用解释器模式，例如：不同日志格式但数据要素相同的服务器解析 一个简单语法需要解释的场景 尽量不要在不重要的模块使用解释器模式，维护困难，可使用脚本语言代替解释器模式 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>解释器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2018%2F11%2F22%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。核心是封装。 角色 State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换 ConcreteState具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态的处理，就是本状态要做的事，以及本状态如何过渡到其他状态 Context环境角色 定义客户端需要的接口，负责具体状态的切换 通用源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public abstract class State &#123; protected Context context; public void setContext(Context _context) &#123; this.context = _context; &#125; //行为 public abstract void handle1(); public abstract void handle2();&#125;public class ConcreteState1 extends State &#123; @Override public void handle1() &#123; //本状态下必须处理的逻辑 &#125; @Override public void handle2() &#123; //设置状态 super.context.setCurrentState(Context.STATE2); //过渡到state2状态 super.context.handle2(); &#125;&#125;public class ConcreteState2 extends State &#123; @Override public void handle1() &#123; //设置状态 super.context.setCurrentState(Context.STATE1); //过渡到state2状态 super.context.handle1(); &#125; @Override public void handle2() &#123; //本状态下必须处理的逻辑 &#125;&#125;public class Context &#123; public final static State STATE1 = new ConcreteState1(); public final static State STATE2 = new ConcreteState2(); private State = CurrentState; public State getCurrentState() &#123; return CurrentState; &#125; public void setCurrentState(State currentState) &#123; this.CurrentState = currentState; //切换状态 this.CurrentState.setContext(this); &#125; public void handle1() &#123; this.CurrentState.handle1(this); &#125; public void handle2() &#123; this.CurrentState.handle2(this); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Context context = new Context(); context.setCurrentState(new ConcreteState1()); context.handel1(); context.handel2(); &#125;&#125; 把状态对象声明为静态常量环境角色（Context）具有状态抽象角色（State）定义的所有行为，具有执行使用委托方式 优点 结构清晰 避免使用过多的switch..case或者if..else，避免程序的复杂性，提高系统的可维护性 遵循设计原则 很好体现了开闭原则和单一职责原则，增加状态就增加一个子类，修改状态就修改一个子类 封装性非常好 状态变换放置到类的内部实现，外部的调用不用知道类内部如何实现状态和行为的变换 缺点子类太多，类膨胀，不好管理 使用场景 行为随状态改变而改变 条件、分支判断语句的替代者 适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2F2018%2F11%2F21%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作 角色 Visitor抽象访问者 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的 ConcreteVisitor具体访问者 影响访问者访问到一个类后该怎么干，要做什么事 Element抽象元素 接口或抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义 ConcreteElement具体元素 实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了 ObjectStructure结构对象 元素产生者，一般容纳多个不同类、不同接口的容器，如List、Set、Map等 通用源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public abstract class Element &#123; //业务逻辑 public abstract void doSomething(); //允许谁来访问 public abstract void accept(Ivisitor visitor);&#125;public classConcreteElement1 extends Element &#123; public void doSomething() &#123; &#125; public void accept(Ivisitor visitor) &#123; visitor.visit(this); &#125;&#125;public classConcreteElement2 extends Element &#123; public void doSomething() &#123; &#125; public void accept(Ivisitor visitor) &#123; visitor.visit(this); &#125;&#125;public interface IVisitor &#123; public void visit(ConcreteElement1 el1); public void visit(ConcreteElement2 el2);&#125;public class Visitor implements IVisitor &#123; public void visit(ConcreteElement1 el1) &#123; el1.doSomething(); &#125; public void visit(ConcreteElement2 el2) &#123; el2.doSomething(); &#125;&#125;//模拟public class ObjectStructure &#123; public static Element createElement() &#123; Random rand = new Random(); if(rand.nextInt(100) &gt; 50) &#123; return new ConcreteElement1(); &#125; else &#123; return new ConcreteElement2(); &#125; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; for(int i=0; i&lt;10; i++)&#123; Element el = ObjectStructure.createElement(); el.accept(new Visitor()); &#125; &#125;&#125; 优点 符合单一职责原则 优秀的扩展性 灵活性非常高 缺点 具体元素对访问者公布细节 访问者要访问一个类就必然要求这个类公布一些方法和数据，违反迪米特法则 具体元素变更比较困难 具体元素角色增加。删除。修改都是比较困难的 违背了依赖倒置原则 访问者依赖的是具体元素，而不是抽象元素，破坏了依赖倒置原则 使用场景 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作”污染”这些对象的类 业务规则要求遍历多个不同的对象，这本身也是访问者模式的出发点，迭代器模式只能访问同类或同接口的数据，而访问者模式是对迭代器模式的补充，可以遍历不同的对象，然后执行不同的操作还有一个用途，充当拦截器（Interceptor） 扩展 统计功能 多个访问者 双分派 双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型 最佳实践通过访问者模式可以容易地把一些功能进行梳理，达到最终目的——功能集中化，如一个统一的报表运算、UI展现等，我们还可以与其他模式混编建立一套自己的过滤器或者拦截器 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>访问者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义在不破坏封装性的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态。这样以后就可将该对象回复到原先保存的状态。 角色 Originator发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据 Memento备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态 Caretaker备忘录管理员角色 对备忘录进行管理、保存和提供备忘录 通用源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Originator &#123; private String state = &quot;&quot;; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Memento createMemento() &#123; return new Memento(this.state); &#125; public void restoreMemento(Memento _memento) &#123; this.setState(_memento.getState()); &#125;&#125;public class Memento &#123; private String state = &quot;&quot;; public Memento(String _state) &#123; this.state = _state; &#125; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125;&#125;public class Caretaker &#123; private Memento memento; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Originator originator = new Originator(); Caretaker caretaker = new Caretaker(); caretaker.setMemento(origunator.createMemento()); originator.restoreMemento(caretaker.getMemento()); &#125;&#125; 使用场景 需要保存和恢复数据的相关状态场景 提供一个可回滚的操作 需要监控的副本场景中 备份一个主线程中的对象，然后由分析程序来分析 数据库连接的事务管理就是用备忘录模式 注意事项 备忘录的生命期 主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理 备忘录的性能 不要频繁建立备份的场景中使用备忘录模式，原因一：控制不了备忘录建立的对象数量；原因二：大对象的建立消耗资源，系统的性能需要考虑 扩展 clone方式的备忘录 1234567891011121314151617181920212223242526272829303132333435363738public class Originator implements Cloneable &#123; private Originator backup; //内部状态 private String state = &quot;&quot;; public String getState() &#123; return state; &#125; public void setState(String state) &#123; this.state = state; &#125; public Memento createMemento() &#123; this.backup = this.clone(); &#125; public void restoreMemento() &#123; this.setState(this.backup.getState()); &#125; @Override protected Originator clone() &#123; try &#123; return (Originator)super.clone(); &#125; catch(CloneNotSupporteException e) &#123; e.printStackTace(); &#125; return null; &#125;&#125;public class Client &#123; public static void mian(String[] args) &#123; Originator = originator = new Originator(); originator.setState(&quot;初始状态..&quot;); originator.createMemento(); originator.setState(&quot;修改后的状态..&quot;); originator.restoreMemento(); &#125;&#125; 多状态的备忘录模式 多备份的备忘录 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>备忘录模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[门面模式]]></title>
    <url>%2F2018%2F11%2F21%2F%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义又叫外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。 角色 Facade门面角色 此角色知晓子系统的所有功能和责任 subsystem子系统角色 可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道门面的存在。 通用源码123456789101112131415161718192021222324252627282930313233public class ClassA &#123; public void doSomethingA() &#123; &#125;&#125;public class ClassB &#123; public void doSomethingB() &#123; &#125;&#125;public class ClassC &#123; public void doSomethingC() &#123; &#125;&#125;public class Facade &#123; private ClassA a = new ClassA(); private ClassB b = new ClassB(); private ClassC c = new ClassC(); public void methodA() &#123; this.a.doSomethingA(); &#125; public void methodB() &#123; this.a.doSomethingB(); &#125; public void methodC() &#123; this.a.doSomethingC(); &#125;&#125; 优点 减少系统的相互依赖 所有的依赖都是对门面对象的依赖，与子系统无关 提高了灵活性 依赖减少了，灵活性自然提高了 提高安全性 想让你访问子系统的哪些业务就开通哪些逻辑 缺点最大的缺点是不符合开闭原则，如果要修改，唯一能做的就是修改门面角色的代码，风险相当大 使用场景 为一个复杂的模块或子系统提供一个供外界访问的接口 子系统相对独立，外界对子系统的访问只要黑箱操作即可 预防低水平人员带来的风险扩散 注意事项 一个子系统可以有多个门面，(1)门面可拆分 (2)子系统可以提供不同的访问路径，新增一个引用原有门面的门面 门面不参与子系统内的业务逻辑，门面对象只是提供一个访问子系统的一个路径而已，不应该参与具体的业务逻辑，否则会产生一个倒依赖的问题：子系统必须依赖门面才能被访问，不仅违反了单一职责原则，同事也破坏了系统的封装性123456789101112131415161718192021222324public class Context &#123; private ClassA a = new ClassA(); private ClassC c = new ClassC(); public void complexMethod() &#123; this.a.doSomethingA(); this.c.doSomethingC(); &#125;&#125;public class Facade &#123; private ClassA a = new ClassA(); private ClassB b = new ClassB(); private Context context = new Context(); public void methodA() &#123; this.a.doSomethingA(); &#125; public void methodB() &#123; this.a.doSomethingB(); &#125; public void methodC() &#123; this.context.complexMethod(); &#125;&#125; 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>门面模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F11%2F21%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义也叫发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 角色 Subject被观察者 Observer观察者 ConcreteSubject具体的被观察者 ConcreteObserver具体的观察者 通用源码123456789101112131415161718192021222324252627282930313233343536373839public abstract class Subject &#123; private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;(); public void addObserver(Observer o) &#123; this.obsVector.add(o); &#125; public void delObserver(Observer o) &#123; this.obsVector.remove(o); &#125; public void notifyObservers() &#123; for(Observer o:this.obsVector) &#123; o.update(); &#125; &#125;&#125;public class ConcreteSubject extends Subject &#123; public void doSomething() &#123; super.notifyObservers(); &#125;&#125;public interface Observer &#123; public void update();&#125;public class ConcreteObserver implements Observer &#123; public void update() &#123; System.out.println(&quot;接收到信息，并进行处理！&quot;); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; ConcreteSubject subject = new ConcreteSubject(); Observer obs = new ConcreteObserver(); subject.addObserver(obs); subject.doSomething(); &#125;&#125; 优点 观察者和被观察者之间是抽象耦合 建立一套触发机制 缺点顺序执行，一个观察者卡壳，影响整体，一般考虑采用异步方式 使用场景 关联行为场景 事件多级触发场景 跨系统的消息交换场景，如消息队列处理机制 注意事项 广播链问题 一个观察者模式中最多出现一个对象既是观察者也是被观察者，消息最多转发一次。 异步处理问题 最佳实践 文件系统 猫鼠游戏 ATM取钱 广播收音机 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2F2018%2F11%2F21%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义也叫合成模式、整体模式。将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。 角色 Component抽象构件角色 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性 Leaf叶子构件 叶子对象 Composite树枝构件 树枝对象 通用源码12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class Component &#123; public void doSomething() &#123; &#125;&#125;public class Composite extends Component &#123; private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;(); public void add(Component component) &#123; this.componentArrayList.add(component); &#125; public void remove(Component component) &#123; this.componentArrayList.remove(component); &#125; public ArrayList&lt;Component&gt; getChildren() &#123; return this.componentArrayList; &#125;&#125;public class Leaf extends Component &#123; //可以覆写 public void doSomething() &#123;&#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Composite root new Composite(); root.doSomething(); Composite branch = new Composite(); Leaf leaf = new Leaf(); root.add(branch); branch.add(leaf); &#125; public static void display(Composite root) &#123; for(Component c:root.getChildren()) &#123; if(c instanceof Leaf) &#123; c.doSomething(); &#125; else &#123; display((Composite)c); &#125; &#125; &#125;&#125; 优点 高层模块调用简单 节点自由增加 缺点与依赖倒置原则冲突 使用场景 维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。 从一个整体中能够独立出部分模块或功能的场景。 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>组合模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2018%2F11%2F20%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义它提供一种方法访问一个容器对象中的各个元素，而不需要暴露该对象的内部细节。没落的模式，基本么有人会单独写一个迭代器。 角色 Iterator抽象迭代器 first，next，isDone ConcreteIterator具体迭代器 Aggregate抽象容器 容器角色负责提供创建具体迭代器角色的接口 ConcreteAggregate具体容器 实现容器接口定义的方法，创建出容纳迭代器的对象 通用源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public interface Iterator &#123; public Object next(); public boolean hasNext(); public boolean remove();&#125;public ConcreteInterator implements Ieterator &#123; private Vector vector = new Vector(); public int cursor = 0; @SuppressWarnings(&quot;unchecked&quot;) public ConcreteIeterator(Vector _vector) &#123; this.vector = _vector; &#125; public boolean hasNext() &#123; if(this.cursor == this.vector.size()) &#123; return false; &#125; else &#123; return true; &#125; &#125; public Object next() &#123; Object result = null; if(this.hasNext()) &#123; result = this.vector.get(this.cursor++); &#125; else &#123; result = null; &#125; return result; &#125; public boolean remove() &#123; this.vector.remove(this.cursor); return true; &#125;&#125;public interface Aggregate &#123; public void add(Object object); public void remove(Object object); public Iterator iterator();&#125;public class ConcreteAggregate implements Aggregate &#123; private Vector vector = new Vector(); public void add(Object object) &#123; this.vector.add(object); &#125; public Iterator iterator() &#123; return new ConcreteIterator(this.vector); &#125; public void remove(Object object) &#123; this.remove(object); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Aggregate agg = new ConcreteAggregate(); agg.add(&quot;abc&quot;); agg.add(&quot;aaa&quot;); agg.add(&quot;1234&quot;); Iterator iterator = agg.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; &#125;&#125; 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F11%2F20%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义又叫变压器模式、包装模式，将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作 三个角色 Target目标角色 Adaptee源角色 Adapter适配器角色 通用源码123456789101112131415161718192021222324252627282930313233public interface Target &#123; //目标角色有自己的方法 public void request();&#125;public vlass ConcreteTarget implements Target &#123; pubilc void request() &#123; System.out.println(&quot;xxxx&quot;); &#125;&#125;public class Adaptee &#123; public void doSomething() &#123; System.out.println(&quot;zzzzz&quot;); &#125;&#125;public vlass Adapter extends Adaptee implements Target &#123; public void request() &#123; super.doSomething(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; //原 Target target = new ConcreteTarget(); target.request(); //适配器 Target target2 = new Adapter(); target2.request(); &#125;&#125; 优点 适配器模式可以让两个没有任何关系的类在一起运行 增加了类的透明性 提高类的复用度 灵活性非常好 使用场景你有动机修改一个已经投产中的接口时 注意事项不要在开发阶段考虑，解决的是正在服役中的项目问题项目一定要遵守依赖倒置原则和里氏替换原则 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2018%2F11%2F20%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义也叫做政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。 角色 Context封装角色 上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化 Strategy抽象策略角色 策略算法的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性 ConcreteStrategy具体策略角色 实现抽象策略 通用源码12345678910111213141516171819202122232425262728293031323334public interface Strategy &#123; public void doSomething();&#125;public class ConcreteStrategy1 implements Strategy &#123; public void doSomething() &#123; // &#125;&#125;public class ConcreteStrategy2 implements Strategy &#123; public void doSomething() &#123; // &#125;&#125;//重点：封装角色，借用了代理模式的思路，区别在于策略模式的封装角色和被封装的策略类不用是同一个接口，如果是同一个接口就成为代理模式public class Context &#123; private Strategy strategy = null; public Context(Strategy _strategy) &#123; this.strategy = _strategy; &#125; public void doAnything() &#123; this.strategy.doSomething(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Strategy strategy = new ConcreteStrategy1(); Context context = new Context(strategy); context.doAnything(); &#125;&#125; 优点 算法可以自由切换 避免使用多重条件判断 扩展性良好 缺点 策略类数量增多 复用可能性小，类数量增多 所有策略类都要对外暴露 违反迪米特法则，可使用其他模式修正缺陷，如工厂方法模式、代理模式或享元模式 使用场景 多个类只有在算法或行为上稍有不同的场景 算法需要自由切换的场景 需要屏蔽算法规则的场景 注意事项如果一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀或对外暴露的问题。 扩展 策略枚举 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。 四个角色 Component抽象构件 定义最核心、最原始的对象 ConcreteComponent具体构件 最核心、最原始的对象的实现 Decorator装饰角色 一般是一个抽象类，实现接口或者抽象方法，里面不一定有抽象的方法，属性里必然有一个private变量指向Component抽象构件 具体装饰角色 通用代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public abstract class Component &#123; public abstract void operate();&#125;public class ConcreteComponent extends Component &#123; @Override public void operate() &#123; System.out.println(&apos;do Something&apos;); &#125;&#125;public abstract class Decorator extends Component &#123; private Component component = null; public Decorator(Component _component) &#123; this.component = _component; &#125; @Override public void operate() &#123; this.component.operate(); &#125;&#125;public class ConcreteDecorator1 extends Decorator &#123; publicConcreteDecorator1(Component _component) &#123; super(_component); &#125; private void method1() &#123; System.out,println(&apos;method 1 修饰&apos;); &#125; public void Operate() &#123; this.method1(); super.operate(); &#125;&#125;public class ConcreteDecorator2 extends Decorator &#123; publicConcreteDecorator1(Component _component) &#123; super(_component); &#125; private void method2() &#123; System.out,println(&apos;method 1 修饰&apos;); &#125; public void Operate() &#123; super.operate(); this.method2(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Component component = new ConcreteComponent(); component = new ConcreteDecorator1(component); component = new ConcreteDecorator2(component); component.operator(); &#125;&#125; 优点 装饰类和被装饰类可以独立发展，不会互相耦合。 装饰模式是继承关系的一个替代方案。 装饰模式可以动态扩展一个实现类的功能。 缺点 多层的装饰是比较复杂的，尽量减少装饰的数量，以降低系统的复杂度 使用场景 需要扩展一个类的功能，或给一个类增加附加功能 需要动态地给一个对象增加功能，这些功能可以再动态地撤销 需要为一批的兄弟类进行改装或加装功能，首选装饰模式 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>装饰模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式]]></title>
    <url>%2F2018%2F11%2F19%2F%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。 实际应用中，一般会有一个封装类对责任模式进行封装，替代Client类，直接返回链中第一个处理者，具体链的设置不需要高层次模块关系 * 优点将请求和处理分开，解耦，提高系统灵活性 缺点 性能问题，每个请求都是从链头遍历到链尾 调试不方便，类似递归 链中节点数量控制，避免超长链，一般做法是在Handler中这是一个最大节点数量，太长则不允许链建立 * 示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public abstract class AbstractLogger &#123; public static int INFO = 1; public static int DEBUG = 2; public static int ERROR = 3; protected int level; //责任链中的下一个元素 protected AbstractLogger nextLogger; public void setNextLogger(AbstractLogger nextLogger)&#123; this.nextLogger = nextLogger; &#125; public void logMessage(int level, String message)&#123; if(this.level &lt;= level)&#123; write(message); &#125; if(nextLogger !=null)&#123; nextLogger.logMessage(level, message); &#125; &#125; abstract protected void write(String message); &#125;public class ConsoleLogger extends AbstractLogger &#123; public ConsoleLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println(&quot;Standard Console::Logger: &quot; + message); &#125;&#125;public class ErrorLogger extends AbstractLogger &#123; public ErrorLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println(&quot;Error Console::Logger: &quot; + message); &#125;&#125;public class FileLogger extends AbstractLogger &#123; public FileLogger(int level)&#123; this.level = level; &#125; @Override protected void write(String message) &#123; System.out.println(&quot;File::Logger: &quot; + message); &#125;&#125;public class ChainPatternDemo &#123; private static AbstractLogger getChainOfLoggers()&#123; AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR); AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG); AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO); errorLogger.setNextLogger(fileLogger); fileLogger.setNextLogger(consoleLogger); return errorLogger; &#125; public static void main(String[] args) &#123; AbstractLogger loggerChain = getChainOfLoggers(); loggerChain.logMessage(AbstractLogger.INFO, &quot;This is an information.&quot;); loggerChain.logMessage(AbstractLogger.DEBUG, &quot;This is an debug level information.&quot;); loggerChain.logMessage(AbstractLogger.ERROR, &quot;This is an error information.&quot;); &#125;&#125; 执行结果123456Standard Console::Logger: This is an information.File::Logger: This is an debug level information.Standard Console::Logger: This is an debug level information.Error Console::Logger: This is an error information.File::Logger: This is an error information.Standard Console::Logger: This is an error information. 参考《设计模式之禅》http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>责任链模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。 角色 Receive接收者角色 Command命令角色 Invoker调用者角色 封装性好，把请求方（Invoker）和执行方（Receiver）分开 * 通用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public abstract class Receiver &#123; //抽象接收者，定义每个接收者都必须完成的业务 public abstract void doSomething();&#125;public class ConcreteReceiver1 extends Receiver &#123; //每个接收者都必须处理一定的业务逻辑 public void doSomthing()&#123; &#125;&#125;public class ConcreteReceiver2 extends Receiver &#123; //每个接收者都必须处理一定的业务逻辑 public void doSomthing()&#123; &#125;&#125;public abstract class Command &#123; //每个命令都有一个执行命令的方法 public abstract void execute();&#125;public class ConcreteCommand1 extends Command &#123; //对哪个Receiver类进行命令处理 private Receiver receiver; public ConcreteCommand1(Receiver _receiver) &#123; this.receiver = _receiver; &#125; public void execute() &#123; this.receiver.doSomething(); &#125;&#125;public class ConcreteCommand2 extends Command &#123; //对哪个Receiver类进行命令处理 private Receiver receiver; public ConcreteCommand2(Receiver _receiver) &#123; this.receiver = _receiver; &#125; public void execute() &#123; this.receiver.doSomething(); &#125;&#125;public class Invoker &#123; private Command command; //接受命令 public void setCommand(Command _command) &#123; this.command = _command; &#125; public void action() &#123; this.command.execute(); &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; Invoker invoker = new Invoker(); Receiver receiver = new ConcreteReceiver1(); Command command = new ConcreteCommand1(receiver); invoker.setCommand(command); invoker.action(); &#125;&#125; 优点 类间解耦 调用者角色与接收者角色之间没有任何依赖关系，不需要了解到底是哪个接收者执行 可扩展性 Command子类非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合 命令模式结合其他模式会更优秀 可以结合责任链模式，实现命令族解析任务；结合模板方法模式，减少Command子类的膨胀问题 缺点如果有N个命令，Command的子类就是N个，类膨胀非常大 场景只要你任务是命令的地方，例如GUI开发中的一个按钮点击；模拟DOS命令；触发-反馈机制的处理等 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2018%2F11%2F19%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义也叫调停者模式用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 组成 Mediator 抽象中介者角色定义统一的接口，用于各同事角色之间的通信 Concrete Mediator 具体中介者角色通过协调各同事角色实现协作行为，必须依赖于各个同事角色 Colleague 同事角色每个同事角色都知道中介者角色，而且与其他的同事角色通信时，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。 通用源代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class Mediator &#123; //定义同事类 protected ConcreteColleague1 c1; protected ConcreteColleague2 c2; //注入同事类 public ConcreteColleague1 getC1() &#123; return c1; &#125; public void setC1(ConcreteColleague1 c1) &#123; this.c1 = c1; &#125; public ConcreteColleague2 getC2() &#123; return c2; &#125; public void setC2(ConcreteColleague2 c2) &#123; this.c2 = c2; &#125; public abstract void doSomething1(); public abstract void doSomething2();&#125;public class ConcreteMediator extends Mediator &#123; @Override public void doSomething1() &#123; super.c1.selfMethod1(); super.c2.selfMethod2(); &#125; public void doSomething2() &#123; super.c1.selfMethod1(); super.c2.selfMethod2(); &#125;&#125;public abstract class Colleague &#123; protected Mediator mediator; public Colleague(Mediator _mediator) &#123; this.mediator = _mediator; &#125;&#125;public class ConcreteColleague1 extends Colleague &#123; public ConcreteColleague1(Mediator _mediator) &#123; super(_mediator); &#125; //自有方法 public void selfMethod1() &#123; //处理自己的业务逻辑 &#125; //依赖方法 public void depMethod1() &#123; //处理自己的业务逻辑 //自己不能处理的业务逻辑，委托给中介者处理 super.mediator.doSomething1(); &#125;&#125;public class ConcreteColleague2 extends Colleague &#123; public ConcreteColleague2(Mediator _mediator) &#123; super(_mediator); &#125; //自有方法 public void selfMethod2() &#123; //处理自己的业务逻辑 &#125; //依赖方法 public void depMethod2() &#123; //处理自己的业务逻辑 //自己不能处理的业务逻辑，委托给中介者处理 super.mediator.doSomething2(); &#125;&#125; 优点减少类间的依赖，把原有的一对多的依赖变成一对一依赖同事类只依赖中介者，减少了依赖，降低了类间的耦合 缺点中介者会膨胀得很快，而且逻辑复杂，同事类越多，中介者的逻辑越复杂 应用 机场调度中心 MVC框架 C就是中介者，隔开M和V，减少M和V的依赖关系。 媒体网关 中介服务 最佳实践 N个对象之间产生了相互的依赖关系（N&gt;2） 多个对象有依赖关系，但依赖的行为尚不确定或者有发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散 产品开发 提升产品的性能和扩展性 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记 laravel chunk 遇到的坑]]></title>
    <url>%2F2018%2F11%2F15%2F%E8%AE%B0laravel-chunk%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：12345Flight::chunk(100, function ($flights) &#123; foreach ($flights as $flight) &#123; //对每条数据做一些处理 &#125;&#125;); 如果’flights’表中有1000条数据，将拆成10次查询：1234567891011121314151617181920select * from `flights` limit 100 offset 0//对每条数据做一些处理select * from `flights` limit 100 offset 100//对每条数据做一些处理select * from `flights` limit 100 offset 200//对每条数据做一些处理select * from `flights` limit 100 offset 300//对每条数据做一些处理select * from `flights` limit 100 offset 400//对每条数据做一些处理select * from `flights` limit 100 offset 500//对每条数据做一些处理select * from `flights` limit 100 offset 600//对每条数据做一些处理select * from `flights` limit 100 offset 700//对每条数据做一些处理select * from `flights` limit 100 offset 800//对每条数据做一些处理select * from `flights` limit 100 offset 900//对每条数据做一些处理 问题 id xx yy 1 0 0 2 0 0 3 0 0 .. .. .. .. .. .. 1000 0 0 如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。1234567Flight::where(&apos;xx&apos;, 0)-&gt;chunk(100, function ($flights) &#123; foreach ($flights as $flight) &#123; //$res = 通过flight与关联表的关系得出来值，这也是我们为什么需要通过这种方法更新 $flight-&gt;yy = $res; $flight-&gt;save(); &#125;&#125;); 更新所有xx=0的yy。 12345678910111213141516171819202122232425262728293031323334353637383940select * from `flights` where `xx` = 0 limit 100 offset 0update `flights` set `yy` = 152 where `id` = 1 update `flights` set `yy` = 12 where `id` = 2 update `flights` set `yy` = 123 where `id` = 3 ...update `flights` set `yy` = 52 where `id` = 99update `flights` set `yy` = 512 where `id` = 100select * from `flights` where `xx` = 0 limit 100 offset 100update `flights` set `yy` = 12 where `id` = 101 update `flights` set `yy` = 112 where `id` =102 update `flights` set `yy` = 13 where `id` = 103 ...update `flights` set `yy` = 5 where `id` = 199update `flights` set `yy` = 512 where `id` = 200select * from `flights` where `xx` = 0 limit 100 offset 200update `flights` set `yy` = 12 where `id` = 201 update `flights` set `yy` = 112 where `id` =202 update `flights` set `yy` = 13 where `id` = 203 ...update `flights` set `yy` = 5 where `id` = 299update `flights` set `yy` = 512 where `id` = 300select * from `flights` where `xx` = 0 limit 100 offset 300...select * from `flights` where `xx` = 0 limit 100 offset 400...select * from `flights` where `xx` = 0 limit 100 offset 500...select * from `flights` where `xx` = 0 limit 100 offset 600...select * from `flights` where `xx` = 0 limit 100 offset 700...select * from `flights` where `xx` = 0 limit 100 offset 800...select * from `flights` where `xx` = 0 limit 100 offset 900update `flights` set `yy` = 12 where `id` = 901 update `flights` set `yy` = 112 where `id` =902 update `flights` set `yy` = 13 where `id` = 903 ...update `flights` set `yy` = 5 where `id` = 999update `flights` set `yy` = 512 where `id` = 1000 如果我们按yy进行筛选，更新yy字段，这样就会出问题。1234567Flight::where(&apos;yy&apos;, 0)-&gt;chunk(100, function ($flights) &#123; foreach ($flights as $flight) &#123; //$res = 通过flight与关联表的关系得出来值(反正不是0)，这也是我们为什么需要通过这种方法更新 $flight-&gt;yy = $res; $flight-&gt;save(); &#125;&#125;); 更新所有yy=0的yy。 1234567891011121314151617181920212223242526272829303132333435select * from `flights` where `yy` = 0 limit 100 offset 0update `flights` set `yy` = 152 where `id` = 1 update `flights` set `yy` = 12 where `id` = 2 update `flights` set `yy` = 123 where `id` = 3 ...update `flights` set `yy` = 52 where `id` = 99update `flights` set `yy` = 512 where `id` = 100select * from `flights` where `yy` = 0 limit 100 offset 100update `flights` set `yy` = 12 where `id` = 201 update `flights` set `yy` = 112 where `id` =202 update `flights` set `yy` = 13 where `id` = 203 ...update `flights` set `yy` = 5 where `id` = 299update `flights` set `yy` = 512 where `id` = 300select * from `flights` where `yy` = 0 limit 100 offset 200update `flights` set `yy` = 12 where `id` = 401 update `flights` set `yy` = 112 where `id` =402 update `flights` set `yy` = 13 where `id` = 403 ...update `flights` set `yy` = 5 where `id` = 499update `flights` set `yy` = 512 where `id` = 400select * from `flights` where `yy` = 0 limit 100 offset 300update `flights` set `yy` = 12 where `id` = 601 update `flights` set `yy` = 112 where `id` =602 update `flights` set `yy` = 13 where `id` = 603 ...update `flights` set `yy` = 5 where `id` = 699update `flights` set `yy` = 512 where `id` = 600select * from `flights` where `yy` = 0 limit 100 offset 400update `flights` set `yy` = 12 where `id` = 801 update `flights` set `yy` = 112 where `id` =802 update `flights` set `yy` = 13 where `id` = 803 ...update `flights` set `yy` = 5 where `id` = 899update `flights` set `yy` = 512 where `id` = 800 很困惑，为什么表中还是有yy=0的数据。在执行 select * from flights where yy = 0 limit 100 offset 100 之前，id=1~100的数据yy已经不等于0了，所以在执行1select * from `flights` where `yy` = 0 limit 100 offset 100 的时候，搜索出的是id=201~300的数据，而id=101~200的数据，只有在再次搜索1select * from `flights` where `yy` = 0 limit 100 offset 0 的时候才会出现。 结论所以，我们要避免使用 chunk 的时候，更改和过滤条件的字段的值。]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式简单程度仅次于单例模式和迭代器模式，使用广泛用原型实例指定创建对象的种类，并且通过拷贝这些原型创建的对象核心就是clone方法，通过该方法进行对象的拷贝，JAVA提供了Cloneable接口，标示这个对象是可拷贝的。覆写clone方法。 优点 性能优良。原型模式是内存二进制流的拷贝。 逃避构造函数的约束。不执行构造函数，优点和缺点都是减少了约束。 使用场景 资源优化场景。类初始化需要消化非常多的资源，包括数据和硬件资源等。 性能和安全要求的场景。通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时。 原型模式很少单独出现，一般和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者 注意 构造函数不会被执行 浅拷贝和深拷贝使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变类型 clone与final关键字冲突 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义也叫委托模式，为其他对象提供一种代理，以控制对这个对象的访问。使用率非常高。提供非常好的访问控制。 角色 Subject抽象主题角色。可以是抽象类也可以是接口 RealSubject具体主题角色。也称为被委托角色或被代理角色，业务逻辑的具体执行者 Proxy代理主题角色。也称为委托类、代理类 代码123456789101112131415161718192021222324252627282930public interface Subject &#123; public void request();&#125;public class RealSubject implements Subject &#123; public void request() &#123; //业务逻辑 &#125;&#125;public class Proxy implements Subject &#123; private Subject subject = null; public Proxy() &#123; this.subject = new Proxy(); &#125; public Proxy(Subject subject) &#123; this.subject = subject; &#125; public void request() &#123; this.before(); this.subject.request(); this.after(); &#125; public void before() &#123;&#125; public void after() &#123;&#125;&#125; 优点 职责清晰。真实角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰 高扩展性。具体主题角色随时发生变化，不管怎么变化，只要实现了接口，那代理类完全就可以在不做任何修改的情况下使用。 使用场景Spring AOP 扩展 普通代理，要求客户端只能访问代理角色，而不能访问真实角色。普通代理模式的约束问题，尽量通过团队内的变成规范类约束，因为每一个主题类是可被重用的和可维护的，实用技术约束的方式对系统维护是一种非常不利的因素 强制代理，强制必须通过真是角色查找到代理角色，否则不能访问。只有通过真实角色指定的代理类才可以访问，由真是角色管理代理角色。可以不知道代理的存在，但是你的所作所为还是需要代理为你提供。 代理是有个性的。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能。可以代理多个真实角色。 动态代理。动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪个对象。横切面编程（AOP）核心就是动态代理机制。？？ 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代码实例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public abstract class CarBuilder &#123; //设置组装顺序 public abstract void setSequence(ArrayList&lt;String&gt; sequence); //设置完毕顺序后，就可以直接拿到这个车辆模型 public abstract CarModel getCarModel();&#125;public class BenzBuilder extends CarBuilder &#123; private BenzModel benz = new BenzModel(); //设置组装顺序 public void setSequence(ArrayList&lt;String&gt; sequence)&#123; this.benz.setSequence(sequence); &#125; //设置完毕顺序后，就可以直接拿到这个车辆模型 public CarModel getCarModel() &#123; return this.benz; &#125;&#125;public class BMWBuilder extends CarBuilder &#123; private BMWModel bmw = new BMWModel(); //设置组装顺序 public void setSequence(ArrayList&lt;String&gt; sequence)&#123; this.bmw.setSequence(sequence); &#125; //设置完毕顺序后，就可以直接拿到这个车辆模型 public CarModel getCarModel() &#123; return this.bmw; &#125;&#125;public class Director &#123; private ArrayList&lt;String&gt; sequence = new ArrayList(); private BenzBuilder benzBuilder = new BenzBuilder(); private BMWBuilder bmwBuilder = new bmwBuilder(); public BenzModel getABenzModel() &#123; this.sequence.clear(); this.sequesce.add(&quot;start&quot;); this.sequesce.add(&quot;stop&quot;); this.benzBuilder.setSequence(this.sequence); return (BenzModel)this.benzBuilder.getCarModel(); &#125; ...&#125;public class Client &#123; public static void main(String[] args) &#123; Director director = new Director(); for(int i = 0; i &lt; 1000; i++) &#123; director.getABenzModel().run(); &#125; &#125;&#125; 需求是无底洞，是无理性的 导演类指挥各事件的先后顺序 定义也叫生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 四个角色 Product产品类，实现模板方法模式 Builder抽象建造类，规划产品的组建，一般由子类实现。CarBuilder ConcreteBuilder具体建造者，实现抽象类定义好的所有方法，并且返回一个组建好的对象。BenzBuilder和BMWBuilder Director导演类，负责安排已有模块顺序，告诉Builder开始建造。 导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。导演类可以有多个 优点 封装性。使用建造者模式可以使客户端不必知道产品内部组成的细节。 建造者独立，容易扩展。BenzBuilder和BMWBuilder互相独立，对系统的扩展非常有利 便于控制细节风险。建造者独立，可对建造过程逐步细化，而不对其他模块产生任何影响 使用场景 相同的方法，不同的执行顺序，产生不同的事件结果时 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能时 在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时。补偿方法，设计阶段没有发觉。 注意建造者模式关注的是零件类型和装配工艺（顺序），与工厂方法模式最大的不同。建造者模式最主要的功能是基本方法的调用顺序安排，顺序不同产生的对象也不同；工厂方法重点是创造，创建零件是它的主要职责，组装顺序则不是它关心的。使用建造者模式的时候考虑一下模板方法模式。 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//抽象悍马模型public abstract class HummerModel &#123; public abstract void start(); public abstract void stop(); public abstract void alarm(); public abstract void engineBoom(); public void run() &#123; this.start(); this.engineBoom(); this.alarm(); this.stop(); &#125;&#125;//悍马模型H1public class HummerH1Model extends HummerModel &#123; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; &#125;//悍马模型H2public class HummerH2Model extends HummerModel &#123; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; &#125;public class Client() &#123; public static void main(String[] args) &#123; HummerModel h1 = new HummerH1Model(); h1.run(); &#125;&#125; 在软件开发过程中，如果相同的一段代码复制过两次，就需要对设计产生怀疑，架构师要明确地说明为什么相同的逻辑要出现两次或更多次 定义定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。常用设计模式 AbstractClassAbstractClass叫做抽象模板，方法分为：基本方法和模板方法，基本方法由子类实现，模板方法一般是一个具体的方法。为防止恶意修改，一般模板方法都加上final关键字，不允许被覆写。基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。 优点 封装不变部分，扩展可变部分 提取公共部分代码，便于维护 行为由父类控制，子类实现。符合开闭原则 缺点在复杂项目中，会带来代码阅读的难度，新手产生不适感 使用场景 多个子类有公有的方法，而且逻辑基本相同时 重要、、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现 重构时，模板方法模式是最常用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为 扩展——钩子方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//抽象悍马模型public abstract class HummerModel &#123; public abstract void start(); public abstract void stop(); public abstract void alarm(); public abstract void engineBoom(); final public void run() &#123; this.start(); this.engineBoom(); //this.alarm(); if(this.isAlarm()) &#123; this.alarm(); &#125; this.stop(); &#125; //默认响喇叭，钩子方法 protected boolean isAlarm() &#123; return true; &#125;&#125;//悍马模型H1public class HummerH1Model extends HummerModel &#123; private boolean alarmFlag = true; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; //设置是否响喇叭 public void setAlarm(boolean isAlarm) &#123; this.alarmFlag = isAlarm; &#125;&#125;//悍马模型H2public class HummerH2Model extends HummerModel &#123; public void alarm() &#123; ... &#125; public void engineBoom() &#123; ... &#125; public void start() &#123; ... &#125; public void stop() &#123; ... &#125; //默认不响喇叭 protected boolean isAlarm() &#123; return false; &#125;&#125;public class Client() &#123; public static void main(String[] args) &#123; HummerModel h1 = new HummerH1Model(); h1.setAlarm(false); h1.run(); &#125;&#125; 外界条件改变，影响模板方法的执行，isAlarm的返回值影响了模板方法的执行结果，该方法叫做钩子方法（Hook Method） 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义为创建一组相关或相互依赖的对象提供一个接口，并且无需指定他们的具体类抽象工厂模式是工厂方法模式的升级版本，在多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式有N个产品族，在抽象工厂类中就应该有N个创建方法 优点 封装性。每个产品的实现类不是高层模块要关心的，高层模块只关心接口，抽象，不关心对象是如何创建出来的。工厂类负责关心对象是如何创建出来的，产品只要知道工厂类是谁，就能创建出一个需要的对象，省时省力。 产品族内的约束为非公开状态。 缺点最大缺点是：产品族扩展非常困难，严重违反开闭原则！ 使用场景一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式例：一个文本编辑器和一个图片处理器，都是软件实体，在操作系统不同下，虽然功能和界面相同，但代码实现不同，图片处理器也有类似情况。这就是具有了共同的约束条件：操作系统类型。于是可以使用抽象工厂模式，产生不同操作系统下的编辑器和图片处理器 注意产品族扩展非常困难，但产品等级扩展非常简单。横向扩展容易，纵向扩展困难。例：不同肤色和不同性别的人类例子中，扩展肤色困难，但是扩展性别简单，这是符合开闭原则的。在软件产品开发过程中，设计不同操作系统时，都可以考虑使用抽象工厂模式。 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2018%2F11%2F13%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[定义定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。 通用代码123456789101112131415161718192021222324252627282930313233343536373839404142//抽象产品类public abstract class Product&#123; //产品类共有方法 public void method1()&#123; &#125; //抽象方法 public abstract void method2();&#125;//产品1类public class Product1 extends Product &#123; public void method2()&#123;&#125;&#125;//抽象工厂类public abstract class Creator &#123; public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);&#125;//具体工厂1类public class Creator1 extends Creator &#123; public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) &#123; Product product = null; try &#123; product = (Product)Class.forName(c.getName()).newInstance(); &#125; catch (Exception e)&#123; //异常处理 &#125; return (T)product; &#125;&#125;//调用public class Client &#123; public static void main(String[] args) &#123; Creator creator = new Creator1(); Product product = creator.createProduct(Product1.class); ... &#125;&#125; 优点 优良的封装性，代码结构清晰，降低模块间的耦合性 扩展性非常优秀 屏蔽产品类 解耦框架。高层模块只需要产品的抽象类，其他的实现类都不关心，符合迪米特法则（不需要的不交流），也符合依赖倒置原则（只依赖产品类的抽象），也符合里氏替换原则（使用产品子类替换产品父类 使用场景 在所有需要生成对象的地方都可以使用 需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式 工厂方法模式可以用在异构项目中 TDD开发的框架下 扩展 缩小为简单工厂模式一个模块只需要一个工厂类，没有必要把它生产出来。该模式是工厂方法模式的弱化，因为简单，成为简单工厂模式，也叫静态工厂模式。缺点是工厂类的扩展比较困难，不符合开闭原则，但仍然是一个非常实用的设计模式 升级为多个工厂类抽象方法中已经不再需要传递相关参数了，因为每个具体的工厂都已经非常明确自己的职责：创建自己负责的产品类对象。增加扩展的难度。 替代单例模式通过反射方式创建 延迟初始化一个对象被消费完毕后，不立刻释放，工厂类保持其初始状态，等待再次被使用。 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Singleton类称为单例类通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象 优点 在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式优势明显 由于单例模式只生成一个实例，所以减少了系统的性能开销。当一个对象的产生需要比较多资源的时候，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决。 单例模式可以避免对资源的多重占用，如避免对同一资源文件的同时写操作 单例模式可以在系统设置全局访问点，优化和共享资源访问。如设计一个单例类，负责所有数据表的映射处理。 缺点 一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。接口对单例模式没有任何意义，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。 单一模式对测试是不利的。在并行开发的环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。 单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。 使用场景 要求生成唯一序列号的环境 在整个项目中需要一个共享访问点或共享数据，如web页面上的计数器 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源 需要定义大量的静态常量和静态方法的环境，可以采用单例模式 两种常见写法饿汉式单例：(单例模式通用代码)1234567891011121314public class Singleton&#123; private static final Singleton singleton = new Singleton(); //限制产生多个对象 private Singleton() &#123; &#125; //通过该方法获得实例对象 public static Singleton getSingleton()&#123; return singleton; &#125; //其他方法尽量使static public static void doSomething()&#123; &#125;&#125; 懒汉式单例：（线程不安全单例）1234567891011121314151617public class Singleton&#123; private static Singleton singleton = null; //限制产生多个对象 private Singleton() &#123; &#125; //通过该方法获得实例对象 public static Singleton getSingleton()&#123; if(singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125; //其他方法尽量使static public static void doSomething()&#123; &#125;&#125; 【修改后】懒汉式单例：（线程安全单例）123456789101112131415161718192021public class Singleton&#123; private static Singleton singleton = null; //限制产生多个对象 private Singleton() &#123; &#125; //通过该方法获得实例对象 public static Singleton getSingleton()&#123; if(singleton == null) &#123; lock(singleton) &#123; if(singleton == null) &#123; //由于某些情况下，可能有延迟加载或者缓存的原因，需要多做一次判断 singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; //其他方法尽量使static public static void doSomething()&#123; &#125;&#125; 注意事项 懒汉式单例高并发情况下，注意单例模式的线程同步问题解决方法，可以在getSingleton方法前加synchronized关键字，也可以在该方法内增加synchronized来实现 需要考虑对象的复制情况解决方法，单例类不实现Cloneable接口 单例模式的扩展 有上限的多例模式：如果要求一个类只能产生两三个对象 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[六大设计原则(SOLID)]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99(SOLID)%2F</url>
    <content type="text"><![CDATA[单一职责原则一个接口或类只有一个原因引起变化 好处 类的复杂度降低 可读性提高 可维护性提高 变更引起的风险降低 难以实现的原因环境、工作量、人员的技术水平、硬件资源、文化差异… 里式替换原则为良好的继承定义了一个规范 规则 子类必须完全实现父类的方法。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承 子类可以有自己的个性 覆盖或实现父类的方法时输入参数可以被放大子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松 覆写或实现父类的方法时输出结果可以被缩小子类返回值必须和父类返回值同类型或是父类返回值的子类 依赖倒置原则正置是面向实现编程，倒置是面向接口编程是实现开闭原则的重要途径本质是通过抽象（接口或抽象类）使各个类或模块的是想彼此独立，不互相影响，实现模块间的松耦合。 定义 高层模块不应该依赖底层模块，两者都应该依赖其抽象抽象指接口或抽象类 抽象不应该依赖细节 细节应该依赖抽象 减少类间的耦合性，提高系统的稳定性依赖是可传递的 三种写法 构造函数传递依赖对象 Setter方法传递依赖对象 接口声明依赖对象 原则 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备 变量的表面类型尽量是接口或者是抽象类 任何类都不应该从具体类派生 尽量不要覆写基类的方法类型依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响 结合里氏替换原则使用接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化。 接口隔离原则类型 实例接口 类接口 定义 客户端不应该依赖它不需要的接口 类间的依赖关系应该建立在最小的接口上 接口尽量细化，同时接口中的方法尽量少，与单一职责的不同与单一职责的视角不同，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；接口隔离原则是要求接口的方法尽量少，提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问 保证接口的纯洁性 接口要尽量小根于接口隔离原则拆分接口时，首先必须满足单一职责原则 接口要高内聚提高接口、类、模块的处理能力，减少对外的交互。要求接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更的风险也就越少，同时也有利于降低成本。 定制服务只提供访问者的需要的方法 接口设计是有限度的接口的设计粒度越小，系统越灵活 迪米特法则——最少知识原则一个对象应该对其他对象有最少的了解 原则 只和朋友交流两个对象之间耦合就成为朋友，组合、聚合、依赖等 朋友间也是有距离的 是自己的就是自己的如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中 谨慎使用Serializable 核心观念类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。但解耦是有限度的。 开闭原则一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，底层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段 软件实体 项目或软件产品中按照一定的逻辑规则划分的模块 抽象和类 方法 变化的归纳 逻辑变化 子模块变化 可见视图变化 为什么 开闭原则对测试的影响 开闭原则可以提高复用性粒度越小，被复用的可能性越大 开闭原则可以提高可维护性 面向对象开发的要求 如何使用开闭原则 抽象约束 元数据控制模块行为 制定项目章程 封装变化 注意以下问题 开闭原则也只是一个原则 项目规章非常重要 预知变化 参考《设计模式之禅》]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 数据类型]]></title>
    <url>%2F2018%2F11%2F06%2FMysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本类型整型 TINYINT = 2^8 bit = 1字节 SMALLINT = 2 * 2^8 bit = 2字节 MEDIUMINT = 3 * 2^8 bit = 3字节 INT = INTEGER = 4 * 2^8 bit = 4字节 BIGINT = 8 * 2^8 bit = 8字节 取值范围如果加了 unsigned，则最大值翻倍 浮点型 FLOAT = 4 * 2^8 = 4字节 DOUBLE = 8 * 2^8 bit = 8字节 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2，否则为D+2。 D&lt;=M &amp;&amp; &amp;&amp; M&gt;=0 &amp;&amp; D&lt;=30, M&gt;=1 &amp;&amp; M&lt;=65。 日期和时间类型 DATE = 3字节 YYYY-MM-DD TIME = 3字节 HH:MM:SS YEAR = 1字节 YYYY DATETIME = 8字节 YYYY-MM-DD HH:MM:SS TIMESTAMP = 4字节 2147483647（类似INT） 字符串类型 CHAR = 2^8字节（定长，不区分大小写） VARCHAR = 2^16字节（变长，不区分大小写） char为定长，后面加空格，如果数据中末尾有空格会被去掉，且不区分大小写 TINYBLOB = 2^8字节 不超过 255 个字符的二进制字符串 TINYTEXT = 2^8字节 BLOB = 2^8 * 2^8 = 2^16字节 TEXT = 2^8 * 2^8 = 2^16字节 MEDIUMBLOB = 2^8 2^8 2^8 = 2^24字节 MEDIUMTEXT = 2^8 2^8 2^8 = 2^24字节 LONGBLOB = 2^8 2^8 2^8* 2^8 = 2^32字节 LONGTEXT = 2^8 2^8 2^8* 2^8 = 2^32字节 其他说明一个汉字占多少长度与编码有关：（MySQL 5.0 以上的版本） UTF－8：一个汉字（含繁体）＝3个字节 ； GBK：一个汉字＝2个字节 char 和 varchar 区别： CHAR和VARCHAR在存储或检索过程中不进行大小写转换。 char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。 char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或2个字节(n&gt;255)，多的字节用来记录长度。所以 varchar(4),存入 3 个字符将占用 4 个字节。 char 类型的字符串检索速度要比 varchar 类型的快。 varchar 和 text 区别： varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或 2 个字节(n&gt;255)，text 是实际字符数 +2 个字节。 text 类型不能有默认值。 varchar 可直接创建索引，text 创建索引指定索引前缀的长度。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。 二进制数据(_Blob) 和 text 区别： BLOB 是一个二进制大对象 _BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 _BLOB存储的数据只能整体读出。 _TEXT可以指定字符集，_BLO不用指定字符集。 ENUM 和 SET 区别： ENUM = 1字节或2字节 最多2字节（2^16） ENUM是一个字符串对象，可以插入空字符串””（索引：0）和NULL（索引：NULL），从1开始编号。其值来自表创建时在列规定中显式枚举的一列值 SET = 1字节或2字节或3字节或4字节或8字节 SET是一个字符串对象，可以有零或多个值，最多可以设置64个值，其值来自表创建时规定的允许的一列值 参考http://www.runoob.com/mysql/mysql-data-types.htmlhttps://www.cnblogs.com/Caveolae/p/7058890.html]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
