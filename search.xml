<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>数据库的存储引擎</title>
      <link href="/2019/09/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/2019/09/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h1><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>支持行锁、表锁</p><h3 id="索引存储结构"><a href="#索引存储结构" class="headerlink" title="索引存储结构"></a>索引存储结构</h3><p>聚集索引<br>主键索引和记录存储在一起，普通索引存储主键<br><img src="/2019/09/29/数据库的存储引擎/InnoDB_Index.png" alt="InnoDB索引"><br>普通索引：从索引树查询出主键，再到主键索引树定位具体记录<br>主键索引：主键索引树定位具体记录<br><a id="more"></a></p><ul><li>主键不宜过长：每个索引都要记录主键值，在数据量大，内存珍贵情况下，MySQL有限的缓冲区，存储索引与数据会减少，磁盘IO的概率会增加，索引占用磁盘空间也会增加，因此需要建立一个自增ID作为主键</li></ul><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>只支持表锁</p><h3 id="索引存储结构-1"><a href="#索引存储结构-1" class="headerlink" title="索引存储结构"></a>索引存储结构</h3><p>非聚集索引<br>主键索引和记录分开存储，普通索引结构和主键索引一致，允许没有主键索引<br><img src="/2019/09/29/数据库的存储引擎/MyISAM_Index.png" alt="MyISAM索引"><br>普通索引/主键索引：从索引树定位到记录指针（索引树的叶子节点）再通过记录指针定位到具体的记录</p><h2 id="其他（MEMORY、MERGE）"><a href="#其他（MEMORY、MERGE）" class="headerlink" title="其他（MEMORY、MERGE）"></a>其他（MEMORY、MERGE）</h2><p>只支持表锁</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ol><li>占用内存少，行锁的数量与行记录相关，非常耗内存</li><li>如果业务经常读写表中很大一块数据时，表锁很更快，因为只涉及一个锁，不涉及管理多个锁</li><li>如果业务经常使用 <code>group by</code> 表锁会更快（这样的场景，使用MyISAM比InnoDB更优），原因是只涉及一个锁，不涉及管理多个锁</li></ol><h3 id="怎么运作？"><a href="#怎么运作？" class="headerlink" title="怎么运作？"></a>怎么运作？</h3><p>写时：如果表没有锁，对表加写锁；否则，入写锁队列<br>读时：如果表没有写锁，对表加读锁；否则，入读锁队列</p><p>如果<em>写锁队列</em>和<em>读锁队列</em>都有锁，写锁优先级更高（执行完所有update才执行select）<br>原因：如果有“大查询”，可能导致写锁被饿死，写锁往往释放很快</p><h3 id="查看表锁情况"><a href="#查看表锁情况" class="headerlink" title="查看表锁情况"></a>查看表锁情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show status like &apos;Table%&apos;;</span><br></pre></td></tr></table></figure><p><img src="/2019/09/29/数据库的存储引擎/mysql_show_status.png" alt="表锁情况"></p><p>其中：<br>Table_locks_immediate：立刻获得锁的次数<br>Table_locks_waited: 需要等到表锁的次数（如果占比较大，表锁可能是潜在的瓶颈）</p><h1 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="为什么在并发插入量比较大的时候，比较适合使用MyISAM呢？不会因为表锁频繁冲突而导致吞吐量降低吗？"><a href="#为什么在并发插入量比较大的时候，比较适合使用MyISAM呢？不会因为表锁频繁冲突而导致吞吐量降低吗？" class="headerlink" title="为什么在并发插入量比较大的时候，比较适合使用MyISAM呢？不会因为表锁频繁冲突而导致吞吐量降低吗？"></a>为什么在并发插入量比较大的时候，比较适合使用MyISAM呢？不会因为表锁频繁冲突而导致吞吐量降低吗？</h2><ul><li>MyISAM索引与记录分开存放，因此记录可以紧密存储（？）</li><li>如果数据文件紧密存储，中间没有空闲块，数据总是插入到数据文件的尾部，就如同追加日志一样，性能很高，并发select和insert不加锁</li><li>如果数据文件中间有空洞（如删除或修改数据），上述机制失效，直至空洞被填满，又会启用不加锁机制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>select poll epoll</title>
      <link href="/2019/09/27/select-poll-epoll/"/>
      <url>/2019/09/27/select-poll-epoll/</url>
      
        <content type="html"><![CDATA[<h2 id="I-O复用"><a href="#I-O复用" class="headerlink" title="I/O复用"></a>I/O复用</h2><p>允许计算机执行或阻塞在一组数据流上，直到某个到达唤醒阻塞的进程</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>水平触发</p><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>水平触发</p><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>支持水平触发，也支持边缘触发，默认是水平触发</p><h2 id="epoll与select的原理比较类似，但epoll作了很多重大改进"><a href="#epoll与select的原理比较类似，但epoll作了很多重大改进" class="headerlink" title="epoll与select的原理比较类似，但epoll作了很多重大改进"></a>epoll与select的原理比较类似，但epoll作了很多重大改进</h2><ol><li>select有FD限制，linux下是1024个，epoll没有数量限制。</li><li>IO效率不会随着FD数量增加而线性下降</li><li>epoll的API更加简单<a id="more"></a></li></ol><h2 id="Level-triggered-水平触发"><a href="#Level-triggered-水平触发" class="headerlink" title="Level_triggered(水平触发)"></a>Level_triggered(水平触发)</h2><p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时,它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你！！！如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率！！！</p><h2 id="Edge-triggered-边缘触发"><a href="#Edge-triggered-边缘触发" class="headerlink" title="Edge_triggered(边缘触发)"></a>Edge_triggered(边缘触发)</h2><p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()据会通知处理程序去读写。如果这次没有把数一次性全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它&lt;不会&gt;通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你！！！这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符！！！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap原理</title>
      <link href="/2019/06/06/HashMap%E5%8E%9F%E7%90%86/"/>
      <url>/2019/06/06/HashMap%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/mbshqqb/article/details/79799009" target="_blank" rel="noopener">https://blog.csdn.net/mbshqqb/article/details/79799009</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>laradock 笔记</title>
      <link href="/2019/05/06/laradock-%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/06/laradock-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="换中国源"><a href="#换中国源" class="headerlink" title="换中国源"></a>换中国源</h2><blockquote><p>新建 php-fpm/sources.list 文件，添加代码（基本上就是只换域名地址，其他不换）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.163.com/debian stretch main</span><br><span class="line">deb http://mirrors.163.com/debian/ stretch-updates main</span><br><span class="line">deb http://mirrors.163.com/debian-security stretch/updates main</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>然后修改 php-fpm/Dockerfile 文件， 在首部添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY ./sources.list /etc/apt/sources.list</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><p><a href="https://blog.forecho.com/use-laradock.html" target="_blank" rel="noopener">https://blog.forecho.com/use-laradock.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nginx概述</title>
      <link href="/2019/03/28/Nginx%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/03/28/Nginx%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h1><p>轻量级web服务器</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><img src="/2019/03/28/Nginx概述/application.png" alt="nginx应用场景"></p><a id="more"></a><h2 id="反向代理服务器"><a href="#反向代理服务器" class="headerlink" title="反向代理服务器"></a>反向代理服务器</h2><h3 id="普通反向代理"><a href="#普通反向代理" class="headerlink" title="普通反向代理"></a>普通反向代理</h3><p>web请求会首先先经过nginx，再到我们的应用服务，然后再访问mysql、redis这样的数据库，提供基本的数据功能。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>应用服务因为要求开发效率非常高，所以运行效率很低，它的qps、tps或并发受限，所以需要把很多应用服务组成一个集群，向用户提供高可用性。<br>很多服务组成集群的时候，需要反向代理具备负载均衡功能，可以把动态请求传导给用户。<br>集群带来的两个需求：1、动态扩容，2、有些服务出问题时需要做容灾。<br>反向代理需要具备负载均衡功能。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>随着网络链路的增长，用户体验时延也会增加，如果我们可以把一些一段时间内不变的动态内容缓存在nginx上，由nginx直接向用户提供，用户时延就会减少很多。</p><h2 id="API服务"><a href="#API服务" class="headerlink" title="API服务"></a>API服务</h2><p>应用服务本身的性能有很多的问题，但数据库服务因为业务场景比较简单，因此比应用服务好得多，并发性能和TPS远高于应用服务，nginx可以直接去访问数据库，利用nginx强大的并发性能实现如web防火墙这样复杂的业务功能来提供给用户，要求我们的API服务有非常强大的业务处理功能，像OpenResty、nginx集成的javascript，利用javascript、lua这样的语言功能、语言工具库提供完整的api服务。</p><h2 id="静态资源服务"><a href="#静态资源服务" class="headerlink" title="静态资源服务"></a>静态资源服务</h2><h3 id="通过本地文件系统提供服务"><a href="#通过本地文件系统提供服务" class="headerlink" title="通过本地文件系统提供服务"></a>通过本地文件系统提供服务</h3><p>css、js、图片等静态资源没有必要由应用服务访问，只需要通过本地文件，系统上放置的静态资源，直接由nginx提供访问就可以。</p><!--# 与传统服务器之间的区别apache一个进程同一时间只会处理一个连接一个请求，只有在这个请求处理完以后才会去处理下一个请求，当需要处理几百万连接时，无法开几百万的进程，进程间切换的代价和成本非常高nginx可以处理数百万甚至上千万的并发连接--><h1 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h1><!--![nginx性能](Nginx概述/performance.png)--><!-- 大部分的程序或web服务器随着并发连接数的上升，RPS会急剧下降，原理是：像apache这样的web服务器，一个进程同一时间只会处理一个连接一个请求，只有在这个请求处理完以后才会去处理下一个请求，当需要处理几百万连接时，无法开几百万的进程，进程间切换的代价和成本非常高。这样的设计架构是有问题的。--><h2 id="高并发，高性能"><a href="#高并发，高性能" class="headerlink" title="高并发，高性能"></a>高并发，高性能</h2><p>高并发只需要每个连接所使用的内存尽量少就可以达到，如果要高并发的同时达到高性能就需要非常好的设计。32核64G的内存，可以轻松达到数千万的并发连接。</p><h2 id="可扩展性好"><a href="#可扩展性好" class="headerlink" title="可扩展性好"></a>可扩展性好</h2><p>主要体现在模块化设计，第三方模块生态圈非常丰富。甚至有<a href="http://tengine.taobao.org/" target="_blank" rel="noopener">Tengine</a>、<a href="http://www.runoob.com/w3cnote/openresty-intro.html" target="_blank" rel="noopener">OpenResty</a>这样的第三方插件，在他们之上又生成新的生态圈。丰富的模块为丰富的功能提供保证。</p><h2 id="高可靠性"><a href="#高可靠性" class="headerlink" title="高可靠性"></a>高可靠性</h2><p>nginx可以在服务器上不间断地运行数年。而很多web服务器运行几周或者几个月就需要重启一次。</p><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><p>可以在不停止服务的情况下，升级nginx。<br><!--kill nginx进程会导致操作系统对所有已经建立连接的客户端发送reset复位包，很多客户端没有办法很好处理复位请求，大并发场景下一些偶然事件会导致必然的恶性结果，因此热部署非常有必要--></p><h2 id="BSD许可证"><a href="#BSD许可证" class="headerlink" title="BSD许可证"></a>BSD许可证</h2><p>nginx不只是开源的、免费的，而且可以在有定制需求的场景下修改源代码，再运行在我们的商业场景下，这是合法的。</p><h1 id="请求切换"><a href="#请求切换" class="headerlink" title="请求切换"></a>请求切换</h1><p><img src="/2019/03/28/Nginx概述/request.png" alt="请求切换对比图"><br>三个请求，如果每个请求都是HTTP请求，简化为三部分，第一部分：收到HTTP请求的header，收到header后利用一些负载均衡算法，就知道应该交给上游的哪台服务器去处理。通过header中的content-length判断有没有body，如果有body，会去读下一个读事件，去处理HTTP body，处理完body后，还会发送一个Http响应，在这个过程中，实际上可能表现为3个事件。</p><p>传统的服务，如Apache、Tomcat，每一个进程同一时间只处理一个请求，比如：process1在处理request1时，当request1目前网络事件不满足的情况下，就会切换到process2，去处理process2上的request2，而request2可能很快就不满足了，可能想写一个响应的时候发现写缓存区已经满了，也就是说网络中已经比较拥塞了，以至于调write方法无法写入需要写入的字节，阻塞类的写方法一定会导致所在的进程又发生一次切换，切换到process3，操作系统选择了process3，因为process3上的request3满足状态，process3可能用完了它的时间片，又切换到process1，如此往复，每做一次切换，会大约消耗5微秒，虽然很小，但如果并发的连接和并发的进程数开始增加，切换进程消耗的时间不是线性增加，而是指数增加，因此并发连接数非常多的时候，进程间切换的消耗会非常可观，消耗绝大部分的计算能力。<br>这种传统的web服务，依赖操作系统进程调度方法实现并发连接数，而操作系统的进程调度仅仅适用于很少的进程间做切换，相对来说，进程间切换的消耗成本还能接受，如果再多上几万或几十万的情况下，就完全无法接受了。</p><p>nginx在蓝色请求处理事件不满足的情况下，用户态直接接切到绿色的请求，这样就没有了中间进程间切换的成本，除非是nginx worker所使用的时间片到了，而时间片的长度一般是5毫秒到800毫秒，所以在nginx worker的配置上一般会把它的优先级加到最高，尽可能让操作系统分配给nginx worker时间片更大，这样nginx才能比较好的在用户态完成请求的切换，使CPU少做无用功。</p><p>nginx采用了异步非阻塞的方式来处理请求，也就是说，nginx是可以同时处理成千上万个请求的。想想apache的常用工作方式（apache也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），每个请求会独占一个工作线程，当并发数上到几千时，就同时有几千的线程在处理请求了。这对操作系统来说，是个不小的挑战，线程带来的内存占用非常大，线程的上下文切换带来的cpu开销很大，自然性能就上不去了，而这些开销完全是没有意义的。<br>首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧。<br>对于一个基本的web服务器来说，事件通常有三种类型，网络事件、信号、定时器。</p><h1 id="版本特性"><a href="#版本特性" class="headerlink" title="版本特性"></a>版本特性</h1><p>x.y.z<br>y为单号是主干版本<br>y为双号是稳定版本</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="下载、编译、安装"><a href="#下载、编译、安装" class="headerlink" title="下载、编译、安装"></a>下载、编译、安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.14.2.tar.gz</span><br><span class="line">tar -xzf nginx-1.14.2.tar.gz</span><br><span class="line">cd nginx-1.14.2</span><br></pre></td></tr></table></figure><p><img src="/2019/03/28/Nginx概述/dir.png" alt="目录结构"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=...</span><br><span class="line">make</span><br><span class="line">首次安装：make install 安装在prefix参数指定的目录下</span><br><span class="line">非首次安装：拷贝objs/nginx 到安装目录中（热部署）</span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/28/Nginx概述/prefix_dir.png" alt="目录结构"></p><h2 id="yum-apt-get"><a href="#yum-apt-get" class="headerlink" title="yum/apt-get"></a>yum/apt-get</h2><p>由于nginx二进制文件会把模块直接编译进来，无法安装出定制化的nginx</p><h1 id="Nginx进程结构"><a href="#Nginx进程结构" class="headerlink" title="Nginx进程结构"></a>Nginx进程结构</h1><p><img src="/2019/03/28/Nginx概述/process_structure.png" alt="进程结构"></p><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><table><thead><tr><th style="text-align:center">信号</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">TERM/INT</td><td style="text-align:center">直接杀死进程（粗暴）stop</td></tr><tr><td style="text-align:center">QUIT</td><td style="text-align:center">优雅的关闭进程,即等请求结束后再关闭 quit</td></tr><tr><td style="text-align:center">HUP</td><td style="text-align:center">改变配置文件,平滑的重读配置文件 reload</td></tr><tr><td style="text-align:center">USR1</td><td style="text-align:center">重读日志,在日志按月/日分割时有用 reopen</td></tr><tr><td style="text-align:center">USR2</td><td style="text-align:center">平滑的升级</td></tr><tr><td style="text-align:center">WINCH</td><td style="text-align:center">优雅关闭旧的进程(配合USR2来进行升级)</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/nginx -s reload/stop/quit/reopen</span><br></pre></td></tr></table></figure><h1 id="重载流程"><a href="#重载流程" class="headerlink" title="重载流程"></a>重载流程</h1><p>当服务器修改配置文件，重载可以平滑地重读配置文件<br><code>sbin/nginx -s reload</code>发生了什么？</p><ol><li>向master进行发送HUP信号（reload命令）</li><li>master进程收到信号</li><li>master进程校验配置语法是否正确</li><li>master进程打开新的监听端口</li><li>master进程用新配置文件启动新的worker子进程</li><li>master进程向老worker子进程发送QUIT信号</li><li>老worker进程关闭监听句柄，处理完当前连接后结束进程</li></ol><h1 id="热部署流程"><a href="#热部署流程" class="headerlink" title="热部署流程"></a>热部署流程</h1><ol><li>将旧的nginx二进制文件替换成新的nginx二进制文件（注意备份）</li><li>向老的master进程发送USR2信号</li><li>master进程修改pid文件名，加后缀.oldbin</li><li>master进程用新的nginx文件启动新的master进程</li><li>向老master进程发送WINCH信号，关闭老worker</li></ol><p>回滚：向老master发送HUP，向新的master发送QUIT</p><h3 id="查看主进程-master-process"><a href="#查看主进程-master-process" class="headerlink" title="查看主进程 master process"></a>查看主进程 master process</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure><p><img src="/2019/03/28/Nginx概述/process.png" alt="发送USR2信号后"></p><h3 id="备份nginx二进制文件"><a href="#备份nginx二进制文件" class="headerlink" title="备份nginx二进制文件"></a>备份nginx二进制文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp sbin/nginx sbin/nginx.old</span><br></pre></td></tr></table></figure><h3 id="替换nginx二进制文件"><a href="#替换nginx二进制文件" class="headerlink" title="替换nginx二进制文件"></a>替换nginx二进制文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp &lt;下载目录&gt;/objs/nginx &lt;安装目录&gt;/sbin/nginx</span><br></pre></td></tr></table></figure><h3 id="发送USR2信号"><a href="#发送USR2信号" class="headerlink" title="发送USR2信号"></a>发送<code>USR2</code>信号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -USR2 [old-master-process-pid]</span><br></pre></td></tr></table></figure><p><img src="/2019/03/28/Nginx概述/hot_development_process.png" alt="发送USR2信号后"><br>新起一个master进程，使用了新的二进制文件，新的master生成新的worker，把新的请求平滑地过渡到新的nginx进程中</p><h3 id="发送WINCH信号，优雅地关闭老的nginx进程"><a href="#发送WINCH信号，优雅地关闭老的nginx进程" class="headerlink" title="发送WINCH信号，优雅地关闭老的nginx进程"></a>发送<code>WINCH</code>信号，优雅地关闭老的nginx进程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -WINCH [old-master-process-pid]</span><br></pre></td></tr></table></figure><p><img src="/2019/03/28/Nginx概述/winch_process.png" alt="发送WINCH信号后"><br>老的worker进程已经优雅退出，所有请求已全部切换到新的worker进程中。<br>老的master进程还没退出，如发现问题，可回退到老版本。</p><h3 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mv sbin/nginx sbin/nginx.new</span><br><span class="line">cp sbin/nginx.old sbin/nginx</span><br><span class="line"></span><br><span class="line">重载配置文件</span><br><span class="line">kill -HUP [old-master-process-pid]</span><br><span class="line">kill -USR2 [new-master-process-pid]</span><br><span class="line">kill -WINCH [new-master-process-pid]</span><br></pre></td></tr></table></figure><!--# 网络收发与nginx事件间的对应关系# HTTP请求的11个阶段https://cloud.tencent.com/developer/news/233604http://tengine.taobao.org/book/chapter_02.html-->]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编译和链接</title>
      <link href="/2019/01/22/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
      <url>/2019/01/22/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h2><p><em>.c 预编译成 </em>.i<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></p><blockquote><p>删除#define，展开所有宏定义<br>处理条件预编译指令 #if #ifdef #elif #else #endif<br>处理#include，递归将被包含的文件插入到该预编译指令的位置<br>删除注释<br>添加行号和文件名标识，方便错误或警告提醒行号<br>保留所有#pragma编译器指令</p></blockquote><a id="more"></a><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>经过词法分析、语法分析、语义分析后产生汇编代码文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br></pre></td></tr></table></figure></p><p>预编译和编译的程序：<br>C：cc1，C++: cc1plus，Object-C：cc1object，fortran：f771，Java：jc1</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>汇编器是将汇编代码转变成机器可以执行的指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">as hello.s -o hello.o</span><br><span class="line">或</span><br><span class="line">gcc -c hello.s -o hello.o</span><br><span class="line">或</span><br><span class="line">gcc -c hello.c -o hello.o    .c =&gt; .i =&gt; .s =&gt; .o(目标文件)</span><br></pre></td></tr></table></figure></p><h3 id="目标文件分类"><a href="#目标文件分类" class="headerlink" title="目标文件分类"></a>目标文件分类</h3><h4 id="程序指令"><a href="#程序指令" class="headerlink" title="程序指令"></a>程序指令</h4><p>代码段：放置程序源代码编译后的机器指令，.code或.text</p><h4 id="程序数据"><a href="#程序数据" class="headerlink" title="程序数据"></a>程序数据</h4><p>数据段：全局变量和局部静态变量数据，.data。<br>Bss段：只是为未初始化的全局变量和局部静态变量预留位置，没有内容，不占空间，.bss</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>只读数据段 .rodata<br>注释信息段 .comment<br>堆栈提示段 .note.GNU-stack</p><h4 id="数据和指令分段好处"><a href="#数据和指令分段好处" class="headerlink" title="数据和指令分段好处"></a>数据和指令分段好处</h4><ol><li>数据可读写，指令只可读，防止程序的指令被改写</li><li>有利于提高程序的局部性，提高CPU的缓存命中率</li><li>系统中运行多个该程序的副本时，指令都是一样的，只需保存一份该程序的指令部分</li></ol><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>主要内容：把各个模块之间相互引用的部分处理好，使得各个模块之间能够正确地衔接。<br>过程主要包括：地址的空间分配、符号决议（也叫符号绑定、名称绑定、名称决议、地址绑定、指令绑定，静态链接中统一称为符号决议）和重定位等。<br>目标文件和库一起链接为最终可执行文件</p><p>在链接中，我们将函数和变量成为符号，函数名或变量名为符号名，每个定义的符号有一个对应的值为符号值，每一个目标文件都会有一个相应的符号表。</p><p>静态链接是把所有程序模块链接成一个个单独的可执行文件<br>动态链接基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将他们链接在一起形成一个完整的程序</p><h3 id="两步"><a href="#两步" class="headerlink" title="两步"></a>两步</h3><ol><li>空间与地址分配</li><li>符号解析和重定位</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Laravel jwt token blacklist storage</title>
      <link href="/2019/01/03/Laravel-jwt-token-blacklist-storage/"/>
      <url>/2019/01/03/Laravel-jwt-token-blacklist-storage/</url>
      
        <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>laravel中，如果我们使用JWT做用户校验，我们可能会有下面的场景</p><blockquote><p>场景1. 退出登录，需要失效这个token，使这个token无法再登录。<br>场景2. 修改密码，需要失效这个用户的所有token，使这些token都无法再登录。</p></blockquote><p>上面的场景的原理都是将token放入一个黑名单。<br>方法是这样的，config/jwt.php中可以设置<code>blacklist_enabled</code>=true，默认<code>providers</code>中的<code>storage</code>是<code>Tymon\JWTAuth\Providers\Storage\Illuminate::class</code></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">return [</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    |--------------------------------------------------------------------------</span><br><span class="line">    | Blacklist Enabled</span><br><span class="line">    |--------------------------------------------------------------------------</span><br><span class="line">    |</span><br><span class="line">    | In order to invalidate tokens, you must have the blacklist enabled.</span><br><span class="line">    | If you do not want or need this functionality, then set this to false.</span><br><span class="line">    |</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    &apos;blacklist_enabled&apos; =&gt; env(&apos;JWT_BLACKLIST_ENABLED&apos;, true),</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    | -------------------------------------------------------------------------</span><br><span class="line">    | Blacklist Grace Period</span><br><span class="line">    | -------------------------------------------------------------------------</span><br><span class="line">    |</span><br><span class="line">    | When multiple concurrent requests are made with the same JWT,</span><br><span class="line">    | it is possible that some of them fail, due to token regeneration</span><br><span class="line">    | on every request.</span><br><span class="line">    |</span><br><span class="line">    | Set grace period in seconds to prevent parallel request failure.</span><br><span class="line">    |</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    &apos;blacklist_grace_period&apos; =&gt; env(&apos;JWT_BLACKLIST_GRACE_PERIOD&apos;, 0),</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    |--------------------------------------------------------------------------</span><br><span class="line">    | Providers</span><br><span class="line">    |--------------------------------------------------------------------------</span><br><span class="line">    |</span><br><span class="line">    | Specify the various providers used throughout the package.</span><br><span class="line">    |</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    &apos;providers&apos; =&gt; [</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        |--------------------------------------------------------------------------</span><br><span class="line">        | Storage Provider</span><br><span class="line">        |--------------------------------------------------------------------------</span><br><span class="line">        |</span><br><span class="line">        | Specify the provider that is used to store tokens in the blacklist.</span><br><span class="line">        |</span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        &apos;storage&apos; =&gt; Tymon\JWTAuth\Providers\Storage\Illuminate::class,</span><br><span class="line"></span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\JWTAuth::setToken($token)-&gt;invalidate();</span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果我们使用jwt的默认配置，可能会有这样的问题。我们把一个token加入黑名单后，的确无法用这个token请求接口了，但是，一旦我们执行了<code>php artisan cache:clear</code>后，这个token又可以请求接口了！！！<br>通过 redis monitor命令，我们可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">登录:</span><br><span class="line">1546424469.572160 [0 172.21.0.6:51426] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546424469.573068 [0 172.21.0.6:51426] &quot;GET&quot; &quot;my_laravel_project_cache:b517b523b1ce573f34e58bf1927d0356fa6bdb47:Sk3cwv4if3qREM0B&quot;</span><br><span class="line"></span><br><span class="line">用token请求接口:</span><br><span class="line">1546424523.795061 [0 172.21.0.6:51438] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546424523.796395 [0 172.21.0.6:51438] &quot;GET&quot; &quot;my_laravel_project_cache:b517b523b1ce573f34e58bf1927d0356fa6bdb47:Sk3cwv4if3qREM0B&quot;</span><br><span class="line"></span><br><span class="line">过期失效token:</span><br><span class="line">1546424689.081416 [0 172.21.0.4:40334] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546424689.081732 [0 172.21.0.4:40334] &quot;SADD&quot; &quot;my_laravel_project_cache:5c23558e2c69e756717126:standard_ref&quot; &quot;my_laravel_project_cache:b517b523b1ce573f34e58bf1927d0356fa6bdb47:Sk3cwv4if3qREM0B&quot;</span><br><span class="line">1546424689.082523 [0 172.21.0.4:40334] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546424689.082872 [0 172.21.0.4:40334] &quot;SETEX&quot; &quot;my_laravel_project_cache:b517b523b1ce573f34e58bf1927d0356fa6bdb47:Sk3cwv4if3qREM0B&quot; &quot;5183820&quot; &quot;a:1:&#123;s:11:\&quot;valid_until\&quot;;i:1546424689;&#125;&quot;</span><br><span class="line"></span><br><span class="line">用失效的token请求接口:</span><br><span class="line">1546424706.850725 [0 172.21.0.6:51456] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546424706.851211 [0 172.21.0.6:51456] &quot;GET&quot; &quot;my_laravel_project_cache:b517b523b1ce573f34e58bf1927d0356fa6bdb47:Sk3cwv4if3qREM0B&quot;</span><br><span class="line"></span><br><span class="line">php artisan cache:clear:</span><br><span class="line">1546424817.672918 [0 172.21.0.4:40348] &quot;FLUSHDB&quot;</span><br><span class="line"></span><br><span class="line">用失效的token请求接口:</span><br><span class="line">1546424840.115652 [0 172.21.0.6:51472] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546424840.116785 [0 172.21.0.6:51472] &quot;SET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot; &quot;s:22:\&quot;5c2c92081c4bf382212366\&quot;;&quot;</span><br><span class="line">1546424840.116960 [0 172.21.0.6:51472] &quot;GET&quot; &quot;my_laravel_project_cache:93b4fa6875e777fb75146e904cdeb7452babab9d:Sk3cwv4if3qREM0B&quot;</span><br><span class="line">1546424840.117916 [0 172.21.0.6:51472] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546424840.118100 [0 172.21.0.6:51472] &quot;GET&quot; &quot;my_laravel_project_cache:93b4fa6875e777fb75146e904cdeb7452babab9d:Sk3cwv4if3qREM0B&quot;</span><br></pre></td></tr></table></figure></p><p>存储token<code>黑名单</code>的redis库默认为0，在执行<code>php artisan cache:clear</code>时，又清除了所有的<code>黑名单</code>中的数据！</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>在<code>config/cache.php</code>的stores中，添加一个jwt的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">return [</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &apos;stores&apos; =&gt; [</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &apos;jwt&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;redis&apos;,</span><br><span class="line">            &apos;connection&apos; =&gt; &apos;jwt&apos;,</span><br><span class="line">        ],</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>在<code>config/database.php</code>的redis中，添加一个jwt的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">return [</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    &apos;redis&apos; =&gt; [</span><br><span class="line">    </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        &apos;jwt&apos; =&gt; [</span><br><span class="line">            &apos;host&apos; =&gt; env(&apos;REDIS_HOST&apos;, &apos;127.0.0.1&apos;),</span><br><span class="line">            &apos;password&apos; =&gt; env(&apos;REDIS_PASSWORD&apos;, null),</span><br><span class="line">            &apos;port&apos; =&gt; env(&apos;REDIS_PORT&apos;, 6379),</span><br><span class="line">            &apos;database&apos; =&gt; 3,                            //根据实际情况修改</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>在<code>app/Providers/AppServiceProvider.php</code>register方法中，绑定cache：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$this-&gt;app-&gt;when(Tymon\JWTAuth\Providers\Storage\Illuminate::class)</span><br><span class="line">    -&gt;needs(Illuminate\Contracts\Cache\Repository::class)</span><br><span class="line">    -&gt;give(function () &#123;</span><br><span class="line">        return app(&apos;cache&apos;)-&gt;store(&apos;jwt&apos;);  //设置cache使用的stores是jwt，jwt中driver为redis，connection为jwt，因此会找到database中redis.jwt的配置</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">登录:</span><br><span class="line">1546502813.438165 [0 172.21.0.6:54284] &quot;SELECT&quot; &quot;3&quot;</span><br><span class="line">1546502813.438443 [3 172.21.0.6:54284] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546502813.438968 [3 172.21.0.6:54284] &quot;GET&quot; &quot;my_laravel_project_cache:12be4fe2af24f2324cf7029d444d8f0d4d09931e:EELCDFgxF2JvnOQu&quot;</span><br><span class="line">1546502813.482131 [0 172.21.0.6:54280] &quot;SET&quot; &quot;my_laravel_project_cache:repository_cache_keys&quot; &quot;a:0:&#123;&#125;&quot;</span><br><span class="line"></span><br><span class="line">用token请求接口:</span><br><span class="line">1546502886.604717 [0 172.21.0.6:54296] &quot;SELECT&quot; &quot;3&quot;</span><br><span class="line">1546502886.605304 [3 172.21.0.6:54296] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546502886.605726 [3 172.21.0.6:54296] &quot;GET&quot; &quot;my_laravel_project_cache:12be4fe2af24f2324cf7029d444d8f0d4d09931e:EELCDFgxF2JvnOQu&quot;</span><br><span class="line"></span><br><span class="line">过期失效token:</span><br><span class="line">1546502919.787005 [0 172.21.0.4:43188] &quot;SELECT&quot; &quot;3&quot;</span><br><span class="line">1546502919.787197 [3 172.21.0.4:43188] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546502919.787502 [3 172.21.0.4:43188] &quot;SADD&quot; &quot;my_laravel_project_cache:5c2dc1ecce50c865414750:standard_ref&quot; &quot;my_laravel_project_cache:12be4fe2af24f2324cf7029d444d8f0d4d09931e:EELCDFgxF2JvnOQu&quot;</span><br><span class="line">1546502919.788080 [3 172.21.0.4:43188] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546502919.788724 [3 172.21.0.4:43188] &quot;SETEX&quot; &quot;my_laravel_project_cache:12be4fe2af24f2324cf7029d444d8f0d4d09931e:EELCDFgxF2JvnOQu&quot; &quot;5183940&quot; &quot;a:1:&#123;s:11:\&quot;valid_until\&quot;;i:1546502919;&#125;&quot;</span><br><span class="line"></span><br><span class="line">用失效的token请求接口:</span><br><span class="line">1546502954.643295 [0 172.21.0.6:54314] &quot;SELECT&quot; &quot;3&quot;</span><br><span class="line">1546502954.643613 [3 172.21.0.6:54314] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546502954.644044 [3 172.21.0.6:54314] &quot;GET&quot; &quot;my_laravel_project_cache:12be4fe2af24f2324cf7029d444d8f0d4d09931e:EELCDFgxF2JvnOQu&quot;</span><br><span class="line"></span><br><span class="line">php artisan cache:clear:</span><br><span class="line">1546502980.079590 [0 172.21.0.4:43202] &quot;FLUSHDB&quot;</span><br><span class="line"></span><br><span class="line">用失效的token请求接口:</span><br><span class="line">1546503000.056368 [0 172.21.0.6:54328] &quot;SELECT&quot; &quot;3&quot;</span><br><span class="line">1546503000.056595 [3 172.21.0.6:54328] &quot;GET&quot; &quot;my_laravel_project_cache:tag:tymon.jwt:key&quot;</span><br><span class="line">1546503000.056982 [3 172.21.0.6:54328] &quot;GET&quot; &quot;my_laravel_project_cache:12be4fe2af24f2324cf7029d444d8f0d4d09931e:EELCDFgxF2JvnOQu&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> redis </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Laravel redis monitor</title>
      <link href="/2018/12/19/Laravel-redis-monitor/"/>
      <url>/2018/12/19/Laravel-redis-monitor/</url>
      
        <content type="html"><![CDATA[<h2 id="使用redis-monitor观察"><a href="#使用redis-monitor观察" class="headerlink" title="使用redis monitor观察"></a>使用redis monitor观察</h2><p><em>以下为laradock环境下的redis</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose exec redis redis-cli</span><br><span class="line">127.0.0.1:6379&gt;monitor</span><br></pre></td></tr></table></figure></p><h3 id="队列中无任务，启动队列：php-artisan-queue-work"><a href="#队列中无任务，启动队列：php-artisan-queue-work" class="headerlink" title="队列中无任务，启动队列：php artisan queue:work"></a>队列中无任务，启动队列：php artisan queue:work</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">查看是否需要重启，如果 my_laravel_project_cache:illuminate:queue:restart 存在，就重启队列（代码更新后，一定要重启队列，否则队列不会读取最新代码）。</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:40858] &quot;GET&quot; &quot;my_laravel_project_cache:illuminate:queue:restart&quot;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:delayed&quot; &quot;queues:default&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，延迟任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:delayed&quot; &quot;-inf&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:reserved&quot; &quot;queues:default&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，待处理任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:reserved&quot; &quot;-inf&quot; &quot;1543320121&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Pop the first job off of the queue...\nlocal job = redis.call(&apos;lpop&apos;, KEYS[1])\nlocal reserved = false\n\nif(job ~= false) then\n    -- Increment the attempt count and place job on the reserved queue...\n    reserved = cjson.decode(job)\n    reserved[&apos;attempts&apos;] = reserved[&apos;attempts&apos;] + 1\n    reserved = cjson.encode(reserved)\n    redis.call(&apos;zadd&apos;, KEYS[2], ARGV[1], reserved)\nend\n\nreturn &#123;job, reserved&#125;&quot; &quot;2&quot; &quot;queues:default&quot; &quot;queues:default:reserved&quot; &quot;1543320211&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，从默认队列中删除job</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;lpop&quot; &quot;queues:default&quot;</span><br></pre></td></tr></table></figure><h3 id="及时任务"><a href="#及时任务" class="headerlink" title="及时任务"></a>及时任务</h3><h4 id="操作1-放一个及时任务到消息队列"><a href="#操作1-放一个及时任务到消息队列" class="headerlink" title="操作1: 放一个及时任务到消息队列"></a>操作1: 放一个及时任务到消息队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择1号redis库</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.6:56918] &quot;SELECT&quot; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">将任务放入默认队列</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.6:56918] &quot;RPUSH&quot; &quot;queues:default&quot; &quot;&#123;\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;maxTries\&quot;:4,\&quot;timeout\&quot;:5000,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:145;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;N;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;&#125;,\&quot;id\&quot;:\&quot;aP4LzhyYgB3aKaiCTJRJjlqhVtrqDhOC\&quot;,\&quot;attempts\&quot;:0&#125;&quot;</span><br></pre></td></tr></table></figure><h4 id="操作2-启动队列：php-artisan-queue-work"><a href="#操作2-启动队列：php-artisan-queue-work" class="headerlink" title="操作2: 启动队列：php artisan queue:work"></a>操作2: 启动队列：php artisan queue:work</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">查看是否需要重启，如果 my_laravel_project_cache:illuminate:queue:restart 存在，就重启队列。</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:40858] &quot;GET&quot; &quot;my_laravel_project_cache:illuminate:queue:restart&quot;</span><br><span class="line"></span><br><span class="line">选择1号redis库</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:40860] &quot;SELECT&quot; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:delayed&quot; &quot;queues:default&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，延迟任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:delayed&quot; &quot;-inf&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:reserved&quot; &quot;queues:default&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，待处理任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:reserved&quot; &quot;-inf&quot; &quot;1543320117&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;EVAL&quot; &quot;-- Pop the first job off of the queue...\nlocal job = redis.call(&apos;lpop&apos;, KEYS[1])\nlocal reserved = false\n\nif(job ~= false) then\n    -- Increment the attempt count and place job on the reserved queue...\n    reserved = cjson.decode(job)\n    reserved[&apos;attempts&apos;] = reserved[&apos;attempts&apos;] + 1\n    reserved = cjson.encode(reserved)\n    redis.call(&apos;zadd&apos;, KEYS[2], ARGV[1], reserved)\nend\n\nreturn &#123;job, reserved&#125;&quot; &quot;2&quot; &quot;queues:default&quot; &quot;queues:default:reserved&quot; &quot;1543320207&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，从默认队列中删除job</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;lpop&quot; &quot;queues:default&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，把job加入待处理任务队列中</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zadd&quot; &quot;queues:default:reserved&quot; &quot;1543320207&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;aP4LzhyYgB3aKaiCTJRJjlqhVtrqDhOC\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:145;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;N;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br><span class="line"></span><br><span class="line">任务执行成功，将job从default:reserved中删除</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:40860] &quot;ZREM&quot; &quot;queues:default:reserved&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;aP4LzhyYgB3aKaiCTJRJjlqhVtrqDhOC\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:145;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;N;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure><h3 id="延迟任务"><a href="#延迟任务" class="headerlink" title="延迟任务"></a>延迟任务</h3><h4 id="操作1-放一个延迟任务到消息队列"><a href="#操作1-放一个延迟任务到消息队列" class="headerlink" title="操作1: 放一个延迟任务到消息队列"></a>操作1: 放一个延迟任务到消息队列</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">选择1号redis库</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.6:57034] &quot;SELECT&quot; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">将job放进延迟队列中</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.6:57034] &quot;zadd&quot; &quot;queues:default:delayed&quot; &quot;1543321166&quot; &quot;&#123;\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;maxTries\&quot;:4,\&quot;timeout\&quot;:5000,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:146;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:19:26.033615\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;&#125;,\&quot;id\&quot;:\&quot;JGqshVc6ub4iQH3CeZFFyGjcxTmmPNvh\&quot;,\&quot;attempts\&quot;:0&#125;&quot;</span><br></pre></td></tr></table></figure><h5 id="对应代码"><a href="#对应代码" class="headerlink" title="对应代码"></a>对应代码</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">namespace Illuminate\Queue;</span><br><span class="line"></span><br><span class="line">class RedisQueue extends Queue implements QueueContract</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * Push a raw job onto the queue after a delay.</span><br><span class="line">     *</span><br><span class="line">     * @param  \DateTimeInterface|\DateInterval|int  $delay</span><br><span class="line">     * @param  string  $payload</span><br><span class="line">     * @param  string  $queue</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    protected function laterRaw($delay, $payload, $queue = null)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;getConnection()-&gt;zadd(</span><br><span class="line">            $this-&gt;getQueue($queue).&apos;:delayed&apos;, $this-&gt;availableAt($delay), $payload</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        return json_decode($payload, true)[&apos;id&apos;] ?? null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="操作2-启动队列：php-artisan-queue-work，并执行延迟任务"><a href="#操作2-启动队列：php-artisan-queue-work，并执行延迟任务" class="headerlink" title="操作2: 启动队列：php artisan queue:work，并执行延迟任务"></a>操作2: 启动队列：php artisan queue:work，并执行延迟任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">查看是否需要重启，如果 my_laravel_project_cache:illuminate:queue:restart 存在，就重启队列。</span><br><span class="line">xxxxxxxxxx.xxxxxx [0 172.21.0.5:41020] &quot;GET&quot; &quot;my_laravel_project_cache:illuminate:queue:restart&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:delayed&quot; &quot;queues:default&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，延迟任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:delayed&quot; &quot;-inf&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，移除延迟任务队列中，下标为0的任务（说明只找到一个）</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zremrangebyrank&quot; &quot;queues:default:delayed&quot; &quot;0&quot; &quot;0&quot;</span><br><span class="line"></span><br><span class="line">将任务放入默认队列</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;rpush&quot; &quot;queues:default&quot; &quot;&#123;\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;maxTries\&quot;:4,\&quot;timeout\&quot;:5000,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;,\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:147;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:12:07.408913\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;&#125;,\&quot;id\&quot;:\&quot;brP2ZEbWU7e5CwXAURQ1fxkk1h9VHuKj\&quot;,\&quot;attempts\&quot;:0&#125;&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;EVAL&quot; &quot;-- Get all of the jobs with an expired \&quot;score\&quot;...\nlocal val = redis.call(&apos;zrangebyscore&apos;, KEYS[1], &apos;-inf&apos;, ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call(&apos;zremrangebyrank&apos;, KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call(&apos;rpush&apos;, KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val&quot; &quot;2&quot; &quot;queues:default:reserved&quot; &quot;queues:default&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，待处理任务队列中，按score排序找score小于等于现在的所有任务，score是执行时间</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zrangebyscore&quot; &quot;queues:default:reserved&quot; &quot;-inf&quot; &quot;1543320729&quot;</span><br><span class="line"></span><br><span class="line">使用 Lua 解释器执行脚本</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;EVAL&quot; &quot;-- Pop the first job off of the queue...\nlocal job = redis.call(&apos;lpop&apos;, KEYS[1])\nlocal reserved = false\n\nif(job ~= false) then\n    -- Increment the attempt count and place job on the reserved queue...\n    reserved = cjson.decode(job)\n    reserved[&apos;attempts&apos;] = reserved[&apos;attempts&apos;] + 1\n    reserved = cjson.encode(reserved)\n    redis.call(&apos;zadd&apos;, KEYS[2], ARGV[1], reserved)\nend\n\nreturn &#123;job, reserved&#125;&quot; &quot;2&quot; &quot;queues:default&quot; &quot;queues:default:reserved&quot; &quot;1543320819&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，从默认队列中删除job</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;lpop&quot; &quot;queues:default&quot;</span><br><span class="line"></span><br><span class="line">Lua 解释器执行脚本，把job加入待处理任务队列中</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 lua] &quot;zadd&quot; &quot;queues:default:reserved&quot; &quot;1543320819&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;brP2ZEbWU7e5CwXAURQ1fxkk1h9VHuKj\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:147;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:12:07.408913\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br><span class="line"></span><br><span class="line">任务执行成功，将job从default:reserved中删除</span><br><span class="line">xxxxxxxxxx.xxxxxx [1 172.21.0.5:41022] &quot;ZREM&quot; &quot;queues:default:reserved&quot; &quot;&#123;\&quot;maxTries\&quot;:4,\&quot;attempts\&quot;:1,\&quot;timeout\&quot;:5000,\&quot;job\&quot;:\&quot;Illuminate\\\\Queue\\\\CallQueuedHandler@call\&quot;,\&quot;id\&quot;:\&quot;brP2ZEbWU7e5CwXAURQ1fxkk1h9VHuKj\&quot;,\&quot;timeoutAt\&quot;:null,\&quot;data\&quot;:&#123;\&quot;command\&quot;:\&quot;O:40:\\\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\\\&quot;:11:&#123;s:7:\\\&quot;timeout\\\&quot;;i:5000;s:5:\\\&quot;tries\\\&quot;;i:4;s:11:\\\&quot;\\u0000*\\u0000advisory\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:19:\\\&quot;App\\\\Models\\\\Advisory\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:4;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:17:\\\&quot;\\u0000*\\u0000advisoryRecord\\\&quot;;O:45:\\\&quot;Illuminate\\\\Contracts\\\\Database\\\\ModelIdentifier\\\&quot;:3:&#123;s:5:\\\&quot;class\\\&quot;;s:25:\\\&quot;App\\\\Models\\\\AdvisoryRecord\\\&quot;;s:2:\\\&quot;id\\\&quot;;i:147;s:10:\\\&quot;connection\\\&quot;;s:5:\\\&quot;mysql\\\&quot;;&#125;s:6:\\\&quot;\\u0000*\\u0000job\\\&quot;;N;s:10:\\\&quot;connection\\\&quot;;N;s:5:\\\&quot;queue\\\&quot;;N;s:15:\\\&quot;chainConnection\\\&quot;;N;s:10:\\\&quot;chainQueue\\\&quot;;N;s:5:\\\&quot;delay\\\&quot;;O:13:\\\&quot;Carbon\\\\Carbon\\\&quot;:3:&#123;s:4:\\\&quot;date\\\&quot;;s:26:\\\&quot;2018-11-27 20:12:07.408913\\\&quot;;s:13:\\\&quot;timezone_type\\\&quot;;i:3;s:8:\\\&quot;timezone\\\&quot;;s:3:\\\&quot;PRC\\\&quot;;&#125;s:7:\\\&quot;chained\\\&quot;;a:0:&#123;&#125;&#125;\&quot;,\&quot;commandName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;,\&quot;displayName\&quot;:\&quot;App\\\\Jobs\\\\Advisory\\\\AdvisoryReplyNoticeJob\&quot;&#125;&quot;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="三个队列"><a href="#三个队列" class="headerlink" title="三个队列"></a>三个队列</h3><blockquote><p>queue:default:delayed : 存储延迟任务<br>queue:default : 存储待处理任务，应该处理但是还未处理任务<br>queue:default:reserved : 存储待处理任务</p></blockquote><p>参考<br><a href="https://www.cnblogs.com/yjf512/p/6571941.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.cnblogs.com/yjf512/p/6571941.html?utm_source=tuicool&amp;utm_medium=referral</a><br><a href="https://laravel-china.org/articles/3729/use-laravel-queue-to-understand-the-knowledge#1e3690" target="_blank" rel="noopener">https://laravel-china.org/articles/3729/use-laravel-queue-to-understand-the-knowledge#1e3690</a><br><a href="https://www.codercto.com/a/20858.html" target="_blank" rel="noopener">https://www.codercto.com/a/20858.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql explain用法及含义</title>
      <link href="/2018/12/14/Mysql-explain%E7%94%A8%E6%B3%95%E5%8F%8A%E5%90%AB%E4%B9%89/"/>
      <url>/2018/12/14/Mysql-explain%E7%94%A8%E6%B3%95%E5%8F%8A%E5%90%AB%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p><em>EXPLAIN只能解释SELECT操作，其他操作要重写为SELECT后查看执行计划</em></p><h2 id="EXPLAIN列的解释："><a href="#EXPLAIN列的解释：" class="headerlink" title="EXPLAIN列的解释："></a>EXPLAIN列的解释：</h2><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>SELECT识别符。这是SELECT的查询序列号，每一个select都会分配一个id</p><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>SELECT类型</p><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>输出的行所引用的表</p><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>从最佳类型到最坏类型进行排序<br><a id="more"></a></p><p>特殊：NULL<br>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select min(id) from users\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Select tables optimized away</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure></p><h4 id="system"><a href="#system" class="headerlink" title="[system]"></a>[system]</h4><p>表中只有一条数据。 这个类型是特殊的 const 类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN select * from (select * from admins where id = 1) tmp\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        table: &lt;derived2&gt;</span><br><span class="line">         type: system</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 2</span><br><span class="line">  select_type: DERIVED</span><br><span class="line">        table: admins</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="const"><a href="#const" class="headerlink" title="[const]"></a>[const]</h4><p>针对<code>主键或唯一索引</code>的等值查询扫描, 最多只返回一行数据。 const 查询速度非常快, 因为它仅仅读取一次即可。<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="[eq_ref]"></a>[eq_ref]</h4><p>对于每个来自于前面的表的行组合,从该表中读取一行。这可能是最好的联接类型,除了const类型。<br>此类型通常出现在多表的 join 查询, 表示<code>对于前表的每一个结果, 都只能匹配到后表的一行结果</code>。 并且查询的比较操作通常是 =, 查询效率较高。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users,doctors where users.doctor_id = doctors.id\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: doctors</span><br><span class="line">         type: eq_ref                      </span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: rysn-test.users.doctor_id</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="ref"><a href="#ref" class="headerlink" title="[ref]"></a>[ref]</h4><p>此类型通常出现在<code>多表的 join 查询, 针对于非唯一或非主键索引</code>, 或者是使用了<code>最左前缀</code>规则索引的查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users,doctors where users.doctor_id = doctors.id AND users.doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: doctors</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref                          </span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM users where doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">使用了`最左前缀`规则索引</span><br></pre></td></tr></table></figure></p><h4 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="[ref_or_null]"></a>[ref_or_null]</h4><p>该联接类型如同ref,但是添加了MySQL可以专门搜索包含NULL值的行。</p><h4 id="index-merge"><a href="#index-merge" class="headerlink" title="[index_merge]"></a>[index_merge]</h4><p>该联接类型表示使用了索引合并优化方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from users where id = 2040 or doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: index_merge</span><br><span class="line">possible_keys: PRIMARY,users_doctor_id_index</span><br><span class="line">          key: PRIMARY,users_doctor_id_index</span><br><span class="line">      key_len: 4,4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 4</span><br><span class="line">        Extra: Using union(PRIMARY,users_doctor_id_index); Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="[unique_subquery]"></a>[unique_subquery]</h4><p>该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。</p><h4 id="index-subquery"><a href="#index-subquery" class="headerlink" title="[index_subquery]"></a>[index_subquery]</h4><p>该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)</p><h4 id="range"><a href="#range" class="headerlink" title="[range]"></a>[range]</h4><p>只检索给定范围的行,使用一个索引来选择行。<br>表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录。 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users,doctors where users.doctor_id = doctors.id AND users.doctor_id &gt; 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: range                          </span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: Using index condition</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: doctors</span><br><span class="line">         type: eq_ref</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: rysn-test.users.doctor_id</span><br><span class="line">         rows: 1</span><br><span class="line">        Extra: NULL</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="index"><a href="#index" class="headerlink" title="[index]"></a>[index]</h4><p>该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。<br>表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据。<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据。 当是这种情况时, Extra 字段 会显示 Using index。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT doctor_id FROM users where doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">但如果是：</span><br><span class="line"></span><br><span class="line">mysql&gt; EXPLAIN SELECT * FROM users where doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">使用了`最左前缀`规则索引</span><br></pre></td></tr></table></figure></p><h4 id="ALL"><a href="#ALL" class="headerlink" title="[ALL]"></a>[ALL]</h4><p>对于每个来自于先前的表的行组合,进行完整的表扫描。我们的查询不应该出现 ALL 类型的查询。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM users where name = &apos;yyy&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h3><p>指出MySQL能使用哪个索引在该表中找到行</p><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><p>显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>显示MySQL决定使用的键的字节数。如果键是NULL,则长度为NULL。</p><h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h3><p>显示使用哪个列或常数与key一起从表中选择行</p><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>显示MySQL认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。</p><h3 id="filtered-？"><a href="#filtered-？" class="headerlink" title="filtered(？)"></a>filtered(？)</h3><p>显示了通过条件过滤出的行数的百分比估计值。</p><h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p>包含MySQL解决查询的详细信息</p><h4 id="Distinct"><a href="#Distinct" class="headerlink" title="[Distinct]"></a>[Distinct]</h4><p>MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行</p><h4 id="Not-exists"><a href="#Not-exists" class="headerlink" title="[Not exists]"></a>[Not exists]</h4><p>MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行</p><h4 id="range-checked-for-each-record-index-map"><a href="#range-checked-for-each-record-index-map" class="headerlink" title="[range checked for each record (index map: #)]"></a>[range checked for each record (index map: #)]</h4><p>MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用</p><h4 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="[Using filesort]"></a>[Using filesort]</h4><p>MySQL需要额外的一次传递,以找出如何按排序顺序检索行<br>表示 MySQL 需额外的排序操作，不能通过索引顺序达到排序效果，一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM users ORDER BY name\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: Using filesort</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-index"><a href="#Using-index" class="headerlink" title="[Using index]"></a>[Using index]</h4><p>从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">doctor_id是索引</span><br><span class="line">mysql&gt; EXPLAIN SELECT doctor_id FROM users where  doctor_id = 2\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: users_doctor_id_index</span><br><span class="line">          key: users_doctor_id_index</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 3</span><br><span class="line">        Extra: Using index</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="[Using temporary]"></a>[Using temporary]</h4><p>为了解决查询,MySQL需要创建一个临时表来容纳结果<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select 1 union all select 1\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: No tables used</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 2</span><br><span class="line">  select_type: UNION</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: No tables used</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">           id: NULL</span><br><span class="line">  select_type: UNION RESULT</span><br><span class="line">        table: &lt;union1,2&gt;</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Using temporary</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-where"><a href="#Using-where" class="headerlink" title="[Using where]"></a>[Using where]</h4><p>WHERE 子句用于限制哪一个行匹配下一个表或发送到客户<br><em>name不是索引</em><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT name FROM users where  name = &apos;xx&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: users</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 24</span><br><span class="line">        Extra: Using where</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h4 id="Using-sort-union-…-Using-union-…-Using-intersect-…"><a href="#Using-sort-union-…-Using-union-…-Using-intersect-…" class="headerlink" title="[Using sort_union(…), Using union(…), Using intersect(…)]"></a>[Using sort_union(…), Using union(…), Using intersect(…)]</h4><p>这些函数说明如何为index_merge联接类型合并索引扫描</p><h4 id="Using-index-for-group-by"><a href="#Using-index-for-group-by" class="headerlink" title="[Using index for group-by]"></a>[Using index for group-by]</h4><p>类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表</p><h4 id="Impossible-WHERE"><a href="#Impossible-WHERE" class="headerlink" title="[Impossible WHERE]"></a>[Impossible WHERE]</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">doctor_id是unsigned integer</span><br><span class="line">mysql&gt; EXPLAIN SELECT doctor_id FROM users where  doctor_id = &apos;1340000000000&apos;\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">        Extra: Impossible WHERE noticed after reading const tables</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>桥梁模式</title>
      <link href="/2018/12/11/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/11/%E6%A1%A5%E6%A2%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫桥接模式，将抽象和实现解耦，使得两者可以独立地变化</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Abstraction抽象化角色</li><li>Implementor实现化角色</li><li>RefinedAbstraction修正抽象化角色，引用实现化角色对抽象化角色进行修正</li><li>ConcreteImplementor具体实现化角色</li></ol><ul><li>使用类间的聚合关系、继承、覆写等常用功能，提供一个清晰、稳定的架构 *</li></ul><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public interface Implementor &#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">    public void doAnything();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteImplementor1 implements Imlementor &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteImplementor2 implements Imlementor &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Abstraction &#123;</span><br><span class="line">    //实现化角色的引用</span><br><span class="line">    private Implement imp;</span><br><span class="line">    public Abstraction(Implementor _imp) &#123;</span><br><span class="line">        this.imp = _imp;</span><br><span class="line">    &#125;</span><br><span class="line">    //自身的行为和属性</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        this.imp.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    //获得实现化角色</span><br><span class="line">    public Implement getImp() &#123;</span><br><span class="line">        return imp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RefinedAbstraction extends Abstraction &#123;</span><br><span class="line">    //覆写构造函数</span><br><span class="line">    public RefinedAbstraction(Implementor _imp) &#123;</span><br><span class="line">        super(_imp);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        super.request();</span><br><span class="line">        super.getImp().doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Implementor imp = new ConcreteImplementor1();</span><br><span class="line">        Abstraction = abs = new RefinedAbstraction(imp);</span><br><span class="line">        abs.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>抽象和实现分离，完全是为了解决继承的缺点而提出的设计模式。该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上</li><li>优秀的扩充能力。可增加实现也可增加抽象。</li><li>实现细节对客户透明</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>不希望或不适合使用继承的场景</li><li>接口或抽象类不稳定的场景</li><li>重用性要求较高的场景</li></ol><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与策略模式比：桥梁模式关注的是抽象和实现的分离，它是结构型模式。在不破坏封装的前提下解决抽象和实现都可以独立扩展的模式。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 桥梁模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>享元模式</title>
      <link href="/2018/12/11/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/11/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>是池技术的重要实现方式，使用共享对象可有效地支持大量的细粒度的对象</p><ul><li>两个要求：细粒度的对象和共享对象 *</li></ul><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Flyweight抽象享元角色</li><li>ConcreteFlyweight具体享元角色</li><li>unsharedConcreteFlyweight不可共享的享元角色</li><li>FlyweightFactory享元工厂</li></ol><ul><li>目的：运用共享技术，使得一些细粒度的对象可以共享，我们的设计也应该多使用细粒度的对象，便于重用或重构 *</li></ul><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Flyweight &#123;</span><br><span class="line">    //内部状态</span><br><span class="line">    private String intrinsic;</span><br><span class="line">    //外部状态</span><br><span class="line">    protected final String Extrinsic;</span><br><span class="line">    //要求享元角色必须接受外部状态</span><br><span class="line">    public Flyweight(String _Extrinsic) &#123;</span><br><span class="line">        this.Extrinsic = _Extrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">    //定义业务操作</span><br><span class="line">    public abstract void operate();</span><br><span class="line">    //内部状态的getter/setter</span><br><span class="line">    public String getIntrinsic() &#123;</span><br><span class="line">        return intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setIntrinsic(String intrinsic) &#123;</span><br><span class="line">        this.intrinsic = intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFlyweight1 extends Flyweight &#123;</span><br><span class="line">    //接受外部状态</span><br><span class="line">    public ConcreteFlyweight1(String _Extrinsic) &#123;</span><br><span class="line">        super(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据外部状态进行逻辑处理</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFlyweight2 extends Flyweight &#123;</span><br><span class="line">    //接受外部状态</span><br><span class="line">    public ConcreteFlyweight2(String _Extrinsic) &#123;</span><br><span class="line">        super(_Extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line">    //根据外部状态进行逻辑处理</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FlyweightFactory &#123;</span><br><span class="line">    //池容器</span><br><span class="line">    private static HashMap&lt;String,Flyweight&gt; pool = new HashMap&lt;String,Flyweight&gt;();</span><br><span class="line">    //享元工厂</span><br><span class="line">    public static Flyweight getFlyweight(String Extrinsic) &#123;</span><br><span class="line">        //需要返回的对象</span><br><span class="line">        Flyweight = flyweight = null;</span><br><span class="line">        //在池中没有该对象</span><br><span class="line">        if(!pool.containsKey(Extrinsic)) &#123;</span><br><span class="line">            flyweight = pool.get(Extrinsic);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //根据外部状态创建享元对象</span><br><span class="line">            flyweight = new ConcreteFlyweight1(Extrinsic);</span><br><span class="line">            //放置到池中</span><br><span class="line">            pool.put(Extrinsic, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>大大减少应用程序创建的对象，降低程序内存的占用，增强程序的性能</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>提高系统复杂性，需要分离外部状态和内部状态，而且外部状态具有固化特性，不应该随内部状态改变而改变，否则导致系统的逻辑混乱</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>系统中存在大量的相似对象</li><li>细粒度的对象都具备较接近的外部状态，而且内部状态与环境无关，也就是说对象没有特定身份</li><li>需要缓冲池的场景</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>线程安全问题</li><li>性能平衡</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 享元模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>解释器模式</title>
      <link href="/2018/12/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/12/05/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>AbstractExpression抽象解释器</li><li>TerminalExpression终结符表达式 实现与文法中的元素相关联的解释操作，通常一个解释器模式中只有一个终结符表达式，但有多个实例，对应不同的终结符。主要是处理场景元素和数据的转换。</li><li>NonterminalExpression非终结符表达式 文法中的每条规则对应于一个非中介表达式</li><li>Context环境角色</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Expression &#123;</span><br><span class="line">    //每个表达式必须有一个解析任务</span><br><span class="line">    public abstract Object interpreter(Context ctx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class TerminalExpression extends Expression &#123;</span><br><span class="line">    //通常终结符表达式只有一个，但是有多个对象</span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//代表一个文法规则</span><br><span class="line">public class NonterminalExpression extends Expression &#123;</span><br><span class="line">    public NonterminalExpression(Expression... exoression) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object interpreter(Context ctx) &#123;</span><br><span class="line">        //进行文法处理</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context ctx = new Context();</span><br><span class="line">        Stack&lt;Expression&gt; stack = null;</span><br><span class="line">        for(;;) &#123;</span><br><span class="line">            //进行语法判断，并产生递归调用</span><br><span class="line">        &#125;</span><br><span class="line">        Expression exp = stack.php();</span><br><span class="line">        exp.interpreter(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>是一个简单语法分析工具，最显著的有点就是扩展性，修改语法规则只要修改相应的非终结符表达式就可以了，若扩展语法，则只要增加非终结符类就可以了。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>类膨胀</li><li>解释其模式采用递归调用方法，难以定位问题</li><li>效率问题，大量循环和递归</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>重复发生的问题可以使用解释器模式，例如：不同日志格式但数据要素相同的服务器解析</li><li>一个简单语法需要解释的场景</li></ol><p><em>尽量不要在不重要的模块使用解释器模式，维护困难，可使用脚本语言代替解释器模式</em></p><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 解释器模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>状态模式</title>
      <link href="/2018/11/22/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/22/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>当一个对象内在状态改变时允许其改变行为，这个对象看起来像改变了其类。核心是封装。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>State抽象状态角色 接口或抽象类，负责对象状态定义，并且封装环境角色以实现状态切换</li><li>ConcreteState具体状态角色 每一个具体状态必须完成两个职责：本状态的行为管理以及趋向状态的处理，就是本状态要做的事，以及本状态如何过渡到其他状态</li><li>Context环境角色 定义客户端需要的接口，负责具体状态的切换</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public abstract class State &#123;</span><br><span class="line">    protected Context context;</span><br><span class="line">    public void setContext(Context _context) &#123;</span><br><span class="line">        this.context = _context;</span><br><span class="line">    &#125;</span><br><span class="line">    //行为</span><br><span class="line">    public abstract void handle1();</span><br><span class="line">    public abstract void handle2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteState1 extends State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        //本状态下必须处理的逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        //设置状态</span><br><span class="line">        super.context.setCurrentState(Context.STATE2);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteState2 extends State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        //设置状态</span><br><span class="line">        super.context.setCurrentState(Context.STATE1);</span><br><span class="line">        //过渡到state2状态</span><br><span class="line">        super.context.handle1();</span><br><span class="line">    &#125;    </span><br><span class="line">    @Override</span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        //本状态下必须处理的逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Context &#123;</span><br><span class="line">    public final static State STATE1 = new ConcreteState1();</span><br><span class="line">    public final static State STATE2 = new ConcreteState2();</span><br><span class="line">    </span><br><span class="line">    private State = CurrentState;</span><br><span class="line">    public State getCurrentState() &#123;</span><br><span class="line">        return CurrentState;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setCurrentState(State currentState) &#123;</span><br><span class="line">        this.CurrentState = currentState;</span><br><span class="line">        //切换状态</span><br><span class="line">        this.CurrentState.setContext(this);</span><br><span class="line">    &#125;</span><br><span class="line">    public void handle1() &#123;</span><br><span class="line">        this.CurrentState.handle1(this);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void handle2() &#123;</span><br><span class="line">        this.CurrentState.handle2(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line">        context.setCurrentState(new ConcreteState1());</span><br><span class="line">        context.handel1();</span><br><span class="line">        context.handel2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>把状态对象声明为静态常量</em><br><em>环境角色（Context）具有状态抽象角色（State）定义的所有行为，具有执行使用委托方式</em></p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>结构清晰 避免使用过多的switch..case或者if..else，避免程序的复杂性，提高系统的可维护性</li><li>遵循设计原则 很好体现了开闭原则和单一职责原则，增加状态就增加一个子类，修改状态就修改一个子类</li><li>封装性非常好 状态变换放置到类的内部实现，外部的调用不用知道类内部如何实现状态和行为的变换</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>子类太多，类膨胀，不好管理</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>行为随状态改变而改变</li><li>条件、分支判断语句的替代者</li></ol><p><em>适用于当某个对象在它的状态发生改变时，它的行为也随着发生比较大的变化，也就是说在行为受状态约束的情况下可以使用状态模式，而且使用时对象的状态最好不要超过5个</em></p><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与策略模式比：状态模式封装的是不同的状态，以达到状态切换行为随之改变的目的。状态模式的环境角色不仅仅是委托行为，具有登记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 访问者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>访问者模式</title>
      <link href="/2018/11/21/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/21/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Visitor抽象访问者 抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法的参数定义哪些对象是可以被访问的</li><li>ConcreteVisitor具体访问者 影响访问者访问到一个类后该怎么干，要做什么事</li><li>Element抽象元素 接口或抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义</li><li>ConcreteElement具体元素 实现accept方法，通常是visitor.visit(this)，基本都形成了一种模式了</li><li>ObjectStructure结构对象 元素产生者，一般容纳多个不同类、不同接口的容器，如List、Set、Map等</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Element &#123;</span><br><span class="line">    //业务逻辑</span><br><span class="line">    public abstract void doSomething();</span><br><span class="line">    //允许谁来访问</span><br><span class="line">    public abstract void accept(Ivisitor visitor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public classConcreteElement1 extends Element &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void accept(Ivisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public classConcreteElement2 extends Element &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void accept(Ivisitor visitor) &#123;</span><br><span class="line">        visitor.visit(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IVisitor &#123;</span><br><span class="line">    public void visit(ConcreteElement1 el1);</span><br><span class="line">    public void visit(ConcreteElement2 el2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Visitor implements IVisitor &#123;</span><br><span class="line">    public void visit(ConcreteElement1 el1) &#123;</span><br><span class="line">        el1.doSomething();</span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    public void visit(ConcreteElement2 el2) &#123;</span><br><span class="line">        el2.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//模拟</span><br><span class="line">public class ObjectStructure &#123;</span><br><span class="line">    public static Element createElement() &#123;</span><br><span class="line">        Random rand = new Random();</span><br><span class="line">        if(rand.nextInt(100) &gt; 50) &#123;</span><br><span class="line">            return new ConcreteElement1();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return new ConcreteElement2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0; i&lt;10; i++)&#123;</span><br><span class="line">            Element el = ObjectStructure.createElement();</span><br><span class="line">            el.accept(new Visitor());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>符合单一职责原则</li><li>优秀的扩展性</li><li>灵活性非常高</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>具体元素对访问者公布细节 访问者要访问一个类就必然要求这个类公布一些方法和数据，违反迪米特法则</li><li>具体元素变更比较困难 具体元素角色增加。删除。修改都是比较困难的</li><li>违背了依赖倒置原则 访问者依赖的是具体元素，而不是抽象元素，破坏了依赖倒置原则</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作</li><li>需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作”污染”这些对象的类</li></ol><p><em>业务规则要求遍历多个不同的对象，这本身也是访问者模式的出发点，迭代器模式只能访问同类或同接口的数据，而访问者模式是对迭代器模式的补充，可以遍历不同的对象，然后执行不同的操作</em><br><em>还有一个用途，充当拦截器（Interceptor）</em></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>统计功能</li><li>多个访问者</li><li>双分派 双分派意味着得到执行的操作决定于请求的种类和两个接收者的类型</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>通过访问者模式可以容易地把一些功能进行梳理，达到最终目的——功能集中化，如一个统一的报表运算、UI展现等，我们还可以与其他模式混编建立一套自己的过滤器或者拦截器</p><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 访问者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>备忘录模式</title>
      <link href="/2018/11/21/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/21/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在不破坏封装性的前提下，捕获一个对象内部状态，并在该对象之外保存这个状态。这样以后就可将该对象回复到原先保存的状态。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Originator发起人角色 记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录数据</li><li>Memento备忘录角色 负责存储Originator发起人对象的内部状态，在需要的时候提供发起人需要的内部状态</li><li>Caretaker备忘录管理员角色 对备忘录进行管理、保存和提供备忘录</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class Originator &#123;</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        return new Memento(this.state);</span><br><span class="line">    &#125;</span><br><span class="line">    public void restoreMemento(Memento _memento) &#123;</span><br><span class="line">        this.setState(_memento.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Memento &#123;</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    public Memento(String _state) &#123;</span><br><span class="line">        this.state = _state;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Caretaker &#123;</span><br><span class="line">    private Memento memento;</span><br><span class="line">    public Memento getMemento() &#123;</span><br><span class="line">        return memento;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMemento(Memento memento) &#123;</span><br><span class="line">        this.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Originator originator = new Originator();</span><br><span class="line">        Caretaker caretaker = new Caretaker();</span><br><span class="line">        caretaker.setMemento(origunator.createMemento());</span><br><span class="line">        originator.restoreMemento(caretaker.getMemento());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要保存和恢复数据的相关状态场景</li><li>提供一个可回滚的操作</li><li>需要监控的副本场景中 备份一个主线程中的对象，然后由分析程序来分析</li><li>数据库连接的事务管理就是用备忘录模式</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>备忘录的生命期 主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理</li><li>备忘录的性能 不要频繁建立备份的场景中使用备忘录模式，原因一：控制不了备忘录建立的对象数量；原因二：大对象的建立消耗资源，系统的性能需要考虑</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li><p>clone方式的备忘录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public class Originator implements Cloneable &#123;</span><br><span class="line">    private Originator backup;</span><br><span class="line">    //内部状态</span><br><span class="line">    private String state = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    public String getState() &#123;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setState(String state) &#123;</span><br><span class="line">        this.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    public Memento createMemento() &#123;</span><br><span class="line">        this.backup = this.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public void restoreMemento() &#123;</span><br><span class="line">        this.setState(this.backup.getState());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    protected Originator clone() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return (Originator)super.clone();</span><br><span class="line">        &#125; catch(CloneNotSupporteException e) &#123;</span><br><span class="line">            e.printStackTace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void mian(String[] args) &#123;</span><br><span class="line">        Originator = originator = new Originator();</span><br><span class="line">        originator.setState(&quot;初始状态..&quot;);</span><br><span class="line">        originator.createMemento();        </span><br><span class="line">        originator.setState(&quot;修改后的状态..&quot;);</span><br><span class="line">        originator.restoreMemento();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多状态的备忘录模式</p></li><li>多备份的备忘录</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 备忘录模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>门面模式</title>
      <link href="/2018/11/21/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/21/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>又叫外观模式，要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Facade门面角色 此角色知晓子系统的所有功能和责任</li><li>subsystem子系统角色 可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统不知道门面的存在。</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class ClassA &#123;</span><br><span class="line">    public void doSomethingA() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassB &#123;</span><br><span class="line">    public void doSomethingB() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassC &#123;</span><br><span class="line">    public void doSomethingC() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Facade &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassB b = new ClassB();</span><br><span class="line">    private ClassC c = new ClassC();</span><br><span class="line">    </span><br><span class="line">    public void methodA() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodB() &#123;</span><br><span class="line">        this.a.doSomethingB();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodC() &#123;</span><br><span class="line">        this.a.doSomethingC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>减少系统的相互依赖 所有的依赖都是对门面对象的依赖，与子系统无关</li><li>提高了灵活性 依赖减少了，灵活性自然提高了</li><li>提高安全性 想让你访问子系统的哪些业务就开通哪些逻辑</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>最大的缺点是不符合开闭原则，如果要修改，唯一能做的就是修改门面角色的代码，风险相当大</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>为一个复杂的模块或子系统提供一个供外界访问的接口</li><li>子系统相对独立，外界对子系统的访问只要黑箱操作即可</li><li>预防低水平人员带来的风险扩散</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>一个子系统可以有多个门面，(1)门面可拆分 (2)子系统可以提供不同的访问路径，新增一个引用原有门面的门面</li><li>门面不参与子系统内的业务逻辑，门面对象只是提供一个访问子系统的一个路径而已，不应该参与具体的业务逻辑，否则会产生一个倒依赖的问题：子系统必须依赖门面才能被访问，不仅违反了单一职责原则，同事也破坏了系统的封装性<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassC c = new ClassC();</span><br><span class="line">    public void complexMethod() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">        this.c.doSomethingC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Facade &#123;</span><br><span class="line">    private ClassA a = new ClassA();</span><br><span class="line">    private ClassB b = new ClassB();</span><br><span class="line">    private Context context = new Context();</span><br><span class="line">    </span><br><span class="line">    public void methodA() &#123;</span><br><span class="line">        this.a.doSomethingA();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodB() &#123;</span><br><span class="line">        this.a.doSomethingB();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void methodC() &#123;</span><br><span class="line">        this.context.complexMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 门面模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>观察者模式</title>
      <link href="/2018/11/21/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/21/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫发布订阅模式，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Subject被观察者</li><li>Observer观察者</li><li>ConcreteSubject具体的被观察者</li><li>ConcreteObserver具体的观察者</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Subject &#123;</span><br><span class="line">    private Vector&lt;Observer&gt; obsVector = new Vector&lt;Observer&gt;();</span><br><span class="line">    public void addObserver(Observer o) &#123;</span><br><span class="line">        this.obsVector.add(o);</span><br><span class="line">    &#125;    </span><br><span class="line">    public void delObserver(Observer o) &#123;</span><br><span class="line">        this.obsVector.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for(Observer o:this.obsVector) &#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteSubject extends Subject &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        super.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Observer &#123;</span><br><span class="line">    public void update();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteObserver implements Observer &#123;</span><br><span class="line">    public void update() &#123;</span><br><span class="line">        System.out.println(&quot;接收到信息，并进行处理！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ConcreteSubject subject = new ConcreteSubject();</span><br><span class="line">        Observer obs = new ConcreteObserver();</span><br><span class="line">        subject.addObserver(obs);</span><br><span class="line">        subject.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>观察者和被观察者之间是抽象耦合</li><li>建立一套触发机制</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>顺序执行，一个观察者卡壳，影响整体，一般考虑采用异步方式</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>关联行为场景</li><li>事件多级触发场景</li><li>跨系统的消息交换场景，如消息队列处理机制</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>广播链问题 一个观察者模式中最多出现一个对象既是观察者也是被观察者，消息最多转发一次。</li><li>异步处理问题</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>文件系统</li><li>猫鼠游戏</li><li>ATM取钱</li><li>广播收音机</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>组合模式</title>
      <link href="/2018/11/21/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/21/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫合成模式、整体模式。将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Component抽象构件角色 定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性</li><li>Leaf叶子构件 叶子对象</li><li>Composite树枝构件 树枝对象</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Composite extends Component &#123;</span><br><span class="line">    private ArrayList&lt;Component&gt; componentArrayList = new ArrayList&lt;Component&gt;();</span><br><span class="line">    public void add(Component component) &#123;</span><br><span class="line">        this.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove(Component component) &#123;</span><br><span class="line">        this.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line">    public ArrayList&lt;Component&gt; getChildren() &#123;</span><br><span class="line">        return this.componentArrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Leaf extends Component &#123;</span><br><span class="line">    //可以覆写</span><br><span class="line">    public void doSomething() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Composite root new Composite();</span><br><span class="line">        root.doSomething();</span><br><span class="line">        Composite branch = new Composite();</span><br><span class="line">        Leaf leaf = new Leaf();</span><br><span class="line">        root.add(branch);</span><br><span class="line">        branch.add(leaf);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void display(Composite root) &#123;</span><br><span class="line">        for(Component c:root.getChildren()) &#123;</span><br><span class="line">            if(c instanceof Leaf) &#123;</span><br><span class="line">                c.doSomething();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                display((Composite)c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>高层模块调用简单</li><li>节点自由增加</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>与依赖倒置原则冲突</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>维护和展示部分-整体关系的场景，如树形菜单、文件和文件夹管理。</li><li>从一个整体中能够独立出部分模块或功能的场景。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 组合模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>迭代器模式</title>
      <link href="/2018/11/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/20/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>它提供一种方法访问一个容器对象中的各个元素，而不需要暴露该对象的内部细节。<br>没落的模式，基本么有人会单独写一个迭代器。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Iterator抽象迭代器 first，next，isDone</li><li>ConcreteIterator具体迭代器</li><li>Aggregate抽象容器 容器角色负责提供创建具体迭代器角色的接口</li><li>ConcreteAggregate具体容器 实现容器接口定义的方法，创建出容纳迭代器的对象</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator &#123;</span><br><span class="line">    public Object next();</span><br><span class="line">    public boolean hasNext();</span><br><span class="line">    public boolean remove();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public ConcreteInterator implements Ieterator &#123;</span><br><span class="line">    private Vector vector = new Vector();</span><br><span class="line">    </span><br><span class="line">    public int cursor = 0;</span><br><span class="line">    </span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public ConcreteIeterator(Vector _vector) &#123;</span><br><span class="line">        this.vector = _vector;     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        if(this.cursor == this.vector.size()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object next() &#123;</span><br><span class="line">        Object result = null;</span><br><span class="line">        if(this.hasNext()) &#123;</span><br><span class="line">            result = this.vector.get(this.cursor++);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = null;</span><br><span class="line">        &#125;</span><br><span class="line">        return result; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean remove() &#123;</span><br><span class="line">        this.vector.remove(this.cursor);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Aggregate &#123;</span><br><span class="line">    public void add(Object object);</span><br><span class="line">    public void remove(Object object);</span><br><span class="line">    public Iterator iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteAggregate implements Aggregate &#123;</span><br><span class="line">    private Vector vector = new Vector();</span><br><span class="line">    public void add(Object object) &#123;</span><br><span class="line">        this.vector.add(object);</span><br><span class="line">    &#125;</span><br><span class="line">    public Iterator iterator() &#123;</span><br><span class="line">        return new ConcreteIterator(this.vector);</span><br><span class="line">    &#125;</span><br><span class="line">    public void remove(Object object) &#123;</span><br><span class="line">        this.remove(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Aggregate agg = new ConcreteAggregate();</span><br><span class="line">        agg.add(&quot;abc&quot;);</span><br><span class="line">        agg.add(&quot;aaa&quot;);</span><br><span class="line">        agg.add(&quot;1234&quot;);</span><br><span class="line">        </span><br><span class="line">        Iterator iterator = agg.iterator();</span><br><span class="line">        while(iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 迭代器模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>适配器模式</title>
      <link href="/2018/11/20/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/20/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>又叫变压器模式、包装模式，将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</p><h2 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h2><ol><li>Target目标角色</li><li>Adaptee源角色</li><li>Adapter适配器角色</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public interface Target &#123;</span><br><span class="line">    //目标角色有自己的方法</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public vlass ConcreteTarget implements Target &#123;</span><br><span class="line">    pubilc void request() &#123;</span><br><span class="line">        System.out.println(&quot;xxxx&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Adaptee &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        System.out.println(&quot;zzzzz&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public vlass Adapter extends Adaptee implements Target &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        super.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //原</span><br><span class="line">        Target target = new ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line">        //适配器</span><br><span class="line">        Target target2 = new Adapter();</span><br><span class="line">        target2.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>适配器模式可以让两个没有任何关系的类在一起运行</li><li>增加了类的透明性</li><li>提高类的复用度</li><li>灵活性非常好</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>你有动机修改一个已经投产中的接口时</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>不要在开发阶段考虑，解决的是正在服役中的项目问题<br>项目一定要遵守依赖倒置原则和里氏替换原则</p><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与装饰模式比：适配器模式修饰非血缘关系类，把一个非本家族的对象伪装成本家族的对象，本质是非相同接口的对象。关注的是转化，意图是不同对象之间的转化。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>策略模式</title>
      <link href="/2018/11/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫做政策模式，定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Context封装角色 上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化</li><li>Strategy抽象策略角色 策略算法的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性</li><li>ConcreteStrategy具体策略角色 实现抽象策略</li></ol><a id="more"></a><h2 id="通用源码"><a href="#通用源码" class="headerlink" title="通用源码"></a>通用源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public interface Strategy &#123;</span><br><span class="line">    public void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategy1 implements Strategy &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteStrategy2 implements Strategy &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重点：封装角色，借用了代理模式的思路，区别在于策略模式的封装角色和被封装的策略类不用是同一个接口，如果是同一个接口就成为代理模式</span><br><span class="line">public class Context &#123;</span><br><span class="line">    private Strategy strategy = null;</span><br><span class="line">    public Context(Strategy _strategy) &#123;</span><br><span class="line">        this.strategy = _strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doAnything() &#123;</span><br><span class="line">        this.strategy.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Strategy strategy = new ConcreteStrategy1();</span><br><span class="line">        Context context = new Context(strategy);</span><br><span class="line">        context.doAnything();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>算法可以自由切换</li><li>避免使用多重条件判断</li><li>扩展性良好</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>策略类数量增多 复用可能性小，类数量增多</li><li>所有策略类都要对外暴露 违反迪米特法则，可使用其他模式修正缺陷，如工厂方法模式、代理模式或享元模式</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个类只有在算法或行为上稍有不同的场景</li><li>算法需要自由切换的场景</li><li>需要屏蔽算法规则的场景</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>如果一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀或对外暴露的问题。</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>策略枚举</li></ol><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与命令模式比：策略模式关注是算法替换问题。关注的是算法的完整性、封装性，只有具备了这两个条件才能保证其可以自由切换。具体算法是负责一个完整算法逻辑，它是不可再拆分的原子业务单元，一旦变更就是对算法整体的变更。</li><li>与状态模式比：策略模式封装的是不同的算法，算法之间没有交互。策略模式的环境角色只是一个委托作用，负责算法的替换。</li><li>与桥梁模式比：策略模式是行为模式，旨在封装一系列行为。使用继承和多态建立一套可以自由切换算法的模式。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 策略模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>装饰模式</title>
      <link href="/2018/11/19/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/19/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。</p><h2 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h2><ol><li>Component抽象构件 定义最核心、最原始的对象</li><li>ConcreteComponent具体构件 最核心、最原始的对象的实现</li><li>Decorator装饰角色 一般是一个抽象类，实现接口或者抽象方法，里面不一定有抽象的方法，属性里必然有一个private变量指向Component抽象构件</li><li>具体装饰角色</li></ol><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Component &#123;</span><br><span class="line">    public abstract void operate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteComponent extends Component &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        System.out.println(&apos;do Something&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Decorator extends Component &#123;</span><br><span class="line">    private Component component = null;</span><br><span class="line">    public Decorator(Component _component) &#123;</span><br><span class="line">        this.component = _component;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void operate() &#123;</span><br><span class="line">        this.component.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecorator1 extends Decorator &#123;</span><br><span class="line">    publicConcreteDecorator1(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void method1() &#123;</span><br><span class="line">        System.out,println(&apos;method 1 修饰&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Operate() &#123;</span><br><span class="line">        this.method1();</span><br><span class="line">        super.operate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteDecorator2 extends Decorator &#123;</span><br><span class="line">    publicConcreteDecorator1(Component _component) &#123;</span><br><span class="line">        super(_component);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void method2() &#123;</span><br><span class="line">        System.out,println(&apos;method 1 修饰&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void Operate() &#123;</span><br><span class="line">        super.operate();</span><br><span class="line">        this.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Component component = new ConcreteComponent();</span><br><span class="line">        component = new ConcreteDecorator1(component);</span><br><span class="line">        component = new ConcreteDecorator2(component);</span><br><span class="line">        component.operator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>装饰类和被装饰类可以独立发展，不会互相耦合。</li><li>装饰模式是继承关系的一个替代方案。</li><li>装饰模式可以动态扩展一个实现类的功能。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>多层的装饰是比较复杂的，尽量减少装饰的数量，以降低系统的复杂度</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>需要扩展一个类的功能，或给一个类增加附加功能</li><li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销</li><li>需要为一批的兄弟类进行改装或加装功能，首选装饰模式</li></ol><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与代理模式比：装饰模式在保证接口不变的情况下加强类的功能，保证被修饰的对象功能比原始对象丰富，但不做准入条件判断和准入参数过滤</li><li>与适配器模式比：装饰模式包装的是自己的兄弟类，隶属同一个家族。意图是加强对象的功能。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 装饰模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>责任链模式</title>
      <link href="/2018/11/19/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/19/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。</p><ul><li>实际应用中，一般会有一个封装类对责任模式进行封装，替代Client类，直接返回链中第一个处理者，具体链的设置不需要高层次模块关系 *</li></ul><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>将请求和处理分开，解耦，提高系统灵活性</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>性能问题，每个请求都是从链头遍历到链尾</li><li>调试不方便，类似递归</li></ol><ul><li>链中节点数量控制，避免超长链，一般做法是在Handler中这是一个最大节点数量，太长则不允许链建立 * </li></ul><a id="more"></a><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractLogger &#123;</span><br><span class="line">   public static int INFO = 1;</span><br><span class="line">   public static int DEBUG = 2;</span><br><span class="line">   public static int ERROR = 3;</span><br><span class="line"> </span><br><span class="line">   protected int level;</span><br><span class="line"> </span><br><span class="line">   //责任链中的下一个元素</span><br><span class="line">   protected AbstractLogger nextLogger;</span><br><span class="line"> </span><br><span class="line">   public void setNextLogger(AbstractLogger nextLogger)&#123;</span><br><span class="line">      this.nextLogger = nextLogger;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public void logMessage(int level, String message)&#123;</span><br><span class="line">      if(this.level &lt;= level)&#123;</span><br><span class="line">         write(message);</span><br><span class="line">      &#125;</span><br><span class="line">      if(nextLogger !=null)&#123;</span><br><span class="line">         nextLogger.logMessage(level, message);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   abstract protected void write(String message);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConsoleLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public ConsoleLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;Standard Console::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ErrorLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public ErrorLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;Error Console::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FileLogger extends AbstractLogger &#123;</span><br><span class="line"> </span><br><span class="line">   public FileLogger(int level)&#123;</span><br><span class="line">      this.level = level;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   @Override</span><br><span class="line">   protected void write(String message) &#123;    </span><br><span class="line">      System.out.println(&quot;File::Logger: &quot; + message);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ChainPatternDemo &#123;</span><br><span class="line">   </span><br><span class="line">   private static AbstractLogger getChainOfLoggers()&#123;</span><br><span class="line"> </span><br><span class="line">      AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">      AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">      AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line"> </span><br><span class="line">      errorLogger.setNextLogger(fileLogger);</span><br><span class="line">      fileLogger.setNextLogger(consoleLogger);</span><br><span class="line"> </span><br><span class="line">      return errorLogger;  </span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.INFO, </span><br><span class="line">         &quot;This is an information.&quot;);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.DEBUG, </span><br><span class="line">         &quot;This is an debug level information.&quot;);</span><br><span class="line"> </span><br><span class="line">      loggerChain.logMessage(AbstractLogger.ERROR, </span><br><span class="line">         &quot;This is an error information.&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Standard Console::Logger: This is an information.</span><br><span class="line">File::Logger: This is an debug level information.</span><br><span class="line">Standard Console::Logger: This is an debug level information.</span><br><span class="line">Error Console::Logger: This is an error information.</span><br><span class="line">File::Logger: This is an error information.</span><br><span class="line">Standard Console::Logger: This is an error information.</span><br></pre></td></tr></table></figure></p><p>参考<br>《设计模式之禅》<br><a href="http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html" target="_blank" rel="noopener">http://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 责任链模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>命令模式</title>
      <link href="/2018/11/19/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/19/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或记录请求日志，可以提供命令的撤销和恢复功能。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Receive接收者角色</li><li>Command命令角色</li><li>Invoker调用者角色</li></ol><p><em>封装性好，把请求方（Invoker）和执行方（Receiver）分开</em></p><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Receiver &#123;</span><br><span class="line">    //抽象接收者，定义每个接收者都必须完成的业务</span><br><span class="line">    public abstract void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteReceiver1 extends Receiver &#123;</span><br><span class="line">    //每个接收者都必须处理一定的业务逻辑</span><br><span class="line">    public void doSomthing()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteReceiver2 extends Receiver &#123;</span><br><span class="line">    //每个接收者都必须处理一定的业务逻辑</span><br><span class="line">    public void doSomthing()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Command &#123;</span><br><span class="line">    //每个命令都有一个执行命令的方法</span><br><span class="line">    public abstract void execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteCommand1 extends Command &#123;</span><br><span class="line">    //对哪个Receiver类进行命令处理</span><br><span class="line">    private Receiver receiver;</span><br><span class="line">    public ConcreteCommand1(Receiver _receiver) &#123;</span><br><span class="line">        this.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteCommand2 extends Command &#123;</span><br><span class="line">    //对哪个Receiver类进行命令处理</span><br><span class="line">    private Receiver receiver;</span><br><span class="line">    public ConcreteCommand2(Receiver _receiver) &#123;</span><br><span class="line">        this.receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        this.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Invoker &#123;</span><br><span class="line">    private Command command;</span><br><span class="line">    //接受命令</span><br><span class="line">    public void setCommand(Command _command) &#123;</span><br><span class="line">        this.command = _command;</span><br><span class="line">    &#125;</span><br><span class="line">    public void action() &#123;</span><br><span class="line">        this.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Invoker invoker = new Invoker();</span><br><span class="line">        Receiver receiver = new ConcreteReceiver1();</span><br><span class="line">        Command command = new ConcreteCommand1(receiver);</span><br><span class="line">        </span><br><span class="line">        invoker.setCommand(command);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>类间解耦 调用者角色与接收者角色之间没有任何依赖关系，不需要了解到底是哪个接收者执行</li><li>可扩展性 Command子类非常容易地扩展，而调用者Invoker和高层次的模块Client不产生严重的代码耦合</li><li>命令模式结合其他模式会更优秀 可以结合责任链模式，实现命令族解析任务；结合模板方法模式，减少Command子类的膨胀问题</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>如果有N个命令，Command的子类就是N个，类膨胀非常大</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>只要你任务是命令的地方，例如GUI开发中的一个按钮点击；模拟DOS命令；触发-反馈机制的处理等</p><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与策略模式比：命令模式的主旨是封装命令，使请求者与实现者解耦。关注的是解耦问题，把请求的内容封装为一个个的命令，由接收者执行。关注命令的实现，也就是功能的实现。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 命令模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>中介者模式</title>
      <link href="/2018/11/19/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/19/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫调停者模式<br>用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li>Mediator 抽象中介者角色<br>定义统一的接口，用于各同事角色之间的通信</li><li>Concrete Mediator 具体中介者角色<br>通过协调各同事角色实现协作行为，必须依赖于各个同事角色</li><li>Colleague 同事角色<br>每个同事角色都知道中介者角色，而且与其他的同事角色通信时，一定要通过中介者角色协作。<br>每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为，与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法。</li></ol><a id="more"></a><h2 id="通用源代码"><a href="#通用源代码" class="headerlink" title="通用源代码"></a>通用源代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Mediator &#123;</span><br><span class="line">    //定义同事类</span><br><span class="line">    protected ConcreteColleague1 c1;</span><br><span class="line">    protected ConcreteColleague2 c2;</span><br><span class="line">    </span><br><span class="line">    //注入同事类</span><br><span class="line">    public ConcreteColleague1 getC1() &#123;</span><br><span class="line">        return c1;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setC1(ConcreteColleague1 c1) &#123;</span><br><span class="line">        this.c1 = c1; </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    public ConcreteColleague2 getC2() &#123;</span><br><span class="line">        return c2;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setC2(ConcreteColleague2 c2) &#123;</span><br><span class="line">        this.c2 = c2; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public abstract void doSomething1();</span><br><span class="line">    public abstract void doSomething2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteMediator extends Mediator &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void doSomething1() &#123;</span><br><span class="line">        super.c1.selfMethod1();</span><br><span class="line">        super.c2.selfMethod2();</span><br><span class="line">    &#125;    </span><br><span class="line">    public void doSomething2() &#123;</span><br><span class="line">        super.c1.selfMethod1();</span><br><span class="line">        super.c2.selfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Colleague &#123;</span><br><span class="line">    protected Mediator mediator;</span><br><span class="line">    public Colleague(Mediator _mediator) &#123;</span><br><span class="line">        this.mediator = _mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteColleague1 extends Colleague &#123;</span><br><span class="line">    public ConcreteColleague1(Mediator _mediator) &#123;</span><br><span class="line">        super(_mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    //自有方法</span><br><span class="line">    public void selfMethod1() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    //依赖方法</span><br><span class="line">    public void depMethod1() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">        //自己不能处理的业务逻辑，委托给中介者处理</span><br><span class="line">        super.mediator.doSomething1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteColleague2 extends Colleague &#123;</span><br><span class="line">    public ConcreteColleague2(Mediator _mediator) &#123;</span><br><span class="line">        super(_mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    //自有方法</span><br><span class="line">    public void selfMethod2() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">    &#125;    </span><br><span class="line">    //依赖方法</span><br><span class="line">    public void depMethod2() &#123;</span><br><span class="line">        //处理自己的业务逻辑</span><br><span class="line">        //自己不能处理的业务逻辑，委托给中介者处理</span><br><span class="line">        super.mediator.doSomething2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>减少类间的依赖，把原有的一对多的依赖变成一对一依赖<br>同事类只依赖中介者，减少了依赖，降低了类间的耦合</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>中介者会膨胀得很快，而且逻辑复杂，同事类越多，中介者的逻辑越复杂</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>机场调度中心</li><li>MVC框架 C就是中介者，隔开M和V，减少M和V的依赖关系。</li><li>媒体网关</li><li>中介服务</li></ol><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>N个对象之间产生了相互的依赖关系（N&gt;2）</li><li>多个对象有依赖关系，但依赖的行为尚不确定或者有发生改变的可能，在这种情况下一般建议采用中介者模式，降低变更引起的风险扩散</li><li>产品开发 提升产品的性能和扩展性</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 中介者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>记 laravel chunk 遇到的坑</title>
      <link href="/2018/11/15/%E8%AE%B0laravel-chunk%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
      <url>/2018/11/15/%E8%AE%B0laravel-chunk%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flight::chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //对每条数据做一些处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果’flights’表中有1000条数据，将拆成10次查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` limit 100 offset 0</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 100</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 200</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 300</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 400</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 500</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 600</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 700</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 800</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 900</span><br><span class="line">//对每条数据做一些处理</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><table><thead><tr><th>id</th><th>xx</th><th>yy  </th></tr></thead><tbody><tr><td> 1</td><td>0</td><td>0  </td></tr><tr><td> 2</td><td>0</td><td>0  </td></tr><tr><td> 3</td><td>0</td><td>0  </td></tr><tr><td> ..</td><td>..</td><td>.. </td></tr><tr><td> ..</td><td>..</td><td>..  </td></tr><tr><td>1000</td><td>0</td><td>0  </td></tr></tbody></table><h2 id="如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。"><a href="#如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。" class="headerlink" title="如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。"></a>如果我们按xx进行筛选，更新yy字段，这样不会出任何问题。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flight::where(&apos;xx&apos;, 0)-&gt;chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //$res = 通过flight与关联表的关系得出来值，这也是我们为什么需要通过这种方法更新 </span><br><span class="line">        $flight-&gt;yy = $res;</span><br><span class="line">        $flight-&gt;save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更新所有xx=0的yy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 0</span><br><span class="line">update `flights` set `yy` = 152 where `id` = 1 </span><br><span class="line">update `flights` set `yy` = 12 where `id` = 2 </span><br><span class="line">update `flights` set `yy` = 123 where `id` = 3 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 52 where `id` = 99</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 100</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 100</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 101 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =102 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 103 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 199</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 200</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 200</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 201 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =202 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 203 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 299</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 300</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 300</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 400</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 500</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 600</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 700</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 800</span><br><span class="line">...</span><br><span class="line">select * from `flights` where  `xx` = 0 limit 100 offset 900</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 901 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =902 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 903 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 999</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 1000</span><br></pre></td></tr></table></figure><h2 id="如果我们按yy进行筛选，更新yy字段，这样就会出问题。"><a href="#如果我们按yy进行筛选，更新yy字段，这样就会出问题。" class="headerlink" title="如果我们按yy进行筛选，更新yy字段，这样就会出问题。"></a>如果我们按yy进行筛选，更新yy字段，这样就会出问题。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flight::where(&apos;yy&apos;, 0)-&gt;chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //$res = 通过flight与关联表的关系得出来值(反正不是0)，这也是我们为什么需要通过这种方法更新 </span><br><span class="line">        $flight-&gt;yy = $res;</span><br><span class="line">        $flight-&gt;save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>更新所有yy=0的yy。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 0</span><br><span class="line">update `flights` set `yy` = 152 where `id` = 1 </span><br><span class="line">update `flights` set `yy` = 12 where `id` = 2 </span><br><span class="line">update `flights` set `yy` = 123 where `id` = 3 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 52 where `id` = 99</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 100</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 100</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 201 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =202 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 203 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 299</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 300</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 200</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 401 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =402 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 403 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 499</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 400</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 300</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 601 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =602 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 603 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 699</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 600</span><br><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 400</span><br><span class="line">update `flights` set `yy` = 12 where `id` = 801 </span><br><span class="line">update `flights` set `yy` = 112 where `id` =802 </span><br><span class="line">update `flights` set `yy` = 13 where `id` = 803 </span><br><span class="line">...</span><br><span class="line">update `flights` set `yy` = 5 where `id` = 899</span><br><span class="line">update `flights` set `yy` = 512 where `id` = 800</span><br></pre></td></tr></table></figure><p>很困惑，为什么表中还是有yy=0的数据。<br>在执行 <code>select * from flights where  yy = 0 limit 100 offset 100</code> 之前，id=1~100的数据yy已经不等于0了，所以在执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 100</span><br></pre></td></tr></table></figure></p><p>的时候，搜索出的是id=201~300的数据，而id=101~200的数据，只有在再次搜索<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` where  `yy` = 0 limit 100 offset 0</span><br></pre></td></tr></table></figure></p><p>的时候才会出现。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>所以，我们要避免使用 chunk 的时候，更改和过滤条件的字段的值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> laravel </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>原型模式</title>
      <link href="/2018/11/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/13/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式<br>简单程度仅次于单例模式和迭代器模式，使用广泛<br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建的对象<br>核心就是clone方法，通过该方法进行对象的拷贝，JAVA提供了Cloneable接口，标示这个对象是可拷贝的。覆写clone方法。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>性能优良。原型模式是内存二进制流的拷贝。</li><li>逃避构造函数的约束。不执行构造函数，优点和缺点都是减少了约束。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>资源优化场景。类初始化需要消化非常多的资源，包括数据和硬件资源等。</li><li>性能和安全要求的场景。通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li><li>一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时。</li></ol><p><em>原型模式很少单独出现，一般和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</em></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>构造函数不会被执行</li><li>浅拷贝和深拷贝<br><em>使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变类型</em></li><li>clone与final关键字冲突</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代理模式</title>
      <link href="/2018/11/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫委托模式，为其他对象提供一种代理，以控制对这个对象的访问。使用率非常高。提供非常好的访问控制。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol><li>Subject抽象主题角色。可以是抽象类也可以是接口</li><li>RealSubject具体主题角色。也称为被委托角色或被代理角色，业务逻辑的具体执行者</li><li>Proxy代理主题角色。也称为委托类、代理类</li></ol><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        //业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Proxy implements Subject &#123;</span><br><span class="line">    private Subject subject = null;</span><br><span class="line">    </span><br><span class="line">    public Proxy() &#123;</span><br><span class="line">        this.subject = new Proxy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Proxy(Subject subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void request() &#123;</span><br><span class="line">        this.before();</span><br><span class="line">        this.subject.request();</span><br><span class="line">        this.after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void before() &#123;&#125;</span><br><span class="line">    public void after() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>职责清晰。真实角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰</li><li>高扩展性。具体主题角色随时发生变化，不管怎么变化，只要实现了接口，那代理类完全就可以在不做任何修改的情况下使用。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Spring AOP(代理模式使用到极致)</p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>普通代理，要求客户端只能访问代理角色，而不能访问真实角色。<br>普通代理模式的约束问题，尽量通过团队内的变成规范类约束，因为每一个主题类是可被重用的和可维护的，实用技术约束的方式对系统维护是一种非常不利的因素</li><li>强制代理，强制必须通过真是角色查找到代理角色，否则不能访问。只有通过真实角色指定的代理类才可以访问，由真是角色管理代理角色。可以不知道代理的存在，但是你的所作所为还是需要代理为你提供。</li><li>代理是有个性的。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能。可以代理多个真实角色。</li><li>动态代理。动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪个对象。横切面编程（AOP）核心就是动态代理机制。？？</li></ol><h2 id="与其他模式对比"><a href="#与其他模式对比" class="headerlink" title="与其他模式对比"></a>与其他模式对比</h2><ol><li>与装饰模式比：代理模式在不改变接口的前提下，对过程进行控制</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 代理模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建造者模式</title>
      <link href="/2018/11/13/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/13/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CarBuilder &#123;</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public abstract void setSequence(ArrayList&lt;String&gt; sequence);</span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public abstract CarModel getCarModel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BenzBuilder extends CarBuilder &#123;</span><br><span class="line">    private BenzModel benz = new BenzModel();</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public void setSequence(ArrayList&lt;String&gt; sequence)&#123;</span><br><span class="line">        this.benz.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public CarModel getCarModel() &#123;</span><br><span class="line">        return this.benz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BMWBuilder extends CarBuilder &#123;</span><br><span class="line">    private BMWModel bmw = new BMWModel();</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public void setSequence(ArrayList&lt;String&gt; sequence)&#123;</span><br><span class="line">        this.bmw.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public CarModel getCarModel() &#123;</span><br><span class="line">        return this.bmw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Director &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; sequence = new ArrayList();</span><br><span class="line">    private BenzBuilder benzBuilder = new BenzBuilder();</span><br><span class="line">    private BMWBuilder bmwBuilder = new bmwBuilder();</span><br><span class="line">    </span><br><span class="line">    public BenzModel getABenzModel() &#123;</span><br><span class="line">        this.sequence.clear();</span><br><span class="line">        </span><br><span class="line">        this.sequesce.add(&quot;start&quot;);</span><br><span class="line">        this.sequesce.add(&quot;stop&quot;);</span><br><span class="line">        this.benzBuilder.setSequence(this.sequence);</span><br><span class="line">        return (BenzModel)this.benzBuilder.getCarModel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Director director = new Director();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            director.getABenzModel().run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>需求是无底洞，是无理性的</em></p><a id="more"></a><h2 id="导演类"><a href="#导演类" class="headerlink" title="导演类"></a>导演类</h2><p>指挥各事件的先后顺序</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><h2 id="四个角色"><a href="#四个角色" class="headerlink" title="四个角色"></a>四个角色</h2><ol><li>Product产品类，实现模板方法模式</li><li>Builder抽象建造类，规划产品的组建，一般由子类实现。CarBuilder</li><li>ConcreteBuilder具体建造者，实现抽象类定义好的所有方法，并且返回一个组建好的对象。BenzBuilder和BMWBuilder</li><li>Director导演类，负责安排已有模块顺序，告诉Builder开始建造。</li></ol><p><em>导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。导演类可以有多个</em></p><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Product &#123;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        //独立业务处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class Builder &#123;</span><br><span class="line">    //设置产品的不同部分，已获得不同产品</span><br><span class="line">    public abstract void setPart();</span><br><span class="line">    //建造产品</span><br><span class="line">    public abstract Product buildProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProduct extends Builder &#123;</span><br><span class="line">    private Product product = new Product();</span><br><span class="line">    //设置产品零件</span><br><span class="line">    public void setPart() &#123;</span><br><span class="line">        //产品类内逻辑处理</span><br><span class="line">    &#125;</span><br><span class="line">    //组件一个产品</span><br><span class="line">    public Product buildProduct() &#123;</span><br><span class="line">        return product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Director &#123;</span><br><span class="line">    private Builder builder new ConcreteProduct();</span><br><span class="line">    //构建不同的产品</span><br><span class="line">    public Product getAProduct() &#123;</span><br><span class="line">        builder.setPart();</span><br><span class="line">        return builder.buildProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>封装性。使用建造者模式可以使客户端不必知道产品内部组成的细节。</li><li>建造者独立，容易扩展。BenzBuilder和BMWBuilder互相独立，对系统的扩展非常有利</li><li>便于控制细节风险。建造者独立，可对建造过程逐步细化，而不对其他模块产生任何影响</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能时</li><li>在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时。补偿方法，设计阶段没有发觉。</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>建造者模式关注的是零件类型和装配工艺（顺序），与工厂方法模式最大的不同。建造者模式最主要的功能是基本方法的调用顺序安排，顺序不同产生的对象也不同；工厂方法重点是创造，创建零件是它的主要职责，组装顺序则不是它关心的。<br>使用建造者模式的时候考虑一下模板方法模式。</p><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 建造者模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模板方法模式</title>
      <link href="/2018/11/13/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/13/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//抽象悍马模型</span><br><span class="line">public abstract class HummerModel &#123;</span><br><span class="line">    public abstract void start();</span><br><span class="line">    public abstract void stop();</span><br><span class="line">    public abstract void alarm();</span><br><span class="line">    public abstract void engineBoom();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        this.start(); </span><br><span class="line">        this.engineBoom(); </span><br><span class="line">        this.alarm(); </span><br><span class="line">        this.stop(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//悍马模型H1</span><br><span class="line">public class HummerH1Model extends HummerModel &#123;</span><br><span class="line">    public void alarm() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void engineBoom() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//悍马模型H2</span><br><span class="line">public class HummerH2Model extends HummerModel &#123;</span><br><span class="line">    public void alarm() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void engineBoom() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client() &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HummerModel h1 = new HummerH1Model();</span><br><span class="line">        h1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>在软件开发过程中，如果相同的一段代码复制过两次，就需要对设计产生怀疑，架构师要明确地说明为什么相同的逻辑要出现两次或更多次</em></p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br>常用设计模式</p><h2 id="AbstractClass"><a href="#AbstractClass" class="headerlink" title="AbstractClass"></a>AbstractClass</h2><p>AbstractClass叫做抽象模板，方法分为：基本方法和模板方法，基本方法由子类实现，模板方法一般是一个具体的方法。为防止恶意修改，一般模板方法都加上final关键字，不允许被覆写。基本方法尽量设计为protected类型，符合迪米特法则，不需要暴露的属性或方法尽量不要设置为protected类型。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>封装不变部分，扩展可变部分</li><li>提取公共部分代码，便于维护</li><li>行为由父类控制，子类实现。符合开闭原则</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>在复杂项目中，会带来代码阅读的难度，新手产生不适感</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>多个子类有公有的方法，而且逻辑基本相同时</li><li>重要、、复杂的算法，可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现</li><li>重构时，模板方法模式是最常用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为</li></ol><h2 id="扩展——钩子方法"><a href="#扩展——钩子方法" class="headerlink" title="扩展——钩子方法"></a>扩展——钩子方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//抽象悍马模型</span><br><span class="line">public abstract class HummerModel &#123;</span><br><span class="line">    public abstract void start();</span><br><span class="line">    public abstract void stop();</span><br><span class="line">    public abstract void alarm();</span><br><span class="line">    public abstract void engineBoom();</span><br><span class="line">    final public void run() &#123;</span><br><span class="line">        this.start(); </span><br><span class="line">        this.engineBoom(); </span><br><span class="line">        //this.alarm(); </span><br><span class="line">        if(this.isAlarm()) &#123;</span><br><span class="line">            this.alarm();</span><br><span class="line">        &#125;</span><br><span class="line">        this.stop(); </span><br><span class="line">    &#125;</span><br><span class="line">    //默认响喇叭，钩子方法</span><br><span class="line">    protected boolean isAlarm() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//悍马模型H1</span><br><span class="line">public class HummerH1Model extends HummerModel &#123;</span><br><span class="line">    private boolean alarmFlag = true;</span><br><span class="line">    public void alarm() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void engineBoom() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    //设置是否响喇叭</span><br><span class="line">    public void setAlarm(boolean isAlarm) &#123;</span><br><span class="line">        this.alarmFlag = isAlarm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//悍马模型H2</span><br><span class="line">public class HummerH2Model extends HummerModel &#123;</span><br><span class="line">    public void alarm() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void engineBoom() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">    //默认不响喇叭</span><br><span class="line">    protected boolean isAlarm() &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client() &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HummerModel h1 = new HummerH1Model();</span><br><span class="line">        h1.setAlarm(false);</span><br><span class="line">        h1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>外界条件改变，影响模板方法的执行，isAlarm的返回值影响了模板方法的执行结果，该方法叫做钩子方法（Hook Method）</em></p><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 模板方法模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>抽象工厂模式</title>
      <link href="/2018/11/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/13/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为创建一组相关或相互依赖的对象提供一个接口，并且无需指定他们的具体类<br>抽象工厂模式是工厂方法模式的升级版本，在多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式<br>有N个产品族，在抽象工厂类中就应该有N个创建方法</p><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品类</span><br><span class="line">public abstract class AbstractProductA &#123;</span><br><span class="line">    //每个产品的共有方法</span><br><span class="line">    public void sgareMethod()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //抽象方法,相同方法不同实现</span><br><span class="line">    public abstract void doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品A1类</span><br><span class="line">public class ProductA1 extends AbstractProductA &#123;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品A2类</span><br><span class="line">public class ProductA2 extends AbstractProductA &#123;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象工厂类</span><br><span class="line">public abstract class AbstractCreator &#123;</span><br><span class="line">    public abstract AbstractProductA createProductA();</span><br><span class="line">    public abstract AbstractProductB createProductB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体工厂等级1实现类</span><br><span class="line">public class Creator1 extends AbstractCreator &#123;</span><br><span class="line">    public AbstractProductA createProductA() &#123;</span><br><span class="line">        return new ProductA1();</span><br><span class="line">    &#125;    </span><br><span class="line">    public AbstractProductB createProductB() &#123;</span><br><span class="line">        return new ProductB1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体工厂等级2实现类</span><br><span class="line">public class Creator2 extends AbstractCreator &#123;</span><br><span class="line">    public AbstractProductA createProductA() &#123;</span><br><span class="line">        return new ProductA2();</span><br><span class="line">    &#125;    </span><br><span class="line">    public AbstractProductB createProductB() &#123;</span><br><span class="line">        return new ProductB2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        AbstractCreator creator1 = new Creator1();</span><br><span class="line">        AbstractCreator creator2 = new Creator2();</span><br><span class="line">        //A1</span><br><span class="line">        AbstractProductA a1 = creator1.createProductA();  </span><br><span class="line">        //A2</span><br><span class="line">        AbstractProductA a2 = creator2.createProductA();        </span><br><span class="line">        //B1</span><br><span class="line">        AbstractProductB b1 = creator1.createProductB();  </span><br><span class="line">        //B2</span><br><span class="line">        AbstractProductB b2 = creator2.createProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>封装性。每个产品的实现类不是高层模块要关心的，高层模块只关心接口，抽象，不关心对象是如何创建出来的。工厂类负责关心对象是如何创建出来的，产品只要知道工厂类是谁，就能创建出一个需要的对象，省时省力。</li><li>产品族内的约束为非公开状态。</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>最大缺点是：产品族扩展非常困难，严重违反开闭原则！</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式<br>例：一个文本编辑器和一个图片处理器，都是软件实体，在操作系统不同下，虽然功能和界面相同，但代码实现不同，图片处理器也有类似情况。这就是具有了共同的约束条件：操作系统类型。于是可以使用抽象工厂模式，产生不同操作系统下的编辑器和图片处理器</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>产品族扩展非常困难，但产品等级扩展非常简单。横向扩展容易，纵向扩展困难。例：不同肤色和不同性别的人类例子中，扩展肤色困难，但是扩展性别简单，这是符合开闭原则的。<br>在软件产品开发过程中，设计不同操作系统时，都可以考虑使用抽象工厂模式。</p><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 抽象工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>工厂方法模式</title>
      <link href="/2018/11/13/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/13/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><a id="more"></a><h2 id="通用代码"><a href="#通用代码" class="headerlink" title="通用代码"></a>通用代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">//抽象产品类</span><br><span class="line">public abstract class Product&#123;</span><br><span class="line">    //产品类共有方法</span><br><span class="line">    public void method1()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //抽象方法</span><br><span class="line">    public abstract void method2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//产品1类</span><br><span class="line">public class Product1 extends Product &#123;</span><br><span class="line">    public void method2()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//抽象工厂类</span><br><span class="line">public abstract class Creator &#123;</span><br><span class="line">    public abstract &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//具体工厂1类</span><br><span class="line">public class Creator1 extends Creator &#123;</span><br><span class="line">    public &lt;T extends Product&gt; T createProduct(Class&lt;T&gt; c) &#123;</span><br><span class="line">        Product product = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            product = (Product)Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; catch (Exception e)&#123;</span><br><span class="line">            //异常处理</span><br><span class="line">        &#125;</span><br><span class="line">        return (T)product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Creator creator = new Creator1();</span><br><span class="line">        Product product = creator.createProduct(Product1.class);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>优良的封装性，代码结构清晰，降低模块间的耦合性</li><li>扩展性非常优秀</li><li>屏蔽产品类</li><li>解耦框架。高层模块只需要产品的抽象类，其他的实现类都不关心，符合迪米特法则（不需要的不交流），也符合依赖倒置原则（只依赖产品类的抽象），也符合里氏替换原则（使用产品子类替换产品父类</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>在所有需要生成对象的地方都可以使用</li><li>需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式</li><li>工厂方法模式可以用在异构项目中</li><li>TDD开发的框架下</li></ol><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol><li>缩小为简单工厂模式<br>一个模块只需要一个工厂类，没有必要把它生产出来。该模式是工厂方法模式的弱化，因为简单，成为简单工厂模式，也叫静态工厂模式。缺点是工厂类的扩展比较困难，不符合开闭原则，但仍然是一个非常实用的设计模式</li><li>升级为多个工厂类<br>抽象方法中已经不再需要传递相关参数了，因为每个具体的工厂都已经非常明确自己的职责：创建自己负责的产品类对象。增加扩展的难度。</li><li>替代单例模式<br>通过反射方式创建</li><li>延迟初始化<br>一个对象被消费完毕后，不立刻释放，工厂类保持其初始状态，等待再次被使用。</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂方法模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>单例模式</title>
      <link href="/2018/11/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2018/11/12/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Singleton类称为单例类<br>通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol><li>在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式优势明显</li><li>由于单例模式只生成一个实例，所以减少了系统的性能开销。当一个对象的产生需要比较多资源的时候，如读取配置、产生其他依赖对象时，则可以通过在<em>应用启动时</em>直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li><li>单例模式可以避免对资源的多重占用，如避免对同一资源文件的同时写操作</li><li>单例模式可以在系统设置全局访问点，优化和共享资源访问。如设计一个单例类，负责所有数据表的映射处理。</li></ol><a id="more"></a><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol><li>一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。<br>接口对单例模式没有任何意义，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。</li><li>单一模式对测试是不利的。<br>在并行开发的环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。</li><li>单例模式与单一职责原则有冲突。<br>一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>要求生成唯一序列号的环境</li><li>在整个项目中需要一个共享访问点或共享数据，如web页面上的计数器</li><li>创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源</li><li>需要定义大量的静态常量和静态方法的环境，可以采用单例模式</li></ol><h2 id="两种常见写法"><a href="#两种常见写法" class="headerlink" title="两种常见写法"></a>两种常见写法</h2><p>饿汉式单例：(单例模式通用代码)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static final Singleton singleton = new Singleton();</span><br><span class="line">    //限制产生多个对象</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过该方法获得实例对象</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    //其他方法尽量使static</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式单例：（线程不安全单例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton = null;</span><br><span class="line">    //限制产生多个对象</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过该方法获得实例对象</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        if(singleton == null) &#123;</span><br><span class="line">            singleton = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    //其他方法尽量使static</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【修改后】懒汉式单例：（线程安全单例）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">    private static Singleton singleton = null;</span><br><span class="line">    //限制产生多个对象</span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过该方法获得实例对象</span><br><span class="line">    public static Singleton getSingleton()&#123;</span><br><span class="line">        if(singleton == null) &#123;</span><br><span class="line">            lock(singleton) &#123;</span><br><span class="line">                if(singleton == null) &#123; //由于某些情况下，可能有延迟加载或者缓存的原因，需要多做一次判断</span><br><span class="line">                    singleton = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return singleton;</span><br><span class="line">    &#125;</span><br><span class="line">    //其他方法尽量使static</span><br><span class="line">    public static void doSomething()&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>懒汉式单例高并发情况下，注意单例模式的线程同步问题<br>解决方法，可以在getSingleton方法前加synchronized关键字，也可以在该方法内增加synchronized来实现</li><li>需要考虑对象的复制情况<br>解决方法，单例类不实现Cloneable接口</li></ol><h2 id="单例模式的扩展"><a href="#单例模式的扩展" class="headerlink" title="单例模式的扩展"></a>单例模式的扩展</h2><ol><li>有上限的多例模式：如果要求一个类只能产生两三个对象</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>六大设计原则(SOLID)</title>
      <link href="/2018/11/12/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99(SOLID)/"/>
      <url>/2018/11/12/%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99(SOLID)/</url>
      
        <content type="html"><![CDATA[<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>一个接口或类只有一个原因引起变化</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>类的复杂度降低</li><li>可读性提高</li><li>可维护性提高</li><li>变更引起的风险降低</li></ol><h2 id="难以实现的原因"><a href="#难以实现的原因" class="headerlink" title="难以实现的原因"></a>难以实现的原因</h2><p>环境、工作量、人员的技术水平、硬件资源、文化差异…</p><hr><h1 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h1><p>为良好的继承定义了一个规范</p><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol><li>子类必须完全实现父类的方法。<br>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li><li>子类可以有自己的个性</li><li>覆盖或实现父类的方法时输入参数可以被放大<br>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松</li><li>覆写或实现父类的方法时输出结果可以被缩小<br>子类返回值必须和父类返回值同类型或是父类返回值的子类</li></ol><a id="more"></a><hr><h1 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h1><p>正置是面向实现编程，倒置是面向接口编程<br>是实现开闭原则的重要途径<br>本质是通过抽象（接口或抽象类）使各个类或模块的是想彼此独立，不互相影响，实现模块间的松耦合。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ol><li>高层模块不应该依赖底层模块，两者都应该依赖其抽象<br>抽象指接口或抽象类</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ol><p>减少类间的耦合性，提高系统的稳定性<br>依赖是可传递的</p><h2 id="三种写法"><a href="#三种写法" class="headerlink" title="三种写法"></a>三种写法</h2><ol><li>构造函数传递依赖对象</li><li>Setter方法传递依赖对象</li><li>接口声明依赖对象</li></ol><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><ol><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或者是抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法<br>类型依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响</li><li>结合里氏替换原则使用<br>接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化。</li></ol><hr><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li>实例接口</li><li>类接口</li></ol><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><ol><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ol><h2 id="接口尽量细化，同时接口中的方法尽量少，与单一职责的不同"><a href="#接口尽量细化，同时接口中的方法尽量少，与单一职责的不同" class="headerlink" title="接口尽量细化，同时接口中的方法尽量少，与单一职责的不同"></a>接口尽量细化，同时接口中的方法尽量少，与单一职责的不同</h2><p>与单一职责的视角不同，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；接口隔离原则是要求接口的方法尽量少，提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问</p><h2 id="保证接口的纯洁性"><a href="#保证接口的纯洁性" class="headerlink" title="保证接口的纯洁性"></a>保证接口的纯洁性</h2><ol><li>接口要尽量小<br>根于接口隔离原则拆分接口时，首先必须满足单一职责原则</li><li>接口要高内聚<br>提高接口、类、模块的处理能力，减少对外的交互。要求接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更的风险也就越少，同时也有利于降低成本。</li><li>定制服务<br>只提供访问者的需要的方法</li><li>接口设计是有限度的<br>接口的设计粒度越小，系统越灵活</li></ol><hr><h1 id="迪米特法则——最少知识原则"><a href="#迪米特法则——最少知识原则" class="headerlink" title="迪米特法则——最少知识原则"></a>迪米特法则——最少知识原则</h1><p>一个对象应该对其他对象有最少的了解</p><h2 id="原则-1"><a href="#原则-1" class="headerlink" title="原则"></a>原则</h2><ol><li>只和朋友交流<br>两个对象之间耦合就成为朋友，组合、聚合、依赖等</li><li>朋友间也是有距离的</li><li>是自己的就是自己的<br>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li><li>谨慎使用Serializable</li></ol><h2 id="核心观念"><a href="#核心观念" class="headerlink" title="核心观念"></a>核心观念</h2><p>类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。但解耦是有限度的。</p><hr><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。<br>开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，底层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段</p><h2 id="软件实体"><a href="#软件实体" class="headerlink" title="软件实体"></a>软件实体</h2><ol><li>项目或软件产品中按照一定的逻辑规则划分的模块</li><li>抽象和类</li><li>方法</li></ol><h2 id="变化的归纳"><a href="#变化的归纳" class="headerlink" title="变化的归纳"></a>变化的归纳</h2><ol><li>逻辑变化</li><li>子模块变化</li><li>可见视图变化</li></ol><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><ol><li>开闭原则对测试的影响</li><li>开闭原则可以提高复用性<br>粒度越小，被复用的可能性越大</li><li>开闭原则可以提高可维护性</li><li>面向对象开发的要求</li></ol><h2 id="如何使用开闭原则"><a href="#如何使用开闭原则" class="headerlink" title="如何使用开闭原则"></a>如何使用开闭原则</h2><ol><li>抽象约束</li><li>元数据控制模块行为</li><li>制定项目章程</li><li>封装变化</li></ol><h2 id="注意以下问题"><a href="#注意以下问题" class="headerlink" title="注意以下问题"></a>注意以下问题</h2><ol><li>开闭原则也只是一个原则</li><li>项目规章非常重要</li><li>预知变化</li></ol><p>参考<br>《设计模式之禅》</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mysql 数据类型</title>
      <link href="/2018/11/06/Mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/11/06/Mysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><blockquote><ul><li>TINYINT = 2^8 bit = 1字节</li><li>SMALLINT = 2 * 2^8 bit = 2字节</li><li>MEDIUMINT = 3 * 2^8 bit = 3字节</li><li>INT = INTEGER = 4 * 2^8 bit = 4字节</li><li>BIGINT = 8 * 2^8 bit = 8字节</li></ul></blockquote><p><em>取值范围如果加了 unsigned，则最大值翻倍</em></p><a id="more"></a><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><blockquote><ul><li>FLOAT = 4 * 2^8 = 4字节</li><li>DOUBLE = 8 * 2^8 bit = 8字节</li><li>DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2，否则为D+2。</li></ul></blockquote><p><em>D&lt;=M &amp;&amp; &amp;&amp; M&gt;=0 &amp;&amp; D&lt;=30, M&gt;=1 &amp;&amp; M&lt;=65。</em></p><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><blockquote><ul><li>DATE = 3字节 YYYY-MM-DD</li><li>TIME = 3字节 HH:MM:SS</li><li>YEAR = 1字节 YYYY</li><li>DATETIME = 8字节 YYYY-MM-DD HH:MM:SS</li><li>TIMESTAMP = 4字节 2147483647（类似INT）</li></ul></blockquote><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><blockquote><ul><li>CHAR = 2^8字节（定长，不区分大小写）</li><li>VARCHAR = 2^16字节（变长，不区分大小写）</li></ul></blockquote><p><em>char为定长，后面加空格，如果数据中末尾有空格会被去掉，且不区分大小写</em></p><blockquote><ul><li>TINYBLOB = 2^8字节 不超过 255 个字符的二进制字符串</li><li>TINYTEXT = 2^8字节</li></ul></blockquote><blockquote><ul><li>BLOB = 2^8 * 2^8 = 2^16字节</li><li>TEXT = 2^8 * 2^8 = 2^16字节</li></ul></blockquote><blockquote><ul><li>MEDIUMBLOB = 2^8 <em> 2^8 </em> 2^8 = 2^24字节</li><li>MEDIUMTEXT = 2^8 <em> 2^8 </em> 2^8 = 2^24字节</li></ul></blockquote><blockquote><ul><li>LONGBLOB = 2^8 <em> 2^8 </em> 2^8* 2^8 = 2^32字节</li><li>LONGTEXT = 2^8 <em> 2^8 </em> 2^8* 2^8 = 2^32字节</li></ul></blockquote><h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><h3 id="一个汉字占多少长度与编码有关：（MySQL-5-0-以上的版本）"><a href="#一个汉字占多少长度与编码有关：（MySQL-5-0-以上的版本）" class="headerlink" title="一个汉字占多少长度与编码有关：（MySQL 5.0 以上的版本）"></a>一个汉字占多少长度与编码有关：（MySQL 5.0 以上的版本）</h3><ul><li>UTF－8：一个汉字（含繁体）＝3个字节 ；</li><li>GBK：一个汉字＝2个字节</li></ul><h3 id="char-和-varchar-区别："><a href="#char-和-varchar-区别：" class="headerlink" title="char 和 varchar 区别："></a>char 和 varchar 区别：</h3><ul><li>CHAR和VARCHAR在存储或检索过程中不进行大小写转换。</li><li>char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。</li><li>char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或2个字节(n&gt;255)，多的字节用来记录长度。所以 varchar(4),存入 3 个字符将占用 4 个字节。</li><li>char 类型的字符串检索速度要比 varchar 类型的快。</li></ul><h3 id="varchar-和-text-区别："><a href="#varchar-和-text-区别：" class="headerlink" title="varchar 和 text 区别："></a>varchar 和 text 区别：</h3><ul><li>varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或 2 个字节(n&gt;255)，text 是实际字符数 +2 个字节。</li><li>text 类型不能有默认值。</li><li>varchar 可直接创建索引，text 创建索引指定索引前缀的长度。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。</li></ul><h3 id="二进制数据-Blob-和-text-区别："><a href="#二进制数据-Blob-和-text-区别：" class="headerlink" title="二进制数据(_Blob) 和 text 区别："></a>二进制数据(_Blob) 和 text 区别：</h3><ul><li>BLOB 是一个二进制大对象</li><li>_BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。</li><li>_BLOB存储的数据只能整体读出。</li><li>_TEXT可以指定字符集，_BLO不用指定字符集。</li></ul><h3 id="ENUM-和-SET-区别："><a href="#ENUM-和-SET-区别：" class="headerlink" title="ENUM 和 SET 区别："></a>ENUM 和 SET 区别：</h3><ul><li>ENUM = 1字节或2字节 最多2字节（2^16）</li><li>ENUM是一个字符串对象，可以插入空字符串””（索引：0）和NULL（索引：NULL），从1开始编号。其值来自表创建时在列规定中显式枚举的一列值</li><li>SET = 1字节或2字节或3字节或4字节或8字节</li><li>SET是一个字符串对象，可以有零或多个值，最多可以设置64个值，其值来自表创建时规定的允许的一列值</li></ul><p>参考<br><a href="http://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-data-types.html</a><br><a href="https://www.cnblogs.com/Caveolae/p/7058890.html" target="_blank" rel="noopener">https://www.cnblogs.com/Caveolae/p/7058890.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
