<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[六大设计原则(SOLID)]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99(SOLID)%2F</url>
    <content type="text"><![CDATA[单一职责原则一个接口或类只有一个原因引起变化 好处 类的复杂度降低 可读性提高 可维护性提高 变更引起的风险降低 难以实现的原因环境、工作量、人员的技术水平、硬件资源、文化差异… 里式替换原则为良好的继承定义了一个规范 规则 子类必须完全实现父类的方法。如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承 子类可以有自己的个性 覆盖或实现父类的方法时输入参数可以被放大子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松 覆写或实现父类的方法时输出结果可以被缩小子类返回值必须和父类返回值同类型或是父类返回值的子类 依赖倒置原则正置是面向实现编程，倒置是面向接口编程是实现开闭原则的重要途径本质是通过抽象（接口或抽象类）使各个类或模块的是想彼此独立，不互相影响，实现模块间的松耦合。 定义 高层模块不应该依赖底层模块，两者都应该依赖其抽象抽象指接口或抽象类 抽象不应该依赖细节 细节应该依赖抽象 减少类间的耦合性，提高系统的稳定性依赖是可传递的 三种写法 构造函数传递依赖对象 Setter方法传递依赖对象 接口声明依赖对象 原则 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备 变量的表面类型尽量是接口或者是抽象类 任何类都不应该从具体类派生 尽量不要覆写基类的方法类型依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响 结合里氏替换原则使用接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确地实现业务逻辑，同时在适当的时候对父类进行细化。 接口隔离原则类型 实例接口 类接口 定义 客户端不应该依赖它不需要的接口 类间的依赖关系应该建立在最小的接口上 接口尽量细化，同时接口中的方法尽量少与单一职责的不同与单一职责的视角不同，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；接口隔离原则是要求接口的方法尽量少，提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问 保证接口的纯洁性 接口要尽量小根于接口隔离原则拆分接口时，首先必须满足单一职责原则 接口要高内聚提高接口、类、模块的处理能力，减少对外的交互。要求接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统开发越有利，变更的风险也就越少，同时也有利于降低成本。 定制服务只提供访问者的需要的方法 接口设计是有限度的接口的设计粒度越小，系统越灵活 迪米特法则——最少知识原则一个对象应该对其他对象有最少的了解 原则 只和朋友交流两个对象之间耦合就成为朋友，组合、聚合、依赖等 朋友间也是有距离的 是自己的就是自己的如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中 谨慎使用Serializable 核心观念类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。但解耦是有限度的。 开闭原则一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，底层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段 软件实体 项目或软件产品中按照一定的逻辑规则划分的模块 抽象和类 方法 变化的归纳 逻辑变化 子模块变化 可见视图变化 为什么 开闭原则对测试的影响 开闭原则可以提高复用性粒度越小，被复用的可能性越大 开闭原则可以提高可维护性 面向对象开发的要求 如何使用开闭原则 抽象约束 元数据控制模块行为 制定项目章程 封装变化 注意以下问题 开闭原则也只是一个原则 项目规章非常重要 预知变化]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 数据类型]]></title>
    <url>%2F2018%2F11%2F06%2FMysql-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本类型整型 TINYINT = 2^8 bit = 1字节 SMALLINT = 2 * 2^8 bit = 2字节 MEDIUMINT = 3 * 2^8 bit = 3字节 INT = INTEGER = 4 * 2^8 bit = 4字节 BIGINT = 8 * 2^8 bit = 8字节 取值范围如果加了 unsigned，则最大值翻倍 浮点型 FLOAT = 4 * 2^8 = 4字节 DOUBLE = 8 * 2^8 bit = 8字节 DECIMAL 对DECIMAL(M,D) ，如果M&gt;D，为M+2，否则为D+2。 D&lt;=M &amp;&amp; &amp;&amp; M&gt;=0 &amp;&amp; D&lt;=30, M&gt;=1 &amp;&amp; M&lt;=65。 日期和时间类型 DATE = 3字节 YYYY-MM-DD TIME = 3字节 HH:MM:SS YEAR = 1字节 YYYY DATETIME = 8字节 YYYY-MM-DD HH:MM:SS TIMESTAMP = 4字节 2147483647（类似INT） 字符串类型 CHAR = 2^8字节（定长，不区分大小写） VARCHAR = 2^16字节（变长，不区分大小写） char为定长，后面加空格，如果数据中末尾有空格会被去掉，且不区分大小写 TINYBLOB = 2^8字节 不超过 255 个字符的二进制字符串 TINYTEXT = 2^8字节 BLOB = 2^8 * 2^8 = 2^16字节 TEXT = 2^8 * 2^8 = 2^16字节 MEDIUMBLOB = 2^8 2^8 2^8 = 2^24字节 MEDIUMTEXT = 2^8 2^8 2^8 = 2^24字节 LONGBLOB = 2^8 2^8 2^8* 2^8 = 2^32字节 LONGTEXT = 2^8 2^8 2^8* 2^8 = 2^32字节 其他说明一个汉字占多少长度与编码有关：（MySQL 5.0 以上的版本） UTF－8：一个汉字（含繁体）＝3个字节 ； GBK：一个汉字＝2个字节 char 和 varchar 区别： CHAR和VARCHAR在存储或检索过程中不进行大小写转换。 char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以 char 类型存储的字符串末尾不能有空格，varchar 不限于此。 char(n) 固定长度，char(4) 不管是存入几个字符，都将占用 4 个字节，varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或2个字节(n&gt;255)，多的字节用来记录长度。所以 varchar(4),存入 3 个字符将占用 4 个字节。 char 类型的字符串检索速度要比 varchar 类型的快。 varchar 和 text 区别： varchar 可指定 n，text 不能指定，内部存储 varchar 是存入的实际字符数 +1 个字节（n&lt;=255）或 2 个字节(n&gt;255)，text 是实际字符数 +2 个字节。 text 类型不能有默认值。 varchar 可直接创建索引，text 创建索引指定索引前缀的长度。varchar 查询速度快于 text, 在都创建索引的情况下，text 的索引似乎不起作用。 二进制数据(_Blob) 和 text 区别： BLOB 是一个二进制大对象 _BLOB和_text存储方式不同，_TEXT以文本方式存储，英文存储区分大小写，而_Blob是以二进制方式存储，不分大小写。 _BLOB存储的数据只能整体读出。 _TEXT可以指定字符集，_BLO不用指定字符集。 ENUM 和 SET 区别： ENUM = 1字节或2字节 最多2字节（2^16） ENUM是一个字符串对象，可以插入空字符串””（索引：0）和NULL（索引：NULL），从1开始编号。其值来自表创建时在列规定中显式枚举的一列值 SET = 1字节或2字节或3字节或4字节或8字节 SET是一个字符串对象，可以有零或多个值，最多可以设置64个值，其值来自表创建时规定的允许的一列值 来源：http://www.runoob.com/mysql/mysql-data-types.htmlhttps://www.cnblogs.com/Caveolae/p/7058890.html]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
