<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>Koo&#39;s blog</title>

  
  <meta name="author" content="Koo">
  

  
  <meta name="description" content="学习记录，每天进步一点点">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Koo&#39;s blog">

  
  <meta property="og:image" content="/favicon.ico">
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Koo&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Koo&#39;s blog</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/15/记laravel-chunk遇到的坑/"><span>记 laravel chunk 遇到的坑</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/15/记laravel-chunk遇到的坑/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-15T06:15:43.000Z">
          2018-11-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>laravel给我们提供了方便的chunk方法，如果你需要处理数千个 Eloquent 记录，可以使用 chunk 命令。chunk 方法会检索 Eloquent 模型的「分块」，将它们提供给指定的 Closure 进行处理。在处理大型结果集时，使用 chunk 方法可节省内存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flight::chunk(100, function ($flights) &#123;</span><br><span class="line">    foreach ($flights as $flight) &#123;</span><br><span class="line">        //对每条数据做一些处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果’flights’表中有1000条数据，将拆成10次查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">select * from `flights` limit 100 offset 0</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 100</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 200</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 300</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 400</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 500</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 600</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 700</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 800</span><br><span class="line">//对每条数据做一些处理</span><br><span class="line">select * from `flights` limit 100 offset 900</span><br><span class="line">//对每条数据做一些处理</span><br></pre></td></tr></table></figure></p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/laravel/">laravel</a><a href="/tags/php/">php</a><a href="/tags/chunk/">chunk</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/原型模式/"><span>原型模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/原型模式/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-13T07:26:06.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>不通过new关键字来产生一个对象，而是通过对象复制来实现的模式叫做原型模式<br>简单程度仅次于单例模式和迭代器模式，使用广泛<br>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建的对象<br>核心就是clone方法，通过该方法进行对象的拷贝，JAVA提供了Cloneable接口，标示这个对象是可拷贝的。覆写clone方法。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>性能优良。原型模式是内存二进制流的拷贝。</li>
<li>逃避构造函数的约束。不执行构造函数，优点和缺点都是减少了约束。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>资源优化场景。类初始化需要消化非常多的资源，包括数据和硬件资源等。</li>
<li>性能和安全要求的场景。通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景。一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时。</li>
</ol>
<p><em>原型模式很少单独出现，一般和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者</em></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>构造函数不会被执行</li>
<li>浅拷贝和深拷贝<br><em>使用原型模式时，引用的成员变量必须满足两个条件才不会被拷贝：一是类的成员变量，而不是方法内变量；二是必须是一个可变的引用对象，而不是一个原始类型或不可变类型</em></li>
<li>clone与final关键字冲突</li>
</ol>
<p>来源：<br>《设计模式之禅》</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/原型模式/">原型模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/代理模式/"><span>代理模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/代理模式/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-13T05:42:28.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>也叫委托模式，为其他对象提供一种代理，以控制对这个对象的访问。使用率非常高。提供非常好的访问控制。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><ol>
<li>Subject抽象主题角色。可以是抽象类也可以是接口</li>
<li>RealSubject具体主题角色。也称为被委托角色或被代理角色，业务逻辑的具体执行者</li>
<li>Proxy代理主题角色。也称为委托类、代理类</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RealSubject implements Subject &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        //业务逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Proxy implements Subject &#123;</span><br><span class="line">    private Subject subject = null;</span><br><span class="line">    </span><br><span class="line">    public Proxy() &#123;</span><br><span class="line">        this.subject = new Proxy();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Proxy(Subject subject) &#123;</span><br><span class="line">        this.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void request() &#123;</span><br><span class="line">        this.before();</span><br><span class="line">        this.subject.request();</span><br><span class="line">        this.after();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void before() &#123;&#125;</span><br><span class="line">    public void after() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>职责清晰。真实角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰</li>
<li>高扩展性。具体主题角色随时发生变化，不管怎么变化，只要实现了接口，那代理类完全就可以在不做任何修改的情况下使用。</li>
</ol>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Spring AOP</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ol>
<li>普通代理，要求客户端只能访问代理角色，而不能访问真实角色。<br>普通代理模式的约束问题，尽量通过团队内的变成规范类约束，因为每一个主题类是可被重用的和可维护的，实用技术约束的方式对系统维护是一种非常不利的因素</li>
<li>强制代理，强制必须通过真是角色查找到代理角色，否则不能访问。只有通过真实角色指定的代理类才可以访问，由真是角色管理代理角色。可以不知道代理的存在，但是你的所作所为还是需要代理为你提供。</li>
<li>代理是有个性的。代理类可以为真实角色预处理消息、过滤消息、消息转发、事后处理消息等功能。可以代理多个真实角色。</li>
<li>动态代理。动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪个对象。横切面编程（AOP）核心就是动态代理机制。？？</li>
</ol>
<p>来源：<br>《设计模式之禅》</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/代理模式/">代理模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/建造者模式/"><span>建造者模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/建造者模式/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-13T03:12:56.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CarBuilder &#123;</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public abstract void setSequence(ArrayList&lt;String&gt; sequence);</span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public abstract CarModel getCarModel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BenzBuilder extends CarBuilder &#123;</span><br><span class="line">    private BenzModel benz = new BenzModel();</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public void setSequence(ArrayList&lt;String&gt; sequence)&#123;</span><br><span class="line">        this.benz.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public CarModel getCarModel() &#123;</span><br><span class="line">        return this.benz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BMWBuilder extends CarBuilder &#123;</span><br><span class="line">    private BMWModel bmw = new BMWModel();</span><br><span class="line">    //设置组装顺序</span><br><span class="line">    public void setSequence(ArrayList&lt;String&gt; sequence)&#123;</span><br><span class="line">        this.bmw.setSequence(sequence);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //设置完毕顺序后，就可以直接拿到这个车辆模型</span><br><span class="line">    public CarModel getCarModel() &#123;</span><br><span class="line">        return this.bmw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Director &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; sequence = new ArrayList();</span><br><span class="line">    private BenzBuilder benzBuilder = new BenzBuilder();</span><br><span class="line">    private BMWBuilder bmwBuilder = new bmwBuilder();</span><br><span class="line">    </span><br><span class="line">    public BenzModel getABenzModel() &#123;</span><br><span class="line">        this.sequence.clear();</span><br><span class="line">        </span><br><span class="line">        this.sequesce.add(&quot;start&quot;);</span><br><span class="line">        this.sequesce.add(&quot;stop&quot;);</span><br><span class="line">        this.benzBuilder.setSequence(this.sequence);</span><br><span class="line">        return (BenzModel)this.benzBuilder.getCarModel();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Director director = new Director();</span><br><span class="line">        </span><br><span class="line">        for(int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">            director.getABenzModel().run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>需求是无底洞，是无理性的</em></p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/建造者模式/">建造者模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/模板方法模式/"><span>模板方法模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/模板方法模式/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-13T02:17:06.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">//抽象悍马模型</span><br><span class="line">public abstract class HummerModel &#123;</span><br><span class="line">    public abstract void start();</span><br><span class="line">    public abstract void stop();</span><br><span class="line">    public abstract void alarm();</span><br><span class="line">    public abstract void engineBoom();</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        this.start(); </span><br><span class="line">        this.engineBoom(); </span><br><span class="line">        this.alarm(); </span><br><span class="line">        this.stop(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//悍马模型H1</span><br><span class="line">public class HummerH1Model extends HummerModel &#123;</span><br><span class="line">    public void alarm() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void engineBoom() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//悍马模型H2</span><br><span class="line">public class HummerH2Model extends HummerModel &#123;</span><br><span class="line">    public void alarm() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void engineBoom() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Client() &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HummerModel h1 = new HummerH1Model();</span><br><span class="line">        h1.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>在软件开发过程中，如果相同的一段代码复制过两次，就需要对设计产生怀疑，架构师要明确地说明为什么相同的逻辑要出现两次或更多次</em></p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/模板方法模式/">模板方法模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/抽象工厂模式/"><span>抽象工厂模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/抽象工厂模式/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-13T02:08:40.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为创建一组相关或相互依赖的对象提供一个接口，并且无需指定他们的具体类<br>抽象工厂模式是工厂方法模式的升级版本，在多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式<br>有N个产品族，在抽象工厂类中就应该有N个创建方法</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>封装性。每个产品的实现类不是高层模块要关心的，高层模块只关心接口，抽象，不关心对象是如何创建出来的。工厂类负责关心对象是如何创建出来的，产品只要知道工厂类是谁，就能创建出一个需要的对象，省时省力。</li>
<li>产品族内的约束为非公开状态。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>最大缺点是：产品族扩展非常困难，严重违反开闭原则！</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>一个对象族（或是一组没有任何关系的对象）都有相同的约束，则可以使用抽象工厂模式<br>例：一个文本编辑器和一个图片处理器，都是软件实体，在操作系统不同下，虽然功能和界面相同，但代码实现不同，图片处理器也有类似情况。这就是具有了共同的约束条件：操作系统类型。于是可以使用抽象工厂模式，产生不同操作系统下的编辑器和图片处理器</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>产品族扩展非常困难，但产品等级扩展非常简单。横向扩展容易，纵向扩展困难。例：不同肤色和不同性别的人类例子中，扩展肤色困难，但是扩展性别简单，这是符合开闭原则的。<br>在软件产品开发过程中，设计不同操作系统时，都可以考虑使用抽象工厂模式。</p>
<p>来源：<br>《设计模式之禅》</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/抽象工厂模式/">抽象工厂模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/13/工厂方法模式/"><span>工厂方法模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/13/工厂方法模式/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-13T02:03:38.000Z">
          2018-11-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/工厂方法模式/">工厂方法模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/12/单例模式/"><span>单例模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/12/单例模式/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-12T10:54:04.000Z">
          2018-11-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Singleton类称为单例类<br>通过定义一个私有访问权限的构造函数，避免被其他类new出来一个对象</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式优势明显</li>
<li>由于单例模式只生成一个实例，所以减少了系统的性能开销。当一个对象的产生需要比较多资源的时候，如读取配置、产生其他依赖对象时，则可以通过在<em>应用启动时</em>直接产生一个单例对象，然后用永久驻留内存的方式来解决。</li>
<li>单例模式可以避免对资源的多重占用，如避免对同一资源文件的同时写操作</li>
<li>单例模式可以在系统设置全局访问点，优化和共享资源访问。如设计一个单例类，负责所有数据表的映射处理。</li>
</ol>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a><a href="/tags/单例模式/">单例模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/12/六大设计原则(SOLID)/"><span>六大设计原则(SOLID)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/12/六大设计原则(SOLID)/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-12T06:05:00.000Z">
          2018-11-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>一个接口或类只有一个原因引起变化</p>
<h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol>
<li>类的复杂度降低</li>
<li>可读性提高</li>
<li>可维护性提高</li>
<li>变更引起的风险降低</li>
</ol>
<h2 id="难以实现的原因"><a href="#难以实现的原因" class="headerlink" title="难以实现的原因"></a>难以实现的原因</h2><p>环境、工作量、人员的技术水平、硬件资源、文化差异…</p>
<hr>
<h1 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h1><p>为良好的继承定义了一个规范</p>
<h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ol>
<li>子类必须完全实现父类的方法。<br>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承</li>
<li>子类可以有自己的个性</li>
<li>覆盖或实现父类的方法时输入参数可以被放大<br>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松</li>
<li>覆写或实现父类的方法时输出结果可以被缩小<br>子类返回值必须和父类返回值同类型或是父类返回值的子类</li>
</ol>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/设计模式/">设计模式</a>
    </span>
    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2018/11/06/Mysql-数据类型/"><span>Mysql 数据类型</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/11/06/Mysql-数据类型/" rel="bookmark">
        <time class="entry-date published" datetime="2018-11-06T06:53:35.000Z">
          2018-11-06
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><blockquote>
<ul>
<li>TINYINT = 2^8 bit = 1字节</li>
<li>SMALLINT = 2 * 2^8 bit = 2字节</li>
<li>MEDIUMINT = 3 * 2^8 bit = 3字节</li>
<li>INT = INTEGER = 4 * 2^8 bit = 4字节</li>
<li>BIGINT = 8 * 2^8 bit = 8字节</li>
</ul>
</blockquote>
<p><em>取值范围如果加了 unsigned，则最大值翻倍</em></p>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/mysql/">mysql</a>
    </span>
    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    <br>
    
    &copy; 2018 Koo
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>